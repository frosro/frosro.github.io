<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>并发编程（三） | BETTER LATE THAN NEVER</title><meta name="description" content="并发编程（三）"><meta name="author" content="Frosro"><meta name="copyright" content="Frosro"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="并发编程（三）"><meta name="twitter:description" content="并发编程（三）"><meta name="twitter:image" content="https://frosro.github.io/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="并发编程（三）"><meta property="og:url" content="https://frosro.github.io/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"><meta property="og:site_name" content="BETTER LATE THAN NEVER"><meta property="og:description" content="并发编程（三）"><meta property="og:image" content="https://frosro.github.io/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://frosro.github.io/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"><link rel="next" title="并发编程（二）" href="https://frosro.github.io/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="BETTER LATE THAN NEVER" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#三、JUC-java-util-concurrent"><span class="toc-number">1.</span> <span class="toc-text">三、JUC:java.util.concurrent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-集合"><span class="toc-number">1.1.</span> <span class="toc-text">3.1 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-BlockingQueue"><span class="toc-number">1.1.1.</span> <span class="toc-text">3.1.1 BlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-ArrayBlockingQueue"><span class="toc-number">1.1.2.</span> <span class="toc-text">3.1.2 ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-PriorityBlockingQueue"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.1.3 PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-4-DelayQueue"><span class="toc-number">1.1.4.</span> <span class="toc-text">3.1.4 DelayQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-5-LinkedBlockingQueue"><span class="toc-number">1.1.5.</span> <span class="toc-text">3.1.5 LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-6-LinkedBlockingDeque"><span class="toc-number">1.1.6.</span> <span class="toc-text">3.1.6 LinkedBlockingDeque</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-7-SynchronousQueue"><span class="toc-number">1.1.7.</span> <span class="toc-text">3.1.7 SynchronousQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-8-LinkedTransferQueue"><span class="toc-number">1.1.8.</span> <span class="toc-text">3.1.8 LinkedTransferQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-9-ConcurrentHashMap"><span class="toc-number">1.1.9.</span> <span class="toc-text">3.1.9 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#HashMap容量"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">HashMap容量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#效率低下的-HashTable-容器"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">效率低下的 HashTable 容器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-10-ConcurrentSkipListMap"><span class="toc-number">1.1.10.</span> <span class="toc-text">3.1.10 ConcurrentSkipListMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-11-ConcurrentSkipListSet"><span class="toc-number">1.1.11.</span> <span class="toc-text">3.1.11 ConcurrentSkipListSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-12-CopyOnWriteArrayList"><span class="toc-number">1.1.12.</span> <span class="toc-text">3.1.12 CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-13-CopyOnWriteArraySet"><span class="toc-number">1.1.13.</span> <span class="toc-text">3.1.13 CopyOnWriteArraySet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-原子操作类"><span class="toc-number">1.2.</span> <span class="toc-text">3.2 原子操作类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-原子基本数据类型"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.2.1 原子基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-原子数组"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2.2 原子数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-原子引用类型"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.2.3 原子引用类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-原子更新字段类型"><span class="toc-number">1.2.4.</span> <span class="toc-text">3.2.4 原子更新字段类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-锁：Lock"><span class="toc-number">1.3.</span> <span class="toc-text">3.3 锁：Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-ReentrantLock"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.3.1 ReentrantLock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-LockSupport"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.3.2 LockSupport</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-Condition"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3.3 Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#源码探索"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">源码探索</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BETTER LATE THAN NEVER</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">并发编程（三）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-01-09 17:20:30"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-01-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-01-09 23:02:25"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-01-09</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>title: 并发编程（三）<br>categories: 🐺JAVA<br>tags: </p>
<ul>
<li>JAVA</li>
<li>并发编程<br>date: 2021-01-09 17:20:30<br>cover:</li>
</ul>
<h3 id="三、JUC-java-util-concurrent"><a href="#三、JUC-java-util-concurrent" class="headerlink" title="三、JUC:java.util.concurrent"></a>三、JUC:java.util.concurrent</h3><h4 id="3-1-集合"><a href="#3-1-集合" class="headerlink" title="3.1 集合"></a>3.1 集合</h4><h5 id="3-1-1-BlockingQueue"><a href="#3-1-1-BlockingQueue" class="headerlink" title="3.1.1 BlockingQueue"></a>3.1.1 BlockingQueue</h5><p><strong>什么是阻塞队列？</strong></p>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时， 获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>阻塞队列提供了四种处理方法:</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。 </li>
<li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元 素，如果没有则返回null</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直 到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻 塞消费者线程，直到队列可用。 </li>
<li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出</li>
</ul>
<p>阻塞队列接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue的核心方法：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，成功返回true, 否则抛出异常。如果向限定了容量的队列中插入值，推 荐使用offer()方法。    </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出 空指针异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的 空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"> <span class="comment">//在给定的时间插入元素e到队列中，如果设置成功返回true, 否则返回false.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//检索并从队列的头部删除元素，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该 方法取得了该值。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//在给定的时间范围内，检索并从队列的头部删除元素，从队列中获取值，如果没有取到会抛出异常。</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>        </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//获取队列中剩余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从队列中移除指定的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//判断队列中是否包含该值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//将队列中值，全部移除，并追加到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line">    <span class="comment">//指定最多数量限制将队列中值，全部移除，并追加到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承关系</p>
<ul>
<li><p>子接口： </p>
<p><strong>BlockingDeque</strong></p>
</li>
</ul>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img1.jpg"  alt></p>
<p>​        <strong>TransferQueue</strong></p>
<p>TransferQueue继承了BlockingQueue,并扩展了一些新方法。 </p>
<p>BlockingQueue是指这样的一个队列：当生产者向队列添加元素但队列已满时，生产者会被阻塞；当消费者从队列移除元素但队列为空时，消费者会被阻塞。</p>
<p>TransferQueue则更进一步，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费 （不仅仅是添加到队列里就完事）。新添加的transfer方法用来实现这种约束。顾名思义，阻塞就是发生在元素从一个线程transfer到另一个线程的过程中，它有效地实现了元素在线程之间的传递（以建立Java内存模型中的happens-before关系的方式）。 TransferQueue还包括了其他的一些方法：两个tryTransfer方法，一个是非阻塞的，另一个带 有timeout参数设置超时时间的。还有两个辅助方法hasWaitingConsumer()和getWaitingConsumerCount()。 </p>
<ul>
<li><p>实现类 </p>
<p>ArrayBlockingQueue </p>
<p>DelayQueue</p>
<p>LinkedBlockingDeque</p>
<p>LinkedBlockingQueue</p>
<p>LinkedTransferQueue </p>
<p>PriorityBlockingQueue </p>
<p>SynchronousQueue</p>
</li>
</ul>
<h5 id="3-1-2-ArrayBlockingQueue"><a href="#3-1-2-ArrayBlockingQueue" class="headerlink" title="3.1.2 ArrayBlockingQueue"></a>3.1.2 ArrayBlockingQueue</h5><p><strong>ArrayBlockingQueue</strong> 是一个线程安全的、基于数组、有界的、阻塞的、FIFO 队列。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。<br>此类基于 java.util.concurrent.locks.ReentrantLock 来实现线程安全，所以提供了 ReentrantLock 所能支持的公平性选择。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>,<span class="keyword">true</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);</span><br><span class="line">                blockingQueue.put(element++);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-PriorityBlockingQueue"><a href="#3-1-3-PriorityBlockingQueue" class="headerlink" title="3.1.3 PriorityBlockingQueue"></a>3.1.3 PriorityBlockingQueue</h5><p><strong>PriorityBlockingQueue</strong>是带优先级的无界阻塞队列，每次出队都返回优先级高的元素，是二叉树小堆的实现。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 		PriorityBlockingQueue&lt;PriorityElement&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Random random=<span class="keyword">new</span> Random();</span><br><span class="line">            PriorityElement ele = <span class="keyword">new</span> PriorityElement(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            queue.put(ele);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityElement</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">PriorityElement</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;<span class="comment">//定义优先级    </span></span><br><span class="line">    PriorityElement(<span class="keyword">int</span> priority) &#123;</span><br><span class="line">        <span class="comment">//初始化优先级        </span></span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PriorityElement o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照优先级大小进行排序</span></span><br><span class="line">        <span class="keyword">return</span> priority &gt;= o.getPriority() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PriorityElement [priority="</span> + priority + <span class="string">"]"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-DelayQueue"><a href="#3-1-4-DelayQueue" class="headerlink" title="3.1.4 DelayQueue"></a>3.1.4 DelayQueue</h5><p><strong>DelayQueue</strong>队列中每个元素都有个过期时间，并且队列是个优先级队列，当从队列获取元素时候，只有过期元素才会出队列。</p>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueTest</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Item item1 = <span class="keyword">new</span> Item(<span class="string">"item1"</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        Item item2 = <span class="keyword">new</span> Item(<span class="string">"item2"</span>,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        Item item3 = <span class="keyword">new</span> Item(<span class="string">"item3"</span>,<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">        DelayQueue&lt;Item&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        queue.put(item1);</span><br><span class="line">        queue.put(item2);</span><br><span class="line">        queue.put(item3);</span><br><span class="line">        System.out.println(<span class="string">"begin time:"</span> + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Item take = queue.take();</span><br><span class="line">            System.out.format(<span class="string">"name:&#123;%s&#125;, time:&#123;%s&#125;\n"</span>,take.name, LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 触发时间*/</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String name, <span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.time = System.currentTimeMillis() + (time &gt; <span class="number">0</span>? unit.toMillis(time): <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> time - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;  </span><br><span class="line">        Item item = (Item) o;  </span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.time - item.time;  </span><br><span class="line">        <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Item&#123;"</span> + </span><br><span class="line">            <span class="string">"time="</span> + time +  </span><br><span class="line">            <span class="string">", name='"</span> + name + <span class="string">'\''</span> +  </span><br><span class="line">            <span class="string">'&#125;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-1-5-LinkedBlockingQueue"><a href="#3-1-5-LinkedBlockingQueue" class="headerlink" title="3.1.5 LinkedBlockingQueue"></a>3.1.5 LinkedBlockingQueue</h5><p><strong>LinkedBlockingQueue</strong>是一个基于单向链表的、范围任意的（其实是有界的）、FIFO 阻塞队列。访问 与移除操作是在队头进行，添加操作是在队尾进行，并分别使用不同的锁进行保护，只有在可能涉及多 个节点的操作才同时对两个锁进行加锁。</p>
<p>队列是否为空、是否已满仍然是通过元素数量的计数器（count）进行判断的，由于可以同时在队头、 队尾并发地进行访问、添加操作，所以这个计数器必须是线程安全的，这里使用了一个原子类 AtomicInteger ，这就决定了它的容量范围是： 1 – Integer.MAX_VALUE。<br>由于同时使用了两把锁，在需要同时使用两把锁时，加锁顺序与释放顺序是非常重要的：必须以固定的 顺序进行加锁，再以与加锁顺序的相反的顺序释放锁。<br>头结点和尾结点一开始总是指向一个哨兵的结点，它不持有实际数据，当队列中有数据时，头结点仍然 指向这个哨兵，尾结点指向有效数据的后一个结点。这样做的好处在于，与计数器 count 结合后， 对队头、队尾的访问可以独立进行，而不需要判断头结点与尾结点的关系。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);   </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);  </span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();      </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;          </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);                blockingQueue.put(element++);           </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;   </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;      </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;  </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());    </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;     </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-6-LinkedBlockingDeque"><a href="#3-1-6-LinkedBlockingDeque" class="headerlink" title="3.1.6 LinkedBlockingDeque"></a>3.1.6 LinkedBlockingDeque</h5><p><strong>LinkedBlockingDeque</strong>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两 端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的 竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst， offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移 除双端队列的第一个元素。以Last单词结尾的方法，表示插入，获取或移除双端队列的后一个元素。 另外插入方法add等同于addLast，移除方法remove等效于removeFirst。在初始化 LinkedBlockingDeque时可以初始化队列的容量，用来防止其再扩容时过渡膨胀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue; <span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;Integer&gt;();  </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);  </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);     </span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;     </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;    </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);  </span><br><span class="line">                blockingQueue.put(element++);        </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;      </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);            e.printStackTrace();  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    	System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">try</span> &#123;        </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;    </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());  </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;     </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;       </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-7-SynchronousQueue"><a href="#3-1-7-SynchronousQueue" class="headerlink" title="3.1.7 SynchronousQueue"></a>3.1.7 SynchronousQueue</h5><p><strong>SynchronousQueue</strong>是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待 消费者的移除操作take，反过来也一样。<br>SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因 为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列 的操作也是不允许的。<br>数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲到队列中。<br>SynchronousQueue支持公平访问队列，默认情况下，线程采用非公平策略，如果使用公平策略，等待 的线程采用先进先出的顺序访问队列。<br>SynchronousQueue适合传递性场景，一个使用场景是在线程池里。 Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到 来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();   </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);      </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();     </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);   </span><br><span class="line">                blockingQueue.put(element++);    </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;      </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);       </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;          </span><br><span class="line">                Thread.sleep(<span class="number">1000l</span>);   </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());      </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>); </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-8-LinkedTransferQueue"><a href="#3-1-8-LinkedTransferQueue" class="headerlink" title="3.1.8 LinkedTransferQueue"></a>3.1.8 LinkedTransferQueue</h5><p><strong>LinkedTransferQueue</strong>是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列 LinkedTransferQueue多了tryTransfer和transfer方法。<br>transfer方法。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll() 方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者 在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返 回。transfer方法的关键代码如下：<br>第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元 素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线 程，并执行其他线程。<br>tryTransfer方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接 收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返 回。而transfer方法是必须等到消费者消费了才返回。<br>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者 传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没 消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedTransferQueueTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedTransferQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedTransferQueue&lt;Integer&gt;(); </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue); </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.linkedTransferQueue = linkedTransferQueue;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;     </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);      </span><br><span class="line">                linkedTransferQueue.put(element++);     </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;       </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;    </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.linkedTransferQueue = linkedTransferQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;      </span><br><span class="line">                Thread.sleep(<span class="number">1000l</span>);   </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+linkedTransferQueue.take());       </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;        </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);    </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-9-ConcurrentHashMap"><a href="#3-1-9-ConcurrentHashMap" class="headerlink" title="3.1.9 ConcurrentHashMap"></a>3.1.9 ConcurrentHashMap</h5><h6 id="HashMap容量"><a href="#HashMap容量" class="headerlink" title="HashMap容量"></a>HashMap容量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial </span></span><br><span class="line"><span class="comment">* capacity and load factor. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  initialCapacity the initial capacity </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  loadFactor      the load factor </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative </span></span><br><span class="line"><span class="comment">*         or the load factor is nonpositive </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +      </span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">     initialCapacity = MAXIMUM_CAPACITY;   </span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +                                           loadFactor);  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等 操作，所以非常消耗性能。<br>因此通常建议能提前预估 HashMap 的大小好，尽量的减少扩容带来的性能损耗。<br>线程不安全的 HashMap<br>因为多线程环境下，使用 HashMap 进行 put 操作会引起死循环，导致 CPU 利用率接近 100%，所以 在并发情况下不能使用 HashMap，如以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;      </span><br><span class="line">                <span class="meta">@Override</span>              </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">                    map.put(UUID.randomUUID().toString(), <span class="string">""</span>);     </span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;, <span class="string">"kaikeba"</span> + i).start();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"kaikeba"</span>);</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>

<h6 id="效率低下的-HashTable-容器"><a href="#效率低下的-HashTable-容器" class="headerlink" title="效率低下的 HashTable 容器"></a>效率低下的 HashTable 容器</h6><p>HashTable 容器使用 syncronized来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率 非常低下。因为当一个线程访问 HashTable 的同步方法时，其他线程访问 HashTable 的同步方法 时，可能会进入阻塞或轮询状态。如线程 1 使用 put 进行添加元素，线程 2 不但不能使用 put 方 法添加元素，并且也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();  </span><br><span class="line">        map.put(<span class="string">"key1"</span>, <span class="string">"1"</span>); </span><br><span class="line">        map.put(<span class="string">"key2"</span>, <span class="string">"2"</span>);  </span><br><span class="line">        map.put(<span class="string">"key3"</span>, <span class="string">"3"</span>);    </span><br><span class="line">        map.put(<span class="string">"key4"</span>, <span class="string">"4"</span>);    </span><br><span class="line">        Iterator&lt;String&gt; it = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">            String key = it.next();    </span><br><span class="line">            System.out.println(key + <span class="string">","</span>+ map.get(key));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-10-ConcurrentSkipListMap"><a href="#3-1-10-ConcurrentSkipListMap" class="headerlink" title="3.1.10 ConcurrentSkipListMap"></a>3.1.10 ConcurrentSkipListMap</h5><p>JDK1.6时，为了对高并发环境下的有序Map提供更好的支持，J.U.C新增了一个 ConcurrentNavigableMap接口，ConcurrentNavigableMap很简单，它同时实现了NavigableMap和 ConcurrentMap接口。<br>ConcurrentNavigableMap接口提供的功能也和NavigableMap几乎完全一致，很多方法仅仅是返回的 类型不同。<br>NavigableMap接口，进一步扩展了SortedMap的功能，提供了根据指定Key返回接近项、按升序/降 序返回所有键的视图等功能。<br>J.U.C提供了基于ConcurrentNavigableMap接口的一个实现—— ConcurrentSkipListMap 。 ConcurrentSkipListMap可以看成是并发版本的TreeMap，但是和TreeMap不同是， ConcurrentSkipListMap并不是基于红黑树实现的，其底层是一种类似跳表（Skip List）的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentNavigableMap; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">        ConcurrentSkipListMap&lt;String, Contact&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">        Thread threads[]=<span class="keyword">new</span> Thread[<span class="number">25</span>];    </span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;     </span><br><span class="line">        <span class="comment">//创建和启动25个任务，对于每个任务指定一个大写字母作为ID    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i=<span class="string">'A'</span>; i&lt;<span class="string">'Z'</span>; i++) &#123;   </span><br><span class="line">            Task0 task=<span class="keyword">new</span> Task0(map, String.valueOf(i));     </span><br><span class="line">            threads[counter]=<span class="keyword">new</span> Thread(task);    </span><br><span class="line">            threads[counter].start();   </span><br><span class="line">            counter++;      </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="comment">//使用join()方法等待线程的结束    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">25</span>; i++) &#123;</span><br><span class="line"> 			<span class="keyword">try</span> &#123;               </span><br><span class="line">                threads[i].join();          </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;          </span><br><span class="line">                e.printStackTrace();          </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;          </span><br><span class="line">        System.out.printf(<span class="string">"Size of the map: %d\n"</span>,map.size());   </span><br><span class="line">        Map.Entry&lt;String, Contact&gt; element;           </span><br><span class="line">        Contact contact;      </span><br><span class="line">        <span class="comment">// 使用firstEntry()方法获取map的第一个实体，并输出。 </span></span><br><span class="line">        element=map.firstEntry();     </span><br><span class="line">        contact=element.getValue();        </span><br><span class="line">        System.out.printf(<span class="string">"First Entry: %s: %s\n"</span>,contact.  </span><br><span class="line">                          getName(),contact.getPhone());   </span><br><span class="line">        <span class="comment">//使用lastEntry()方法获取map的最后一个实体，并输出。   </span></span><br><span class="line">        element=map.lastEntry();         </span><br><span class="line">        contact=element.getValue();     </span><br><span class="line">        System.out.printf(<span class="string">"Last Entry: %s: %s\n"</span>,contact.                    getName(),contact.getPhone());        </span><br><span class="line">        <span class="comment">//使用subMap()方法获取map的子map，并输出。</span></span><br><span class="line">        System.out.printf(<span class="string">"Submap from A1996 to B1002: \n"</span>);</span><br><span class="line">        ConcurrentNavigableMap&lt;String, Contact&gt; submap=map.</span><br><span class="line">            subMap(<span class="string">"A1996"</span>, <span class="string">"B1001"</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;     </span><br><span class="line">              </span><br><span class="line">            element=submap.pollFirstEntry();  </span><br><span class="line">            <span class="keyword">if</span> (element!=<span class="keyword">null</span>) &#123;     </span><br><span class="line">                contact=element.getValue();      </span><br><span class="line">                System.out.printf(<span class="string">"%s: %s\n"</span>,contact.getName(),contact.                            getPhone());            </span><br><span class="line">            &#125;         </span><br><span class="line">        &#125; <span class="keyword">while</span> (element!=<span class="keyword">null</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contact</span><span class="params">(String name, String phone)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name;      </span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> phone;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task0</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentSkipListMap&lt;String, Contact&gt; map; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task0</span><span class="params">(ConcurrentSkipListMap&lt;String, Contact&gt; map, String id)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;   </span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;   </span><br><span class="line">            Contact contact = <span class="keyword">new</span> Contact(id, String.valueOf(i + <span class="number">1000</span>));  </span><br><span class="line">            map.put(id + contact.getPhone(), contact);   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-11-ConcurrentSkipListSet"><a href="#3-1-11-ConcurrentSkipListSet" class="headerlink" title="3.1.11 ConcurrentSkipListSet"></a>3.1.11 ConcurrentSkipListSet</h5><p><strong>ConcurrentSkipListSet</strong>，是JDK1.6时J.U.C新增的一个集合工具类，它是一种有序的SET类型。<br>ConcurrentSkipListSet实现了NavigableSet接口，ConcurrentSkipListMap实现了NavigableMap 接口，以提供和排序相关的功能，维持元素的有序性，所以ConcurrentSkipListSet就是一种为并发 环境设计的有序SET工具类。<br>ConcurrentSkipListSet底层实现引用了ConcurrentSkipListMap。<br>栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSetTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ConcurrentSkipListSet&lt;Contact1&gt; set = <span class="keyword">new</span> ConcurrentSkipListSet&lt;&gt; ();     </span><br><span class="line">        Thread threads[]=<span class="keyword">new</span> Thread[<span class="number">25</span>];     </span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;     </span><br><span class="line">        <span class="comment">//创建和启动25个任务，对于每个任务指定一个大写字母作为ID     </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i=<span class="string">'A'</span>; i&lt;<span class="string">'Z'</span>; i++) &#123;       </span><br><span class="line">            Task1 task=<span class="keyword">new</span> Task1(set, String.valueOf(i));   </span><br><span class="line">            threads[counter]=<span class="keyword">new</span> Thread(task);    </span><br><span class="line">            threads[counter].start();       </span><br><span class="line">            counter++;   </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用join()方法等待线程的结束    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">25</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                threads[i].join();       </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;      </span><br><span class="line">                e.printStackTrace();           </span><br><span class="line">            &#125;    </span><br><span class="line"> 		&#125;       </span><br><span class="line">        System.out.printf(<span class="string">"Size of the set: %d\n"</span>,set.size());  </span><br><span class="line">        Contact1 contact;     </span><br><span class="line">        <span class="comment">// 使用first方法获取set的第一个实体，并输出。  </span></span><br><span class="line">        contact=set.first();    </span><br><span class="line">        System.out.printf(<span class="string">"First Entry: %s: %s\n"</span>,contact.                getName(),contact.getPhone()); </span><br><span class="line">        <span class="comment">//使用last方法获取set的最后一个实体，并输出。      </span></span><br><span class="line">        contact=set.last();        </span><br><span class="line">        System.out.printf(<span class="string">"Last Entry: %s: %s\n"</span>,contact.                getName(),contact.getPhone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact1</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Contact1</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contact1</span><span class="params">(String name, String phone)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> phone; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Contact1 o)</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> name.compareTo(o.name);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentSkipListSet&lt;Contact1&gt; set;    </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task1</span><span class="params">(ConcurrentSkipListSet&lt;Contact1&gt; set, String id)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;     </span><br><span class="line">        <span class="keyword">this</span>.set = set;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;        </span><br><span class="line">            Contact1 contact = <span class="keyword">new</span> Contact1(id, String.valueOf(i + <span class="number">100</span>));            set.add(contact);      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-12-CopyOnWriteArrayList"><a href="#3-1-12-CopyOnWriteArrayList" class="headerlink" title="3.1.12 CopyOnWriteArrayList"></a>3.1.12 CopyOnWriteArrayList</h5><p><strong>Copy-On-Write</strong>简称COW，是一种用于程序设计中的优化策略。</p>
<p>其基本思路是，从一开始大家都在共享 同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并 发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<p> <strong>什么是CopyOnWrite容器</strong></p>
<p> CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前 容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素 之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读， 而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读 和写不同的容器。 </p>
<p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在 开发的时候需要注意一下内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个 对象的内存，旧的对象和新写入的对象（<code>注意:在复制的时候只是复制容器里的引用，只是在写的时候 会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存</code>）。如果这些对象占用 的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有 可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制 更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p> 针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是 10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。 数据一致性问题。CopyOnWrite容器只能保证数据的终一致性，不能保证数据的实时一致性。所以如 果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list = list;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.print(<span class="string">"size:="</span>+list.size()+<span class="string">",::"</span>);  </span><br><span class="line">        <span class="keyword">for</span> (Integer ele : list) &#123;</span><br><span class="line">            System.out.print(ele + <span class="string">","</span>);   </span><br><span class="line">        &#125;       </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriteThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list = list; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list.add(<span class="number">9</span>);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//1、初始化CopyOnWriteArrayList   </span></span><br><span class="line">        List&lt;Integer&gt; tempList = Arrays.asList(<span class="keyword">new</span> Integer [] &#123;<span class="number">1</span>,<span class="number">2</span>&#125;); </span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; copyList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt; (tempList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、模拟多线程对list进行读和写    </span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));     </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList)); </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));  </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));   </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));    </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));    </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));  </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));  </span><br><span class="line">        <span class="keyword">try</span> &#123;           </span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"copyList size:"</span>+copyList.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> TestCopyOnWriteArrayList().test();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-13-CopyOnWriteArraySet"><a href="#3-1-13-CopyOnWriteArraySet" class="headerlink" title="3.1.13 CopyOnWriteArraySet"></a>3.1.13 CopyOnWriteArraySet</h5><p>CopyOnWriteArraySet相对CopyOnWriteArrayList用来存储不重复的对象，是线程安全的。虽然继承了AbstractSet类，但CopyOnWriteArraySet与HashMap 完全不同，内部是用 CopyOnWriteArrayList实现的，实现不重复的特性也是直接调用CopyOnWriteArrayList的方法实现 的，感觉加的有用的函数就是eq函数判断对象是否相同</p>
<h4 id="3-2-原子操作类"><a href="#3-2-原子操作类" class="headerlink" title="3.2 原子操作类"></a>3.2 原子操作类</h4><p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程 执行i++操作，就有可能获取不到正确的值，而这个问题，常用的方法是通过Synchronized进行控制 来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去 更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的 是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p>
<h5 id="3-2-1-原子基本数据类型"><a href="#3-2-1-原子基本数据类型" class="headerlink" title="3.2.1 原子基本数据类型"></a>3.2.1 原子基本数据类型</h5><p>原子更新基本类型<br>atomic包提高原子更新基本类型的工具类，主要有这些：</p>
<ul>
<li>AtomicBoolean：以原子更新的方式更新boolean；</li>
<li>AtomicInteger：以原子更新的方式更新Integer; </li>
<li>AtomicLong：以原子更新的方式更新Long；</li>
<li>AtomicInteger常用的方法:</li>
<li>addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回后的结 果； </li>
<li>incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回终相加后的结果； </li>
<li>getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值； </li>
<li>getAndIncrement()：以原子的方式将实例中的原值加1，返回的是自增前的旧值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，该方法实际上是调用了unsafe实例的getAndAddInt方法，unsafe实例的获取时通过 UnSafe类的静态方法getUnsafe获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure>

<p>Unsafe类在sun.misc包下，Unsafer类提供了一些底层操作，atomic包下的原子操作类的也主要是通 过Unsafe类提供的compareAndSwapInt，compareAndSwapLong等一系列提供CAS操作的方法来进行实现。</p>
<p>atomicInteger借助了UnSafe提供的CAS操作能够保证数据更新的时候是线程安全的，并且由于CAS是 采用乐观锁策略，因此，这种数据更新的方法也具有高效性。</p>
<p>AtomicLong的实现原理和AtomicInteger一致，只不过一个针对的是long变量，一个针对的是int变 量。而boolean变量的更新类AtomicBoolean类是怎样实现更新的呢?核心方法是 compareAndSet t方 法，</p>
<p>其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，compareAndSet方法的实际上也是先转换成0,1的整型变量，然后是通过针对int型变量的 原子更新方法compareAndSwapInt来实现的。可以看出atomic包中只提供了对boolean,int ,long这 三种基本类型的原子更新的方法，参考对boolean更新的方式，原子更新char,double,float也可以采 用类似的思路进行实现。<br>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;      </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Accumlator(ai), <span class="string">"thread-"</span> + i);     </span><br><span class="line">            list.add(t);       </span><br><span class="line">            t.start();    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;    </span><br><span class="line">            t.join();     </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ai.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumlator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> AtomicInteger ai;</span><br><span class="line">        Accumlator(AtomicInteger ai) &#123;      </span><br><span class="line">            <span class="keyword">this</span>.ai = ai;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="number">1000</span>; i &lt; len; i++) &#123;   </span><br><span class="line">                ai.incrementAndGet();      </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-原子数组"><a href="#3-2-2-原子数组" class="headerlink" title="3.2.2 原子数组"></a>3.2.2 原子数组</h5><p>atomic包下提供能原子更新数组中元素的类有：</p>
<ul>
<li>AtomicIntegerArray：原子更新整型数组中的元素；</li>
<li>AtomicLongArray：原子更新长整型数组中的元素； </li>
<li>AtomicReferenceArray：原子更新引用类型数组中的元素</li>
</ul>
<p>这几个类的用法一致，就以AtomicIntegerArray来总结下常用的方法：</p>
<ul>
<li>addAndGet(int i, int delta)：以原子更新的方式将数组中索引为i的元素与输入值相加；</li>
<li>getAndIncrement(int i)：以原子更新的方式将数组中索引为i的元素自增加1； </li>
<li>compareAndSet(int i, int expect, int update)：将数组中索引为i的位置的元素进行更新</li>
</ul>
<p>可以看出，AtomicIntegerArray与AtomicInteger的方法基本一致，只不过在AtomicIntegerArray 的方法中会多一个指定数组索引位i。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//创建给定长度的AtomicIntegerArray。  </span></span><br><span class="line">        AtomicIntegerArray atomicIntegerArray = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);   </span><br><span class="line">        <span class="comment">//将位置 i 的元素设置为给定值,默认值为0     </span></span><br><span class="line">        atomicIntegerArray.set(<span class="number">9</span>,<span class="number">10</span>);   </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> + atomicIntegerArray.get(<span class="number">9</span>) + <span class="string">"默认值："</span> + atomicIntegerArray.get(<span class="number">0</span>));      </span><br><span class="line">        <span class="comment">//返回该数组的长度     </span></span><br><span class="line">        System.out.println(<span class="string">"数组长度："</span> + atomicIntegerArray.length());  </span><br><span class="line">        <span class="comment">//以原子方式先对给定下标加上特定的值，再获取相加后的值      </span></span><br><span class="line">        atomicIntegerArray.set(<span class="number">0</span>,<span class="number">10</span>);    </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> + atomicIntegerArray.get(<span class="number">0</span>));  </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> +  atomicIntegerArray.addAndGet(<span class="number">5</span>,<span class="number">10</span>));  </span><br><span class="line">        <span class="comment">//如果当前值 == 预期值，将位置 i 的元素设置为给定的更新值。    </span></span><br><span class="line">        Boolean bool = atomicIntegerArray.compareAndSet(<span class="number">5</span>,<span class="number">10</span>,<span class="number">30</span>);    </span><br><span class="line">        System.out.println(<span class="string">"结果值： "</span> + atomicIntegerArray.get(<span class="number">5</span>) + <span class="string">" Result: "</span> + bool);</span><br><span class="line">        <span class="comment">//以原子方式先将当前下标的值减1，再获取减1后的结果    </span></span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> +  atomicIntegerArray.decrementAndGet(<span class="number">5</span>)); </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + atomicIntegerArray.get(<span class="number">5</span>));     </span><br><span class="line">        <span class="comment">//以原子方式先获取当前下标的值，再将当前下标的值加上给定的值    </span></span><br><span class="line">        Integer result2 = atomicIntegerArray.getAndAdd(<span class="number">5</span>,<span class="number">5</span>);    </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + result2);   </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + atomicIntegerArray.get(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//以原子方式先获取当前下标的值，再对当前下标的值减1   </span></span><br><span class="line">        System.out.println(<span class="string">"下标为1的值为："</span> + atomicIntegerArray.getAndDecrement(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"下标为1的值为："</span> + atomicIntegerArray.get(<span class="number">1</span>));    </span><br><span class="line">        <span class="comment">// 以原子方式先获取当前下标的值，再对当前下标的值加1   </span></span><br><span class="line">        System.out.println(<span class="string">"下标为2的值为："</span> + atomicIntegerArray.getAndIncrement(<span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">"下标为2的值为："</span> + atomicIntegerArray.get(<span class="number">2</span>));     </span><br><span class="line">        <span class="comment">//将位置 i 的元素以原子方式设置为给定值，并返回旧值。</span></span><br><span class="line">        System.out.println(<span class="string">"下标为3的值为："</span> + atomicIntegerArray.getAndSet(<span class="number">3</span>,<span class="number">50</span>));  </span><br><span class="line">        System.out.println(<span class="string">"下标为3的值为："</span> + atomicIntegerArray.get(<span class="number">3</span>));  </span><br><span class="line">        <span class="comment">//以原子方式先对下标加1再获取值     </span></span><br><span class="line">        System.out.println(<span class="string">"下标为4的值为："</span> + atomicIntegerArray.incrementAndGet(<span class="number">4</span>));  </span><br><span class="line">        System.out.println(<span class="string">"下标为4的值为："</span> + atomicIntegerArray.get(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerArray arr = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++)     </span><br><span class="line">                arr.getAndIncrement(k % arr.length()); </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;        </span><br><span class="line">            ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread()); </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;    </span><br><span class="line">            ts[k].start();      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;       </span><br><span class="line">            ts[k].join();     </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(arr);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-原子引用类型"><a href="#3-2-3-原子引用类型" class="headerlink" title="3.2.3 原子引用类型"></a>3.2.3 原子引用类型</h5><p>如果需要原子更新引用类型变量的话，为了保证线程安全，atomic也提供了相关的类：</p>
<ul>
<li><p>AtomicReference </p>
</li>
<li><p>AtomicStampedReference </p>
</li>
<li><p>AtomicMarkableReference</p>
</li>
</ul>
<p>AtomicReference的引入是为了可以用一种类似乐观锁的方式操作共享资源，在某些情景下以提升性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;       </span><br><span class="line">        AtomicReference&lt;Integer&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> Integer(<span class="number">1000</span>));</span><br><span class="line">        </span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;      </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(ref), <span class="string">"Thread-"</span> + i);     </span><br><span class="line">            list.add(t);        </span><br><span class="line">            t.start();</span><br><span class="line">            </span><br><span class="line"> &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;   </span><br><span class="line">            t.join();     </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ref.get());   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Integer&gt; ref;</span><br><span class="line">    Task(AtomicReference&lt;Integer&gt; ref) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.ref = ref; </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;  </span><br><span class="line">            <span class="comment">//自旋操作       </span></span><br><span class="line">            Integer oldV = ref.get();   </span><br><span class="line">            <span class="keyword">if</span> (ref.compareAndSet(oldV, oldV + <span class="number">1</span>)) </span><br><span class="line">                <span class="comment">// CAS操作            </span></span><br><span class="line">                <span class="keyword">break</span>;      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该案例并没有使用锁，是使用自旋+CAS的无锁操作保证共享变量的线程安全。<br>CAS操作可能存在ABA的问题： 假如一个值原来是A，变成了B，又变成了A，那么CAS检查时会发现它的值没有发生变化，但是实际上却 变化了。<br>一般来讲这并不是什么问题，比如数值运算，线程其实根本不关心变量中途如何变化，只要终的状态 和预期值一样即可。<br>但是，有些操作会依赖于对象的变化过程，此时的解决思路一般就是使用版本号。在变量前面追加上版 本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A - 2B - 3A。<br>AtomicStampedReference就是上面所说的加了版本号的AtomicReference。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> T reference;     </span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> stamp;    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;   </span><br><span class="line">         <span class="keyword">this</span>.reference = reference;   </span><br><span class="line">         <span class="keyword">this</span>.stamp = stamp;    </span><br><span class="line">     &#125;      </span><br><span class="line">     <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;     </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);     </span><br><span class="line">     &#125;   </span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AtomicStampedReference&#125; with the given</span></span><br><span class="line"><span class="comment">	 * initial values.     </span></span><br><span class="line"><span class="comment">	 *     </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> initialRef the initial reference     </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> initialStamp the initial stamp     </span></span><br><span class="line"><span class="comment">	 */</span>    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;   </span><br><span class="line">    	pair = Pair.of(initialRef, initialStamp);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决ABA问题，引入了AtomicStampedReference。</p>
<p>AtomicStampedReference可以给引用加上版本号，追踪引用的整个变化过程，如： A -&gt; B -&gt; C -&gt; D - &gt; A，通过AtomicStampedReference，可以知道，引用变量中途被更改了3 次。</p>
<p>但是，有时候，我们并不关心引用变量更改了几次，只关心是否更改过，就有了 AtomicMarkableReference：<br>    AtomicMarkableReference和AtomicStampedReference的唯一区别就是不再用int标识引用，而是使 用boolean变量——表示引用变量是否被更改过。<br>    AtomicMarkableReference对于那些不关心引用变化过程，只关心引用变量是否变化过的应用会更加友好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMarkableReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">        <span class="keyword">final</span> T reference;     </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> mark;    </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">this</span>.reference = reference;    </span><br><span class="line">            <span class="keyword">this</span>.mark = mark;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, mark);       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">      * Creates a new &#123;<span class="doctag">@code</span> AtomicMarkableReference&#125; with the given   </span></span><br><span class="line"><span class="comment">      * initial values.   </span></span><br><span class="line"><span class="comment">      *    </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> initialRef the initial reference     </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> initialMark the initial mark </span></span><br><span class="line"><span class="comment">      */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicMarkableReference</span><span class="params">(V initialRef, <span class="keyword">boolean</span> initialMark)</span> </span>&#123; </span><br><span class="line">        pair = Pair.of(initialRef, initialMark);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-4-原子更新字段类型"><a href="#3-2-4-原子更新字段类型" class="headerlink" title="3.2.4 原子更新字段类型"></a>3.2.4 原子更新字段类型</h5><p>如果需要更新对象的某个字段，并在多线程的情况下，能够保证线程安全，atomic同样也提供了相应的 原子操作类：</p>
<ul>
<li>AtomicIntegeFieldUpdater：原子更新整型字段类； </li>
<li>AtomicLongFieldUpdater：原子更新长整型字段类；</li>
<li>AtomicReferenceFieldUpdater：</li>
</ul>
<p>原子更新引用字段类型；</p>
<p>要想使用原子更新字段需要两步操作：</p>
<ul>
<li>原子更新字段类都是抽象类，只能通过静态方法 newUpdater 来创建一个更新器，并且需要设置想 要更新的类和属性； </li>
<li>更新类的属性必须使用 public volatile 进行修饰；</li>
<li>字段必须是volatile类型的，在线程之间共享变量时保证立即可见 </li>
<li>字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的 关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。</li>
<li>对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</li>
<li>只能是实例变量，不能是类变量，也就是说不能加static关键字。 </li>
<li>只能是可修改变量，不能使final变量，因为final的语义就是不可修改。 </li>
<li>对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字 段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用 AtomicReferenceFieldUpdater。</li>
</ul>
<p>这几个类提供的方法基本一致，以AtomicIntegerFieldUpdater为例来看看具体的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = </span><br><span class="line">        AtomicIntegerFieldUpdater.newUpdater(User.class, "age");</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);       </span><br><span class="line">        System.out.println(a.getAndIncrement(user));  </span><br><span class="line">        System.out.println(a.get(user));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">private</span> String name;      </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;      </span><br><span class="line">            <span class="keyword">this</span>.name = name;    </span><br><span class="line">            <span class="keyword">this</span>.age = age;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">return</span> name;     </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">return</span> age;        </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从示例中可以看出，创建 AtomicIntegerFieldUpdater 是通过它提供的静态方法进行创建， getAndAdd 方法会将指定的字段加上输入的值，并且返回相加之前的值。user对象中age字段原值为 1，加5之后，可以看出user对象中的age字段的值已经变成了6。</p>
<h4 id="3-3-锁：Lock"><a href="#3-3-锁：Lock" class="headerlink" title="3.3 锁：Lock"></a>3.3 锁：Lock</h4><p>java.util.concurrent.locks 包，该包提供了一系列基础的锁工具，用以对synchronizd、wait、 notify等进行补充、增强。 juc-locks锁框架中一共就三个接口：Lock、Condition、ReadWriteLock。</p>
<h5 id="3-3-1-ReentrantLock"><a href="#3-3-1-ReentrantLock" class="headerlink" title="3.3.1 ReentrantLock"></a>3.3.1 ReentrantLock</h5><p>ReentrantLock叫做可重入锁，指的是线程可以重复获取同一把锁，或者说该锁支持一个线程对资源的 重复加锁。同时该锁还支持获取锁的公平性和非公平性选择，锁的公平性是指，在绝对时间上，先对锁 获取的请求一定先被满足，也就是等待时间长的那个线程优先获得，可以说，锁的获取是顺序的，即 符合FIFO规则。<br>ReentrantLock也是互斥锁，因此也可以保证原子性。<br>ReentrantLock 重入锁的基本原理是判断上次获取锁的线程是否为当前线程，如果是则可再次进入临 界区，如果不是，则阻塞。<br>由于ReentrantLock是基于AQS实现的，底层通过操作同步状态来获取锁.，下面看一下非公平锁的实 现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//获取当前线程         </span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();        </span><br><span class="line">    <span class="comment">//通过AQS获取同步状态       </span></span><br><span class="line">    <span class="keyword">int</span> c = getState();            </span><br><span class="line">    <span class="comment">//同步状态为0，说明临界区处于无锁状态，            </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;            </span><br><span class="line">        <span class="comment">//修改同步状态，即加锁          </span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;        </span><br><span class="line">            <span class="comment">//将当前线程设置为锁的owner     </span></span><br><span class="line">            setExclusiveOwnerThread(current);    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="comment">//如果临界区处于锁定状态，且上次获取锁的线程为当前线程  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;   </span><br><span class="line">        <span class="comment">//则递增同步状态       </span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;     </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow      </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);   </span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;       </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功获取锁的线程再次获取锁，只是增加了同步状态值，在释放同步转态时，相应的减少同步状态值， 实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;       </span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;   </span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())       </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;         </span><br><span class="line">    <span class="comment">//在同步状态完全释放了，设置true    </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;              </span><br><span class="line">        free = <span class="keyword">true</span>;       </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);     </span><br><span class="line">    &#125;           </span><br><span class="line">    setState(c);    </span><br><span class="line">    <span class="keyword">return</span> free;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁和非公平锁的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections; </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLockMine(<span class="keyword">true</span>); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLockMine(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    </span><br><span class="line">        testLock(<span class="string">"unfair lock"</span>, unfairLock);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        testLock(<span class="string">"fair lock"</span>, fairLock);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(String type, Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        System.out.println(type);    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;      </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(lock))&#123;     </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">                    <span class="keyword">return</span> getName();</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;;       </span><br><span class="line">            thread.setName(<span class="string">""</span> + i);    </span><br><span class="line">            thread.start();      </span><br><span class="line">        &#125;     </span><br><span class="line">        Thread.sleep(<span class="number">11000</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    </span><br><span class="line">        <span class="keyword">private</span> Lock lock;     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123;      </span><br><span class="line">            <span class="keyword">this</span>.lock = lock;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;      </span><br><span class="line">                lock.lock();           </span><br><span class="line">                <span class="keyword">try</span> &#123;            </span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">                    System.out.println(<span class="string">"获取锁的当前线程["</span> + Thread.currentThread().getName() + <span class="string">"], 同步队列中的线程"</span> + ((ReentrantLockMine)lock).getQueuedThreads() + <span class="string">""</span>);      </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </span><br><span class="line">                    e.printStackTrace();        </span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;                </span><br><span class="line">                    lock.unlock();       </span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockMine</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//重新实 现ReentrantLock类是为了重写getQueuedThreads方法，便于我们试验的观察</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLockMine</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">super</span>(fair);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>   </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="comment">//获取同步队列中的 线程          </span></span><br><span class="line">            List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt; (<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);     </span><br><span class="line">            <span class="keyword">return</span> arrayList;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁的获取，只要获取了同步状态就可以获取锁，有可能导致饥饿现象，但是非公平锁，线程的切 换比较少，更高效。<br>ReentrantLock与synchronized的区别</p>
<ul>
<li><p>重入 </p>
<p>synchronized可重入，因为加锁和解锁自动进行，不必担心后是否释放锁；ReentrantLock也 可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。</p>
</li>
<li><p>实现</p>
<p> synchronized是JVM实现的、而ReentrantLock是JDK实现的。说白了就是，是操作系统来实现， 还是用户自己敲代码实现。 </p>
</li>
<li><p>性能 </p>
<p>在 Java 的 1.5 版本中，synchronized 性能不如 SDK 里面的 Lock，但 1.6 版本之后， synchronized 做了很多优化，将性能追了上来。</p>
</li>
<li><p>功能 </p>
<p>ReentrantLock锁的细粒度和灵活度，优于synchronized。 ReentrantLock不同点一：可在构造函数中指定是公平锁还是非公平锁，而synchronized只能是非公平锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>ReentrantLock不同点二：可以避免死锁问题，因为它可以非阻塞地获取锁。如果尝试获取 锁失败，并不进入阻塞状态，而是直接返回false，这时候线程不用阻塞等待，可以先去做其他事情。 所以不会造成死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持非阻塞获取锁的 API </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>tryLock还支持超时。调用tryLock时没有获取到锁，会等待一段时间，如果线程在一段时间之内还是 没有获取到锁，不是进入阻塞状态，而是throws InterruptedException，那这个线程也有机会释放 曾经持有的锁，这样也能破坏死锁不可抢占条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>

<p>ReentrantLock不同点三：提供能够中断等待锁机制。</p>
<p>synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦 发生死锁，就没有任何机会来唤醒阻塞的线程。</p>
<p>但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤 醒它，那它就有机会释放曾经持有的锁 A。ReentrantLock可以用lockInterruptibly方法来实现。</p>
<p>ReentrantLock不同点四：可以用J.U.C包中的Condition实现分组唤醒需要等待的线程。而 synchronized只能notify或者notifyAll。</p>
<h5 id="3-3-2-LockSupport"><a href="#3-3-2-LockSupport" class="headerlink" title="3.3.2 LockSupport"></a>3.3.2 LockSupport</h5><p>LockSupport类，是JUC包中的一个工具类，定义了一组静态方法，提供基本的线程阻塞和唤醒功 能，是构建同步组件的基础工具，用来创建锁和其他同步类的基本线程阻塞原语。<br>LockSupport类的核心方法其实就两个：park() 和 unpark()，其中 park() 方法用来阻塞线程， unpark()方法用于唤醒指定线程。<br>和Object类的wait() 和 signal() 方法有些类似，但是LockSupport的这两种方法从语意上讲比 Object类的方法更清晰，而且可以针对指定线程进行阻塞和唤醒。<br>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，可以把许可看 成是一种（0，1）信号量（Semaphore），但与Semaphore不同的是，许可的量加上限1。<br>初始时，permit为0，当调用 unpark() 方法时，线程的permit加1，当调用 park()方法时，如果 permit为0，则调用线程进入阻塞状态。</p>
<p>假设现在需要实现一种FIFO类型的独占锁，可以把这种锁看成是ReentrantLock的公平锁简单版本， 且是不可重入的，就是说当一个线程获得锁后，其他等待线程以FIFO的调度方式等待获取锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">FIFOMutex</span>  </span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean locked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Thread&gt; waiters = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        Thread current = Thread.currentThread();       </span><br><span class="line">        waiters.add(current);       </span><br><span class="line">        <span class="comment">// 如果当前线程不在队首，或锁已被占用，则当前线程阻塞 </span></span><br><span class="line">        <span class="comment">// 这个判断的内在意图：锁必须由队首元素拿到    </span></span><br><span class="line">        <span class="keyword">while</span> (waiters.peek() != current || !locked.compareAndSet(<span class="keyword">false</span>,<span class="keyword">true</span>))&#123;  </span><br><span class="line">            LockSupport.park();      </span><br><span class="line">        &#125;       </span><br><span class="line">        waiters.remove();</span><br><span class="line">        <span class="comment">// 删除队首元素  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123; </span><br><span class="line">        locked.set(<span class="keyword">false</span>);    </span><br><span class="line">        LockSupport.unpark(waiters.peek());  </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFIFOMutex</span> </span>&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">         FIFOMutex mutex = <span class="keyword">new</span> FIFOMutex(); </span><br><span class="line">         MyThread a1 = <span class="keyword">new</span> MyThread(<span class="string">"a"</span>, mutex);   </span><br><span class="line">         MyThread a2 = <span class="keyword">new</span> MyThread(<span class="string">"b"</span>, mutex);   </span><br><span class="line">         MyThread a3 = <span class="keyword">new</span> MyThread(<span class="string">"c"</span>, mutex);  </span><br><span class="line">         a1.start();     </span><br><span class="line">         a2.start();     </span><br><span class="line">         a3.start();     </span><br><span class="line">         a1.join();        </span><br><span class="line">         a2.join();  </span><br><span class="line">         a3.join();     </span><br><span class="line">         System.out.println(<span class="string">"Finished"</span>);  </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> FIFOMutex mutex;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, FIFOMutex mutex)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;    </span><br><span class="line">            mutex.lock();      </span><br><span class="line">            count++;         </span><br><span class="line">            System.out.println(<span class="string">"thread:"</span>+Thread.currentThread().getName()+<span class="string">" name:"</span> + name + <span class="string">" count:"</span> + count);  </span><br><span class="line">            mutex.unlock();   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述FIFOMutex类的实现中，当判断锁已被占用时，会调用 LockSupport.park(this) 方法，将当前 调用线程阻塞；当使用完锁时，会调用 LockSupport.unpark(waiters.peek()) 方法将等待队列中 的队首线程唤醒。<br>通过LockSupport的这两个方法，可以很方便的阻塞和唤醒线程。</p>
<ul>
<li>park 方法是会响应中断的，但是不会抛出异常。（也就是说如果当前调用线程被中断，则会立即 返回但不会抛出中断异常） </li>
<li>park 的重载方法 park(Object blocker)，会传入一个blocker对象，所谓Blocker对象，其实 就是当前线程调用时所在调用对象（如上述示例中的FIFOMutex对象）。该对象一般供监视、诊断 工具确定线程受阻塞的原因时使用。</li>
</ul>
<h5 id="3-3-3-Condition"><a href="#3-3-3-Condition" class="headerlink" title="3.3.3 Condition"></a>3.3.3 Condition</h5><p>在没有Lock之前，我们使用synchronized来控制同步，配合Object的wait()、wait(long timeout)、notify()、以及notifyAll 等方法可以实现等待/通知模式。<br>Condition接口也提供了类似于Object的监听器方法、与Lock接口配合可以实现等待/通知模式，但是 两者还是有很大区别的，下图是两者的对比：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img2.jpg"  alt></p>
<p>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便 通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中， Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。</p>
<p>条件（也称为条件队列 或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同 的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性 是：以原子方式 释放相关的锁，并挂起当前线程，就像 Object.wait 做的那样。</p>
<p>Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。<br>核心方法<br>Condition提供了一系列的方法来对阻塞和唤醒线程：</p>
<ul>
<li>await()：造成当前线程在接到信号或被中断之前一直处于等待状态。</li>
<li>await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时 间之前一直处于等待状态。 </li>
<li>awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间 之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。 </li>
<li>awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。 </li>
<li>awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定后期限之前一 直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返 回false。</li>
<li>signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</li>
<li>signalAll() ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的 锁。</li>
</ul>
<p>Condition是一种广义上的条件队列。他为线程提供了一种更为灵活的等待/通知模式，线程在调用 await方法后执行挂起操作，直到线程等待的某个条件为真时才会被唤醒。Condition必须要配合锁一 起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑 定，因此Condition一般都是作为Lock的内部实现。</p>
<h6 id="源码探索"><a href="#源码探索" class="headerlink" title="源码探索"></a>源码探索</h6><p>获取一个Condition必须要通过Lock的newCondition()方法。该方法定义在接口Lock下，返回的结果 是绑定到此 Lock 实例的新 Condition 实例。<br>Condition为一个接口，其下仅有一个实现类ConditionObject，由于Condition的操作需要获取相关 的锁，而AQS则是同步锁的实现基础，所以ConditionObject则定义为AQS的内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>等待队列</strong><br>每个Condition对象都包含着一个FIFO队列，该队列是Condition对象通知/等待功能的关键。<br>在队列中每一个节点都包含着一个线程引用，该线程就是在该Condition对象上等待的线程。<br>Condition的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>; </span><br><span class="line">    <span class="comment">/** First node of condition queue. */</span>     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;           </span><br><span class="line">    <span class="comment">/** Last node of condition queue. */</span>   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">/**   </span></span><br><span class="line"><span class="comment">         * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">	  */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">       <span class="comment">// Internal methods     </span></span><br><span class="line">    	<span class="comment">// 省略方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出Condition拥有首节点（firstWaiter），尾节点（lastWaiter）。</p>
<p>当前线程调用await()方法，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾 部。<br>Node里面包含了当前线程的引用。Node定义与AQS的CLH同步队列的节点使用的都是同一个类。</p>
<p>Condition的队列结构比CLH同步队列的结构简单些，新增过程较为简单只需要将原尾节点的 nextWaiter指向新增节点，然后更新lastWaiter即可。</p>
<p><strong>等待</strong><br>调用Condition的await()方法会使当前线程进入等待状态，同时会加入到Condition等待队列并释放 锁。</p>
<p>当从await()方法返回时，当前线程一定是获取了Condition相的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    <span class="comment">// 当前线程中断、直接异常   </span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();     </span><br><span class="line">    <span class="comment">//加入等待队列            </span></span><br><span class="line">    Node node = addConditionWaiter();    </span><br><span class="line">    <span class="comment">//释放锁           </span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);      </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;      </span><br><span class="line">    <span class="comment">//检测当前节点是否在同步队列上、如果不在则说明该节点没有资格竞争锁，继续等 待。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;      </span><br><span class="line">        <span class="comment">// 挂起线程           </span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);           </span><br><span class="line">        <span class="comment">// 线程释是否被中断，中断直接退出      </span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)       </span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">    &#125;                   </span><br><span class="line">    <span class="comment">// 获取同步状态    </span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)    </span><br><span class="line">        interruptMode = REINTERRUPT;            </span><br><span class="line">    <span class="comment">// 清理条件队列         </span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// clean up if cancelled      </span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">	<span class="keyword">if</span> (interruptMode != <span class="number">0</span>)    </span><br><span class="line">    	reportInterruptAfterWait(interruptMode);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此段代码的逻辑是： 首先将当前线程新建一个节点同时加入到等待队列中，然后释放当前线程持有的同步状态。<br>然后则是不断检测该节点代表的线程是否出现在CLH同步队列中（收到signal信号之后就会在AQS队列 中检测到），如果不存在则一直挂起，否则参与竞争同步状态。</p>
<p><strong>加入条件队列（addConditionWaiter()）源码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//队列的尾节点          </span></span><br><span class="line">    Node t = lastWaiter;      </span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.           </span></span><br><span class="line">    <span class="comment">// 如果该节点的状态的不是CONDITION，则说明该节点不在等待队列上，需要清除       </span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;       </span><br><span class="line">        <span class="comment">// 清除等待队列中状态不为CONDITION的节点         </span></span><br><span class="line">        unlinkCancelledWaiters();                 </span><br><span class="line">        <span class="comment">//清除后重新获取尾节点           </span></span><br><span class="line">        t = lastWaiter;       </span><br><span class="line">    &#125;                 </span><br><span class="line">    <span class="comment">// 将当前线程构造成等待节点     </span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);     </span><br><span class="line">    <span class="comment">// 将node节点添加到等待队列的尾部      </span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)           </span><br><span class="line">        firstWaiter = node;       </span><br><span class="line">    <span class="keyword">else</span>           </span><br><span class="line">        t.nextWaiter = node;     </span><br><span class="line">    lastWaiter = node;      </span><br><span class="line">    <span class="keyword">return</span> node;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是将当前线程加入到Condition条件队列中。当然在加入到尾节点之前会清除所有状态不为 Condition的节点。<br>fullyRelease(Node node)，负责释放该线程持有的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;    </span><br><span class="line">    <span class="keyword">try</span> &#123;                 </span><br><span class="line">        <span class="comment">// 获取节点持有锁的数量       </span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();        </span><br><span class="line">        <span class="comment">// 释放锁也就是释放共享状态       </span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;      </span><br><span class="line">            failed = <span class="keyword">false</span>;        </span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)       </span><br><span class="line">            node.waitStatus = Node.CANCELLED;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isOnSyncQueue(Node node)：如果一个节点刚开始在条件队列上，现在在同步队列上获取锁则返回 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;    </span><br><span class="line">	<span class="comment">// 状态为CONDITION 、前驱节点为空，返回false    </span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;       </span><br><span class="line">    <span class="comment">// 如果后继节点不为空，则说明节点肯定在同步队列中       </span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="comment">// If has successor, it must be on queue            </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;     </span><br><span class="line">    <span class="comment">/*         </span></span><br><span class="line"><span class="comment">    * node.prev can be non-null, but not yet on queue because    </span></span><br><span class="line"><span class="comment">    * the CAS to place it on queue can fail. So we have to         </span></span><br><span class="line"><span class="comment">    * traverse from tail to make sure it actually made it.  It   </span></span><br><span class="line"><span class="comment">    * will always be near the tail in calls to this method, and    </span></span><br><span class="line"><span class="comment">    * unless the CAS failed (which is unlikely), it will be     </span></span><br><span class="line"><span class="comment">    * there, so we hardly ever traverse much.  </span></span><br><span class="line"><span class="comment">    */</span>     </span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlinkCancelledWaiters()：负责将条件队列中状态不为Condition的节点删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    <span class="comment">// 首节点           </span></span><br><span class="line">    Node t = firstWaiter;      </span><br><span class="line">    Node trail = <span class="keyword">null</span>;      </span><br><span class="line">    <span class="comment">// 从头开始清除状态不为CONDITION的节点       </span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;          </span><br><span class="line">        Node next = t.nextWaiter;          </span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;   </span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;       </span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)        </span><br><span class="line">                firstWaiter = next;  </span><br><span class="line">            <span class="keyword">else</span>                      </span><br><span class="line">                trail.nextWaiter = next;      </span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)       </span><br><span class="line">                lastWaiter = trail;        </span><br><span class="line">        &#125;               </span><br><span class="line">        <span class="keyword">else</span>             </span><br><span class="line">            trail = t;       </span><br><span class="line">        t = next;</span><br><span class="line">	&#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通知</strong></p>
<p>调用Condition的signal()方法，将会唤醒在等待队列中等待长时间的节点（条件队列里的首节 点），在唤醒节点前，会将节点移到同步队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果同步是以独占方式进行的，则返回 true；其他情况则返回 false  </span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())           </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();         </span><br><span class="line">    <span class="comment">// 唤醒首节点         </span></span><br><span class="line">    Node first = firstWaiter;             </span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)        </span><br><span class="line">        doSignal(first);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先会判断当前线程是否已经获得了锁，这是前置条件。然后唤醒条件队列中的头节点。<br>doSignal(Node first)：唤醒头节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">do</span> &#123;             </span><br><span class="line">        <span class="comment">// 修改头节点、方便移除          </span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)      </span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;        </span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;              </span><br><span class="line">        <span class="comment">// 将该节点移到同步队列      </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;     </span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doSignal(Node first)主要是做两件事：</p>
<ul>
<li>修改头节点；</li>
<li>调用transferForSignal(Node first) 方法将节点移动到CLH同步队列中。</li>
</ul>
<p>整个通知的流程如下：</p>
<ul>
<li>判断当前线程是否已经获取了锁，如果没有获取则直接抛出异常，因为获取锁为通知的前置条件。 </li>
<li>如果线程已经获取了锁，则将唤醒条件队列的首节点。 </li>
<li>唤醒首节点是先将条件队列中的头节点移出，然后调用AQS的enq(Node node)方法将其安全地移 到CLH同步队列中 。 </li>
<li>最后判断如果该节点的同步状态是否为Cancel，或者修改状态为Signal失败时，则直接调用 LockSupport唤醒该节点的线程。</li>
</ul>
<p>一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到条件队列中，然后释 放锁，后通过isOnSyncQueue(Node node)方法不断自检看节点是否已经在CLH同步队列了，如果是 则尝试获取锁，否则一直挂起。<br>当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法唤醒CLH同步队列的首节点。被唤醒的线程，将从await()方法中的while循环中退出来， 然后调用acquireQueued()方法竞争同步状态。<br>栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition();  </span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        </span><br><span class="line">       lock.lock();     </span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">           <span class="keyword">while</span> (count == items.length)    </span><br><span class="line">               notFull.await();    </span><br><span class="line">            items[putptr] = x;    </span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;   </span><br><span class="line">            ++count;    </span><br><span class="line">            notEmpty.signal(); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">            lock.unlock();    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">       lock.lock();    </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"> 			<span class="keyword">while</span> (count == <span class="number">0</span>)   </span><br><span class="line">                notEmpty.await(); </span><br><span class="line">           Object x = items[takeptr];   </span><br><span class="line">           <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>; </span><br><span class="line">           --count;      </span><br><span class="line">           notFull.signal();     </span><br><span class="line">           <span class="keyword">return</span> x;  </span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">           lock.unlock();   </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Frosro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://frosro.github.io/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/">https://frosro.github.io/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://frosro.github.io" target="_blank">BETTER LATE THAN NEVER</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发编程（二）</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTMzNS8yNTgyNw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Frosro</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">-------------非常欢迎 <i class="fa fa-paw"></i> 来到我的博客-------------</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>