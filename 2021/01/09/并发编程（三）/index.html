<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>并发编程（三） | BETTER LATE THAN NEVER</title><meta name="description" content="并发编程（三）"><meta name="keywords" content="JAVA,并发编程"><meta name="author" content="Frosro"><meta name="copyright" content="Frosro"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="并发编程（三）"><meta name="twitter:description" content="并发编程（三）"><meta name="twitter:image" content="https://frosro.github.io/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="并发编程（三）"><meta property="og:url" content="https://frosro.github.io/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"><meta property="og:site_name" content="BETTER LATE THAN NEVER"><meta property="og:description" content="并发编程（三）"><meta property="og:image" content="https://frosro.github.io/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://frosro.github.io/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"><link rel="prev" title="SpringCloud Alibaba 之 Sentinel（一）" href="https://frosro.github.io/2022/02/08/SpringCloudAlibaba%E4%B9%8BSentinel/"><link rel="next" title="并发编程（二）" href="https://frosro.github.io/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="BETTER LATE THAN NEVER" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#三、JUC-java-util-concurrent"><span class="toc-number">1.</span> <span class="toc-text">三、JUC:java.util.concurrent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-集合"><span class="toc-number">1.1.</span> <span class="toc-text">3.1 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-BlockingQueue"><span class="toc-number">1.1.1.</span> <span class="toc-text">3.1.1 BlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-ArrayBlockingQueue"><span class="toc-number">1.1.2.</span> <span class="toc-text">3.1.2 ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-PriorityBlockingQueue"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.1.3 PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-4-DelayQueue"><span class="toc-number">1.1.4.</span> <span class="toc-text">3.1.4 DelayQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-5-LinkedBlockingQueue"><span class="toc-number">1.1.5.</span> <span class="toc-text">3.1.5 LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-6-LinkedBlockingDeque"><span class="toc-number">1.1.6.</span> <span class="toc-text">3.1.6 LinkedBlockingDeque</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-7-SynchronousQueue"><span class="toc-number">1.1.7.</span> <span class="toc-text">3.1.7 SynchronousQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-8-LinkedTransferQueue"><span class="toc-number">1.1.8.</span> <span class="toc-text">3.1.8 LinkedTransferQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-9-ConcurrentHashMap"><span class="toc-number">1.1.9.</span> <span class="toc-text">3.1.9 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#HashMap容量"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">HashMap容量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#效率低下的-HashTable-容器"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">效率低下的 HashTable 容器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-10-ConcurrentSkipListMap"><span class="toc-number">1.1.10.</span> <span class="toc-text">3.1.10 ConcurrentSkipListMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-11-ConcurrentSkipListSet"><span class="toc-number">1.1.11.</span> <span class="toc-text">3.1.11 ConcurrentSkipListSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-12-CopyOnWriteArrayList"><span class="toc-number">1.1.12.</span> <span class="toc-text">3.1.12 CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-13-CopyOnWriteArraySet"><span class="toc-number">1.1.13.</span> <span class="toc-text">3.1.13 CopyOnWriteArraySet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-原子操作类"><span class="toc-number">1.2.</span> <span class="toc-text">3.2 原子操作类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-原子基本数据类型"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.2.1 原子基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-原子数组"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2.2 原子数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-原子引用类型"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.2.3 原子引用类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-原子更新字段类型"><span class="toc-number">1.2.4.</span> <span class="toc-text">3.2.4 原子更新字段类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-锁：Lock"><span class="toc-number">1.3.</span> <span class="toc-text">3.3 锁：Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-ReentrantLock"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.3.1 ReentrantLock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-LockSupport"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.3.2 LockSupport</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-Condition"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3.3 Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#源码探索"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">源码探索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Synchronizers"><span class="toc-number">1.4.</span> <span class="toc-text">3.4 Synchronizers</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-Semaphore"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.4.1 Semaphore</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-CountDownLatch"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.4.2 CountDownLatch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-CyclicBarrier"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.4.3 CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#CyclicBarrier对异常的处理"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">CyclicBarrier对异常的处理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-4-Exchanger"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4.4 Exchanger</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-Phaser"><span class="toc-number">1.4.5.</span> <span class="toc-text">3.4.5 Phaser</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-Executors"><span class="toc-number">1.5.</span> <span class="toc-text">3.5 Executors</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-1-Executor框架"><span class="toc-number">1.5.1.</span> <span class="toc-text">3.5.1 Executor框架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-2-ThreadPoolExecutor"><span class="toc-number">1.5.2.</span> <span class="toc-text">3.5.2 ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-3-ScheduledExecutorService"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.5.3 ScheduledExecutorService</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BETTER LATE THAN NEVER</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">并发编程（三）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-01-09 21:27:14"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-01-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-01-10 22:54:52"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-01-10</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%F0%9F%90%BAJAVA/">🐺JAVA</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h3 id="三、JUC-java-util-concurrent"><a href="#三、JUC-java-util-concurrent" class="headerlink" title="三、JUC:java.util.concurrent"></a>三、JUC:java.util.concurrent</h3><h4 id="3-1-集合"><a href="#3-1-集合" class="headerlink" title="3.1 集合"></a>3.1 集合</h4><h5 id="3-1-1-BlockingQueue"><a href="#3-1-1-BlockingQueue" class="headerlink" title="3.1.1 BlockingQueue"></a>3.1.1 BlockingQueue</h5><p><strong>什么是阻塞队列？</strong></p>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时， 获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>阻塞队列提供了四种处理方法:</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。 </li>
<li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元 素，如果没有则返回null</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直 到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻 塞消费者线程，直到队列可用。 </li>
<li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出</li>
</ul>
<p>阻塞队列接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue的核心方法：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，成功返回true, 否则抛出异常。如果向限定了容量的队列中插入值，推 荐使用offer()方法。    </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出 空指针异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的 空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"> <span class="comment">//在给定的时间插入元素e到队列中，如果设置成功返回true, 否则返回false.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//检索并从队列的头部删除元素，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该 方法取得了该值。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//在给定的时间范围内，检索并从队列的头部删除元素，从队列中获取值，如果没有取到会抛出异常。</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>        </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//获取队列中剩余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从队列中移除指定的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//判断队列中是否包含该值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//将队列中值，全部移除，并追加到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line">    <span class="comment">//指定最多数量限制将队列中值，全部移除，并追加到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承关系</p>
<ul>
<li><p>子接口： </p>
<p><strong>BlockingDeque</strong></p>
</li>
</ul>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img1.jpg"  alt></p>
<p>​        <strong>TransferQueue</strong></p>
<p>TransferQueue继承了BlockingQueue,并扩展了一些新方法。 </p>
<p>BlockingQueue是指这样的一个队列：当生产者向队列添加元素但队列已满时，生产者会被阻塞；当消费者从队列移除元素但队列为空时，消费者会被阻塞。</p>
<p>TransferQueue则更进一步，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费 （不仅仅是添加到队列里就完事）。新添加的transfer方法用来实现这种约束。顾名思义，阻塞就是发生在元素从一个线程transfer到另一个线程的过程中，它有效地实现了元素在线程之间的传递（以建立Java内存模型中的happens-before关系的方式）。 TransferQueue还包括了其他的一些方法：两个tryTransfer方法，一个是非阻塞的，另一个带 有timeout参数设置超时时间的。还有两个辅助方法hasWaitingConsumer()和getWaitingConsumerCount()。 </p>
<ul>
<li><p>实现类 </p>
<p>ArrayBlockingQueue </p>
<p>DelayQueue</p>
<p>LinkedBlockingDeque</p>
<p>LinkedBlockingQueue</p>
<p>LinkedTransferQueue </p>
<p>PriorityBlockingQueue </p>
<p>SynchronousQueue</p>
</li>
</ul>
<h5 id="3-1-2-ArrayBlockingQueue"><a href="#3-1-2-ArrayBlockingQueue" class="headerlink" title="3.1.2 ArrayBlockingQueue"></a>3.1.2 ArrayBlockingQueue</h5><p><strong>ArrayBlockingQueue</strong> 是一个线程安全的、基于数组、有界的、阻塞的、FIFO 队列。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。<br>此类基于 java.util.concurrent.locks.ReentrantLock 来实现线程安全，所以提供了 ReentrantLock 所能支持的公平性选择。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>,<span class="keyword">true</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);</span><br><span class="line">                blockingQueue.put(element++);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-PriorityBlockingQueue"><a href="#3-1-3-PriorityBlockingQueue" class="headerlink" title="3.1.3 PriorityBlockingQueue"></a>3.1.3 PriorityBlockingQueue</h5><p><strong>PriorityBlockingQueue</strong>是带优先级的无界阻塞队列，每次出队都返回优先级高的元素，是二叉树小堆的实现。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 		PriorityBlockingQueue&lt;PriorityElement&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Random random=<span class="keyword">new</span> Random();</span><br><span class="line">            PriorityElement ele = <span class="keyword">new</span> PriorityElement(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            queue.put(ele);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityElement</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">PriorityElement</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;<span class="comment">//定义优先级    </span></span><br><span class="line">    PriorityElement(<span class="keyword">int</span> priority) &#123;</span><br><span class="line">        <span class="comment">//初始化优先级        </span></span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PriorityElement o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照优先级大小进行排序</span></span><br><span class="line">        <span class="keyword">return</span> priority &gt;= o.getPriority() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PriorityElement [priority="</span> + priority + <span class="string">"]"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-DelayQueue"><a href="#3-1-4-DelayQueue" class="headerlink" title="3.1.4 DelayQueue"></a>3.1.4 DelayQueue</h5><p><strong>DelayQueue</strong>队列中每个元素都有个过期时间，并且队列是个优先级队列，当从队列获取元素时候，只有过期元素才会出队列。</p>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueTest</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Item item1 = <span class="keyword">new</span> Item(<span class="string">"item1"</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        Item item2 = <span class="keyword">new</span> Item(<span class="string">"item2"</span>,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        Item item3 = <span class="keyword">new</span> Item(<span class="string">"item3"</span>,<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">        DelayQueue&lt;Item&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        queue.put(item1);</span><br><span class="line">        queue.put(item2);</span><br><span class="line">        queue.put(item3);</span><br><span class="line">        System.out.println(<span class="string">"begin time:"</span> + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Item take = queue.take();</span><br><span class="line">            System.out.format(<span class="string">"name:&#123;%s&#125;, time:&#123;%s&#125;\n"</span>,take.name, LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 触发时间*/</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String name, <span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.time = System.currentTimeMillis() + (time &gt; <span class="number">0</span>? unit.toMillis(time): <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> time - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;  </span><br><span class="line">        Item item = (Item) o;  </span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.time - item.time;  </span><br><span class="line">        <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Item&#123;"</span> + </span><br><span class="line">            <span class="string">"time="</span> + time +  </span><br><span class="line">            <span class="string">", name='"</span> + name + <span class="string">'\''</span> +  </span><br><span class="line">            <span class="string">'&#125;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-1-5-LinkedBlockingQueue"><a href="#3-1-5-LinkedBlockingQueue" class="headerlink" title="3.1.5 LinkedBlockingQueue"></a>3.1.5 LinkedBlockingQueue</h5><p><strong>LinkedBlockingQueue</strong>是一个基于单向链表的、范围任意的（其实是有界的）、FIFO 阻塞队列。访问 与移除操作是在队头进行，添加操作是在队尾进行，并分别使用不同的锁进行保护，只有在可能涉及多 个节点的操作才同时对两个锁进行加锁。</p>
<p>队列是否为空、是否已满仍然是通过元素数量的计数器（count）进行判断的，由于可以同时在队头、 队尾并发地进行访问、添加操作，所以这个计数器必须是线程安全的，这里使用了一个原子类 AtomicInteger ，这就决定了它的容量范围是： 1 – Integer.MAX_VALUE。<br>由于同时使用了两把锁，在需要同时使用两把锁时，加锁顺序与释放顺序是非常重要的：必须以固定的 顺序进行加锁，再以与加锁顺序的相反的顺序释放锁。<br>头结点和尾结点一开始总是指向一个哨兵的结点，它不持有实际数据，当队列中有数据时，头结点仍然 指向这个哨兵，尾结点指向有效数据的后一个结点。这样做的好处在于，与计数器 count 结合后， 对队头、队尾的访问可以独立进行，而不需要判断头结点与尾结点的关系。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);   </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);  </span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();      </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;          </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);                blockingQueue.put(element++);           </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;   </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;      </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;  </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());    </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;     </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-6-LinkedBlockingDeque"><a href="#3-1-6-LinkedBlockingDeque" class="headerlink" title="3.1.6 LinkedBlockingDeque"></a>3.1.6 LinkedBlockingDeque</h5><p><strong>LinkedBlockingDeque</strong>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两 端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的 竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst， offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移 除双端队列的第一个元素。以Last单词结尾的方法，表示插入，获取或移除双端队列的后一个元素。 另外插入方法add等同于addLast，移除方法remove等效于removeFirst。在初始化 LinkedBlockingDeque时可以初始化队列的容量，用来防止其再扩容时过渡膨胀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue; <span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;Integer&gt;();  </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);  </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);     </span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;     </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;    </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);  </span><br><span class="line">                blockingQueue.put(element++);        </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;      </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);            e.printStackTrace();  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    	System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">try</span> &#123;        </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;    </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());  </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;     </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;       </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-7-SynchronousQueue"><a href="#3-1-7-SynchronousQueue" class="headerlink" title="3.1.7 SynchronousQueue"></a>3.1.7 SynchronousQueue</h5><p><strong>SynchronousQueue</strong>是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待 消费者的移除操作take，反过来也一样。<br>SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因 为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列 的操作也是不允许的。<br>数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲到队列中。<br>SynchronousQueue支持公平访问队列，默认情况下，线程采用非公平策略，如果使用公平策略，等待 的线程采用先进先出的顺序访问队列。<br>SynchronousQueue适合传递性场景，一个使用场景是在线程池里。 Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到 来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();   </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);      </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();     </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);   </span><br><span class="line">                blockingQueue.put(element++);    </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;      </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);       </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;          </span><br><span class="line">                Thread.sleep(<span class="number">1000l</span>);   </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());      </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>); </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-8-LinkedTransferQueue"><a href="#3-1-8-LinkedTransferQueue" class="headerlink" title="3.1.8 LinkedTransferQueue"></a>3.1.8 LinkedTransferQueue</h5><p><strong>LinkedTransferQueue</strong>是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列 LinkedTransferQueue多了tryTransfer和transfer方法。<br>transfer方法。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll() 方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者 在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返 回。transfer方法的关键代码如下：<br>第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元 素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线 程，并执行其他线程。<br>tryTransfer方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接 收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返 回。而transfer方法是必须等到消费者消费了才返回。<br>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者 传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没 消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedTransferQueueTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedTransferQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedTransferQueue&lt;Integer&gt;(); </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue); </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.linkedTransferQueue = linkedTransferQueue;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;     </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);      </span><br><span class="line">                linkedTransferQueue.put(element++);     </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;       </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;    </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.linkedTransferQueue = linkedTransferQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;      </span><br><span class="line">                Thread.sleep(<span class="number">1000l</span>);   </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+linkedTransferQueue.take());       </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;        </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);    </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-9-ConcurrentHashMap"><a href="#3-1-9-ConcurrentHashMap" class="headerlink" title="3.1.9 ConcurrentHashMap"></a>3.1.9 ConcurrentHashMap</h5><h6 id="HashMap容量"><a href="#HashMap容量" class="headerlink" title="HashMap容量"></a>HashMap容量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial </span></span><br><span class="line"><span class="comment">* capacity and load factor. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  initialCapacity the initial capacity </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  loadFactor      the load factor </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative </span></span><br><span class="line"><span class="comment">*         or the load factor is nonpositive </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +      </span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">     initialCapacity = MAXIMUM_CAPACITY;   </span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +                                           loadFactor);  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等 操作，所以非常消耗性能。<br>因此通常建议能提前预估 HashMap 的大小好，尽量的减少扩容带来的性能损耗。<br>线程不安全的 HashMap<br>因为多线程环境下，使用 HashMap 进行 put 操作会引起死循环，导致 CPU 利用率接近 100%，所以 在并发情况下不能使用 HashMap，如以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;      </span><br><span class="line">                <span class="meta">@Override</span>              </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">                    map.put(UUID.randomUUID().toString(), <span class="string">""</span>);     </span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;, <span class="string">"kaikeba"</span> + i).start();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"kaikeba"</span>);</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>

<h6 id="效率低下的-HashTable-容器"><a href="#效率低下的-HashTable-容器" class="headerlink" title="效率低下的 HashTable 容器"></a>效率低下的 HashTable 容器</h6><p>HashTable 容器使用 syncronized来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率 非常低下。因为当一个线程访问 HashTable 的同步方法时，其他线程访问 HashTable 的同步方法 时，可能会进入阻塞或轮询状态。如线程 1 使用 put 进行添加元素，线程 2 不但不能使用 put 方 法添加元素，并且也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();  </span><br><span class="line">        map.put(<span class="string">"key1"</span>, <span class="string">"1"</span>); </span><br><span class="line">        map.put(<span class="string">"key2"</span>, <span class="string">"2"</span>);  </span><br><span class="line">        map.put(<span class="string">"key3"</span>, <span class="string">"3"</span>);    </span><br><span class="line">        map.put(<span class="string">"key4"</span>, <span class="string">"4"</span>);    </span><br><span class="line">        Iterator&lt;String&gt; it = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">            String key = it.next();    </span><br><span class="line">            System.out.println(key + <span class="string">","</span>+ map.get(key));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-10-ConcurrentSkipListMap"><a href="#3-1-10-ConcurrentSkipListMap" class="headerlink" title="3.1.10 ConcurrentSkipListMap"></a>3.1.10 ConcurrentSkipListMap</h5><p>JDK1.6时，为了对高并发环境下的有序Map提供更好的支持，J.U.C新增了一个 ConcurrentNavigableMap接口，ConcurrentNavigableMap很简单，它同时实现了NavigableMap和 ConcurrentMap接口。<br>ConcurrentNavigableMap接口提供的功能也和NavigableMap几乎完全一致，很多方法仅仅是返回的 类型不同。<br>NavigableMap接口，进一步扩展了SortedMap的功能，提供了根据指定Key返回接近项、按升序/降 序返回所有键的视图等功能。<br>J.U.C提供了基于ConcurrentNavigableMap接口的一个实现—— ConcurrentSkipListMap 。 ConcurrentSkipListMap可以看成是并发版本的TreeMap，但是和TreeMap不同是， ConcurrentSkipListMap并不是基于红黑树实现的，其底层是一种类似跳表（Skip List）的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentNavigableMap; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">        ConcurrentSkipListMap&lt;String, Contact&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">        Thread threads[]=<span class="keyword">new</span> Thread[<span class="number">25</span>];    </span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;     </span><br><span class="line">        <span class="comment">//创建和启动25个任务，对于每个任务指定一个大写字母作为ID    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i=<span class="string">'A'</span>; i&lt;<span class="string">'Z'</span>; i++) &#123;   </span><br><span class="line">            Task0 task=<span class="keyword">new</span> Task0(map, String.valueOf(i));     </span><br><span class="line">            threads[counter]=<span class="keyword">new</span> Thread(task);    </span><br><span class="line">            threads[counter].start();   </span><br><span class="line">            counter++;      </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="comment">//使用join()方法等待线程的结束    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">25</span>; i++) &#123;</span><br><span class="line"> 			<span class="keyword">try</span> &#123;               </span><br><span class="line">                threads[i].join();          </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;          </span><br><span class="line">                e.printStackTrace();          </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;          </span><br><span class="line">        System.out.printf(<span class="string">"Size of the map: %d\n"</span>,map.size());   </span><br><span class="line">        Map.Entry&lt;String, Contact&gt; element;           </span><br><span class="line">        Contact contact;      </span><br><span class="line">        <span class="comment">// 使用firstEntry()方法获取map的第一个实体，并输出。 </span></span><br><span class="line">        element=map.firstEntry();     </span><br><span class="line">        contact=element.getValue();        </span><br><span class="line">        System.out.printf(<span class="string">"First Entry: %s: %s\n"</span>,contact.  </span><br><span class="line">                          getName(),contact.getPhone());   </span><br><span class="line">        <span class="comment">//使用lastEntry()方法获取map的最后一个实体，并输出。   </span></span><br><span class="line">        element=map.lastEntry();         </span><br><span class="line">        contact=element.getValue();     </span><br><span class="line">        System.out.printf(<span class="string">"Last Entry: %s: %s\n"</span>,contact.                    getName(),contact.getPhone());        </span><br><span class="line">        <span class="comment">//使用subMap()方法获取map的子map，并输出。</span></span><br><span class="line">        System.out.printf(<span class="string">"Submap from A1996 to B1002: \n"</span>);</span><br><span class="line">        ConcurrentNavigableMap&lt;String, Contact&gt; submap=map.</span><br><span class="line">            subMap(<span class="string">"A1996"</span>, <span class="string">"B1001"</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;     </span><br><span class="line">              </span><br><span class="line">            element=submap.pollFirstEntry();  </span><br><span class="line">            <span class="keyword">if</span> (element!=<span class="keyword">null</span>) &#123;     </span><br><span class="line">                contact=element.getValue();      </span><br><span class="line">                System.out.printf(<span class="string">"%s: %s\n"</span>,contact.getName(),contact.                            getPhone());            </span><br><span class="line">            &#125;         </span><br><span class="line">        &#125; <span class="keyword">while</span> (element!=<span class="keyword">null</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contact</span><span class="params">(String name, String phone)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name;      </span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> phone;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task0</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentSkipListMap&lt;String, Contact&gt; map; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task0</span><span class="params">(ConcurrentSkipListMap&lt;String, Contact&gt; map, String id)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;   </span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;   </span><br><span class="line">            Contact contact = <span class="keyword">new</span> Contact(id, String.valueOf(i + <span class="number">1000</span>));  </span><br><span class="line">            map.put(id + contact.getPhone(), contact);   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-11-ConcurrentSkipListSet"><a href="#3-1-11-ConcurrentSkipListSet" class="headerlink" title="3.1.11 ConcurrentSkipListSet"></a>3.1.11 ConcurrentSkipListSet</h5><p><strong>ConcurrentSkipListSet</strong>，是JDK1.6时J.U.C新增的一个集合工具类，它是一种有序的SET类型。<br>ConcurrentSkipListSet实现了NavigableSet接口，ConcurrentSkipListMap实现了NavigableMap 接口，以提供和排序相关的功能，维持元素的有序性，所以ConcurrentSkipListSet就是一种为并发 环境设计的有序SET工具类。<br>ConcurrentSkipListSet底层实现引用了ConcurrentSkipListMap。<br>栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSetTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ConcurrentSkipListSet&lt;Contact1&gt; set = <span class="keyword">new</span> ConcurrentSkipListSet&lt;&gt; ();     </span><br><span class="line">        Thread threads[]=<span class="keyword">new</span> Thread[<span class="number">25</span>];     </span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;     </span><br><span class="line">        <span class="comment">//创建和启动25个任务，对于每个任务指定一个大写字母作为ID     </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i=<span class="string">'A'</span>; i&lt;<span class="string">'Z'</span>; i++) &#123;       </span><br><span class="line">            Task1 task=<span class="keyword">new</span> Task1(set, String.valueOf(i));   </span><br><span class="line">            threads[counter]=<span class="keyword">new</span> Thread(task);    </span><br><span class="line">            threads[counter].start();       </span><br><span class="line">            counter++;   </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用join()方法等待线程的结束    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">25</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                threads[i].join();       </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;      </span><br><span class="line">                e.printStackTrace();           </span><br><span class="line">            &#125;    </span><br><span class="line"> 		&#125;       </span><br><span class="line">        System.out.printf(<span class="string">"Size of the set: %d\n"</span>,set.size());  </span><br><span class="line">        Contact1 contact;     </span><br><span class="line">        <span class="comment">// 使用first方法获取set的第一个实体，并输出。  </span></span><br><span class="line">        contact=set.first();    </span><br><span class="line">        System.out.printf(<span class="string">"First Entry: %s: %s\n"</span>,contact.                getName(),contact.getPhone()); </span><br><span class="line">        <span class="comment">//使用last方法获取set的最后一个实体，并输出。      </span></span><br><span class="line">        contact=set.last();        </span><br><span class="line">        System.out.printf(<span class="string">"Last Entry: %s: %s\n"</span>,contact.                getName(),contact.getPhone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact1</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Contact1</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contact1</span><span class="params">(String name, String phone)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> phone; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Contact1 o)</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> name.compareTo(o.name);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentSkipListSet&lt;Contact1&gt; set;    </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task1</span><span class="params">(ConcurrentSkipListSet&lt;Contact1&gt; set, String id)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;     </span><br><span class="line">        <span class="keyword">this</span>.set = set;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;        </span><br><span class="line">            Contact1 contact = <span class="keyword">new</span> Contact1(id, String.valueOf(i + <span class="number">100</span>));            set.add(contact);      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-12-CopyOnWriteArrayList"><a href="#3-1-12-CopyOnWriteArrayList" class="headerlink" title="3.1.12 CopyOnWriteArrayList"></a>3.1.12 CopyOnWriteArrayList</h5><p><strong>Copy-On-Write</strong>简称COW，是一种用于程序设计中的优化策略。</p>
<p>其基本思路是，从一开始大家都在共享 同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并 发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<p> <strong>什么是CopyOnWrite容器</strong></p>
<p> CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前 容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素 之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读， 而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读 和写不同的容器。 </p>
<p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在 开发的时候需要注意一下内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个 对象的内存，旧的对象和新写入的对象（<code>注意:在复制的时候只是复制容器里的引用，只是在写的时候 会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存</code>）。如果这些对象占用 的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有 可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制 更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p> 针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是 10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。 数据一致性问题。CopyOnWrite容器只能保证数据的终一致性，不能保证数据的实时一致性。所以如 果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list = list;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.print(<span class="string">"size:="</span>+list.size()+<span class="string">",::"</span>);  </span><br><span class="line">        <span class="keyword">for</span> (Integer ele : list) &#123;</span><br><span class="line">            System.out.print(ele + <span class="string">","</span>);   </span><br><span class="line">        &#125;       </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriteThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list = list; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list.add(<span class="number">9</span>);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//1、初始化CopyOnWriteArrayList   </span></span><br><span class="line">        List&lt;Integer&gt; tempList = Arrays.asList(<span class="keyword">new</span> Integer [] &#123;<span class="number">1</span>,<span class="number">2</span>&#125;); </span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; copyList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt; (tempList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、模拟多线程对list进行读和写    </span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));     </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList)); </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));  </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));   </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));    </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));    </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));  </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));  </span><br><span class="line">        <span class="keyword">try</span> &#123;           </span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"copyList size:"</span>+copyList.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> TestCopyOnWriteArrayList().test();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-13-CopyOnWriteArraySet"><a href="#3-1-13-CopyOnWriteArraySet" class="headerlink" title="3.1.13 CopyOnWriteArraySet"></a>3.1.13 CopyOnWriteArraySet</h5><p>CopyOnWriteArraySet相对CopyOnWriteArrayList用来存储不重复的对象，是线程安全的。虽然继承了AbstractSet类，但CopyOnWriteArraySet与HashMap 完全不同，内部是用 CopyOnWriteArrayList实现的，实现不重复的特性也是直接调用CopyOnWriteArrayList的方法实现 的，感觉加的有用的函数就是eq函数判断对象是否相同</p>
<h4 id="3-2-原子操作类"><a href="#3-2-原子操作类" class="headerlink" title="3.2 原子操作类"></a>3.2 原子操作类</h4><p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程 执行i++操作，就有可能获取不到正确的值，而这个问题，常用的方法是通过Synchronized进行控制 来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去 更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的 是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p>
<h5 id="3-2-1-原子基本数据类型"><a href="#3-2-1-原子基本数据类型" class="headerlink" title="3.2.1 原子基本数据类型"></a>3.2.1 原子基本数据类型</h5><p>原子更新基本类型<br>atomic包提高原子更新基本类型的工具类，主要有这些：</p>
<ul>
<li>AtomicBoolean：以原子更新的方式更新boolean；</li>
<li>AtomicInteger：以原子更新的方式更新Integer; </li>
<li>AtomicLong：以原子更新的方式更新Long；</li>
<li>AtomicInteger常用的方法:</li>
<li>addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回后的结 果； </li>
<li>incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回终相加后的结果； </li>
<li>getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值； </li>
<li>getAndIncrement()：以原子的方式将实例中的原值加1，返回的是自增前的旧值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，该方法实际上是调用了unsafe实例的getAndAddInt方法，unsafe实例的获取时通过 UnSafe类的静态方法getUnsafe获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure>

<p>Unsafe类在sun.misc包下，Unsafer类提供了一些底层操作，atomic包下的原子操作类的也主要是通 过Unsafe类提供的compareAndSwapInt，compareAndSwapLong等一系列提供CAS操作的方法来进行实现。</p>
<p>atomicInteger借助了UnSafe提供的CAS操作能够保证数据更新的时候是线程安全的，并且由于CAS是 采用乐观锁策略，因此，这种数据更新的方法也具有高效性。</p>
<p>AtomicLong的实现原理和AtomicInteger一致，只不过一个针对的是long变量，一个针对的是int变 量。而boolean变量的更新类AtomicBoolean类是怎样实现更新的呢?核心方法是 compareAndSet t方 法，</p>
<p>其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，compareAndSet方法的实际上也是先转换成0,1的整型变量，然后是通过针对int型变量的 原子更新方法compareAndSwapInt来实现的。可以看出atomic包中只提供了对boolean,int ,long这 三种基本类型的原子更新的方法，参考对boolean更新的方式，原子更新char,double,float也可以采 用类似的思路进行实现。<br>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;      </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Accumlator(ai), <span class="string">"thread-"</span> + i);     </span><br><span class="line">            list.add(t);       </span><br><span class="line">            t.start();    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;    </span><br><span class="line">            t.join();     </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ai.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumlator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> AtomicInteger ai;</span><br><span class="line">        Accumlator(AtomicInteger ai) &#123;      </span><br><span class="line">            <span class="keyword">this</span>.ai = ai;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="number">1000</span>; i &lt; len; i++) &#123;   </span><br><span class="line">                ai.incrementAndGet();      </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-原子数组"><a href="#3-2-2-原子数组" class="headerlink" title="3.2.2 原子数组"></a>3.2.2 原子数组</h5><p>atomic包下提供能原子更新数组中元素的类有：</p>
<ul>
<li>AtomicIntegerArray：原子更新整型数组中的元素；</li>
<li>AtomicLongArray：原子更新长整型数组中的元素； </li>
<li>AtomicReferenceArray：原子更新引用类型数组中的元素</li>
</ul>
<p>这几个类的用法一致，就以AtomicIntegerArray来总结下常用的方法：</p>
<ul>
<li>addAndGet(int i, int delta)：以原子更新的方式将数组中索引为i的元素与输入值相加；</li>
<li>getAndIncrement(int i)：以原子更新的方式将数组中索引为i的元素自增加1； </li>
<li>compareAndSet(int i, int expect, int update)：将数组中索引为i的位置的元素进行更新</li>
</ul>
<p>可以看出，AtomicIntegerArray与AtomicInteger的方法基本一致，只不过在AtomicIntegerArray 的方法中会多一个指定数组索引位i。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//创建给定长度的AtomicIntegerArray。  </span></span><br><span class="line">        AtomicIntegerArray atomicIntegerArray = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);   </span><br><span class="line">        <span class="comment">//将位置 i 的元素设置为给定值,默认值为0     </span></span><br><span class="line">        atomicIntegerArray.set(<span class="number">9</span>,<span class="number">10</span>);   </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> + atomicIntegerArray.get(<span class="number">9</span>) + <span class="string">"默认值："</span> + atomicIntegerArray.get(<span class="number">0</span>));      </span><br><span class="line">        <span class="comment">//返回该数组的长度     </span></span><br><span class="line">        System.out.println(<span class="string">"数组长度："</span> + atomicIntegerArray.length());  </span><br><span class="line">        <span class="comment">//以原子方式先对给定下标加上特定的值，再获取相加后的值      </span></span><br><span class="line">        atomicIntegerArray.set(<span class="number">0</span>,<span class="number">10</span>);    </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> + atomicIntegerArray.get(<span class="number">0</span>));  </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> +  atomicIntegerArray.addAndGet(<span class="number">5</span>,<span class="number">10</span>));  </span><br><span class="line">        <span class="comment">//如果当前值 == 预期值，将位置 i 的元素设置为给定的更新值。    </span></span><br><span class="line">        Boolean bool = atomicIntegerArray.compareAndSet(<span class="number">5</span>,<span class="number">10</span>,<span class="number">30</span>);    </span><br><span class="line">        System.out.println(<span class="string">"结果值： "</span> + atomicIntegerArray.get(<span class="number">5</span>) + <span class="string">" Result: "</span> + bool);</span><br><span class="line">        <span class="comment">//以原子方式先将当前下标的值减1，再获取减1后的结果    </span></span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> +  atomicIntegerArray.decrementAndGet(<span class="number">5</span>)); </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + atomicIntegerArray.get(<span class="number">5</span>));     </span><br><span class="line">        <span class="comment">//以原子方式先获取当前下标的值，再将当前下标的值加上给定的值    </span></span><br><span class="line">        Integer result2 = atomicIntegerArray.getAndAdd(<span class="number">5</span>,<span class="number">5</span>);    </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + result2);   </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + atomicIntegerArray.get(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//以原子方式先获取当前下标的值，再对当前下标的值减1   </span></span><br><span class="line">        System.out.println(<span class="string">"下标为1的值为："</span> + atomicIntegerArray.getAndDecrement(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"下标为1的值为："</span> + atomicIntegerArray.get(<span class="number">1</span>));    </span><br><span class="line">        <span class="comment">// 以原子方式先获取当前下标的值，再对当前下标的值加1   </span></span><br><span class="line">        System.out.println(<span class="string">"下标为2的值为："</span> + atomicIntegerArray.getAndIncrement(<span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">"下标为2的值为："</span> + atomicIntegerArray.get(<span class="number">2</span>));     </span><br><span class="line">        <span class="comment">//将位置 i 的元素以原子方式设置为给定值，并返回旧值。</span></span><br><span class="line">        System.out.println(<span class="string">"下标为3的值为："</span> + atomicIntegerArray.getAndSet(<span class="number">3</span>,<span class="number">50</span>));  </span><br><span class="line">        System.out.println(<span class="string">"下标为3的值为："</span> + atomicIntegerArray.get(<span class="number">3</span>));  </span><br><span class="line">        <span class="comment">//以原子方式先对下标加1再获取值     </span></span><br><span class="line">        System.out.println(<span class="string">"下标为4的值为："</span> + atomicIntegerArray.incrementAndGet(<span class="number">4</span>));  </span><br><span class="line">        System.out.println(<span class="string">"下标为4的值为："</span> + atomicIntegerArray.get(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerArray arr = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++)     </span><br><span class="line">                arr.getAndIncrement(k % arr.length()); </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;        </span><br><span class="line">            ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread()); </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;    </span><br><span class="line">            ts[k].start();      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;       </span><br><span class="line">            ts[k].join();     </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(arr);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-原子引用类型"><a href="#3-2-3-原子引用类型" class="headerlink" title="3.2.3 原子引用类型"></a>3.2.3 原子引用类型</h5><p>如果需要原子更新引用类型变量的话，为了保证线程安全，atomic也提供了相关的类：</p>
<ul>
<li><p>AtomicReference </p>
</li>
<li><p>AtomicStampedReference </p>
</li>
<li><p>AtomicMarkableReference</p>
</li>
</ul>
<p>AtomicReference的引入是为了可以用一种类似乐观锁的方式操作共享资源，在某些情景下以提升性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;       </span><br><span class="line">        AtomicReference&lt;Integer&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> Integer(<span class="number">1000</span>));</span><br><span class="line">        </span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;      </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(ref), <span class="string">"Thread-"</span> + i);     </span><br><span class="line">            list.add(t);        </span><br><span class="line">            t.start();</span><br><span class="line">            </span><br><span class="line"> &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;   </span><br><span class="line">            t.join();     </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ref.get());   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Integer&gt; ref;</span><br><span class="line">    Task(AtomicReference&lt;Integer&gt; ref) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.ref = ref; </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;  </span><br><span class="line">            <span class="comment">//自旋操作       </span></span><br><span class="line">            Integer oldV = ref.get();   </span><br><span class="line">            <span class="keyword">if</span> (ref.compareAndSet(oldV, oldV + <span class="number">1</span>)) </span><br><span class="line">                <span class="comment">// CAS操作            </span></span><br><span class="line">                <span class="keyword">break</span>;      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该案例并没有使用锁，是使用自旋+CAS的无锁操作保证共享变量的线程安全。<br>CAS操作可能存在ABA的问题： 假如一个值原来是A，变成了B，又变成了A，那么CAS检查时会发现它的值没有发生变化，但是实际上却 变化了。<br>一般来讲这并不是什么问题，比如数值运算，线程其实根本不关心变量中途如何变化，只要终的状态 和预期值一样即可。<br>但是，有些操作会依赖于对象的变化过程，此时的解决思路一般就是使用版本号。在变量前面追加上版 本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A - 2B - 3A。<br>AtomicStampedReference就是上面所说的加了版本号的AtomicReference。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> T reference;     </span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> stamp;    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;   </span><br><span class="line">         <span class="keyword">this</span>.reference = reference;   </span><br><span class="line">         <span class="keyword">this</span>.stamp = stamp;    </span><br><span class="line">     &#125;      </span><br><span class="line">     <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;     </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);     </span><br><span class="line">     &#125;   </span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AtomicStampedReference&#125; with the given</span></span><br><span class="line"><span class="comment">	 * initial values.     </span></span><br><span class="line"><span class="comment">	 *     </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> initialRef the initial reference     </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> initialStamp the initial stamp     </span></span><br><span class="line"><span class="comment">	 */</span>    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;   </span><br><span class="line">    	pair = Pair.of(initialRef, initialStamp);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决ABA问题，引入了AtomicStampedReference。</p>
<p>AtomicStampedReference可以给引用加上版本号，追踪引用的整个变化过程，如： A -&gt; B -&gt; C -&gt; D - &gt; A，通过AtomicStampedReference，可以知道，引用变量中途被更改了3 次。</p>
<p>但是，有时候，我们并不关心引用变量更改了几次，只关心是否更改过，就有了 AtomicMarkableReference：<br>    AtomicMarkableReference和AtomicStampedReference的唯一区别就是不再用int标识引用，而是使 用boolean变量——表示引用变量是否被更改过。<br>    AtomicMarkableReference对于那些不关心引用变化过程，只关心引用变量是否变化过的应用会更加友好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMarkableReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">        <span class="keyword">final</span> T reference;     </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> mark;    </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">this</span>.reference = reference;    </span><br><span class="line">            <span class="keyword">this</span>.mark = mark;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, mark);       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">      * Creates a new &#123;<span class="doctag">@code</span> AtomicMarkableReference&#125; with the given   </span></span><br><span class="line"><span class="comment">      * initial values.   </span></span><br><span class="line"><span class="comment">      *    </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> initialRef the initial reference     </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> initialMark the initial mark </span></span><br><span class="line"><span class="comment">      */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicMarkableReference</span><span class="params">(V initialRef, <span class="keyword">boolean</span> initialMark)</span> </span>&#123; </span><br><span class="line">        pair = Pair.of(initialRef, initialMark);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-4-原子更新字段类型"><a href="#3-2-4-原子更新字段类型" class="headerlink" title="3.2.4 原子更新字段类型"></a>3.2.4 原子更新字段类型</h5><p>如果需要更新对象的某个字段，并在多线程的情况下，能够保证线程安全，atomic同样也提供了相应的 原子操作类：</p>
<ul>
<li>AtomicIntegeFieldUpdater：原子更新整型字段类； </li>
<li>AtomicLongFieldUpdater：原子更新长整型字段类；</li>
<li>AtomicReferenceFieldUpdater：</li>
</ul>
<p>原子更新引用字段类型；</p>
<p>要想使用原子更新字段需要两步操作：</p>
<ul>
<li>原子更新字段类都是抽象类，只能通过静态方法 newUpdater 来创建一个更新器，并且需要设置想 要更新的类和属性； </li>
<li>更新类的属性必须使用 public volatile 进行修饰；</li>
<li>字段必须是volatile类型的，在线程之间共享变量时保证立即可见 </li>
<li>字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的 关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。</li>
<li>对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</li>
<li>只能是实例变量，不能是类变量，也就是说不能加static关键字。 </li>
<li>只能是可修改变量，不能使final变量，因为final的语义就是不可修改。 </li>
<li>对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字 段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用 AtomicReferenceFieldUpdater。</li>
</ul>
<p>这几个类提供的方法基本一致，以AtomicIntegerFieldUpdater为例来看看具体的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = </span><br><span class="line">        AtomicIntegerFieldUpdater.newUpdater(User.class, "age");</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);       </span><br><span class="line">        System.out.println(a.getAndIncrement(user));  </span><br><span class="line">        System.out.println(a.get(user));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">private</span> String name;      </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;      </span><br><span class="line">            <span class="keyword">this</span>.name = name;    </span><br><span class="line">            <span class="keyword">this</span>.age = age;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">return</span> name;     </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">return</span> age;        </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从示例中可以看出，创建 AtomicIntegerFieldUpdater 是通过它提供的静态方法进行创建， getAndAdd 方法会将指定的字段加上输入的值，并且返回相加之前的值。user对象中age字段原值为 1，加5之后，可以看出user对象中的age字段的值已经变成了6。</p>
<h4 id="3-3-锁：Lock"><a href="#3-3-锁：Lock" class="headerlink" title="3.3 锁：Lock"></a>3.3 锁：Lock</h4><p>java.util.concurrent.locks 包，该包提供了一系列基础的锁工具，用以对synchronizd、wait、 notify等进行补充、增强。 juc-locks锁框架中一共就三个接口：Lock、Condition、ReadWriteLock。</p>
<h5 id="3-3-1-ReentrantLock"><a href="#3-3-1-ReentrantLock" class="headerlink" title="3.3.1 ReentrantLock"></a>3.3.1 ReentrantLock</h5><p>ReentrantLock叫做可重入锁，指的是线程可以重复获取同一把锁，或者说该锁支持一个线程对资源的 重复加锁。同时该锁还支持获取锁的公平性和非公平性选择，锁的公平性是指，在绝对时间上，先对锁 获取的请求一定先被满足，也就是等待时间长的那个线程优先获得，可以说，锁的获取是顺序的，即 符合FIFO规则。<br>ReentrantLock也是互斥锁，因此也可以保证原子性。<br>ReentrantLock 重入锁的基本原理是判断上次获取锁的线程是否为当前线程，如果是则可再次进入临 界区，如果不是，则阻塞。<br>由于ReentrantLock是基于AQS实现的，底层通过操作同步状态来获取锁.，下面看一下非公平锁的实 现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//获取当前线程         </span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();        </span><br><span class="line">    <span class="comment">//通过AQS获取同步状态       </span></span><br><span class="line">    <span class="keyword">int</span> c = getState();            </span><br><span class="line">    <span class="comment">//同步状态为0，说明临界区处于无锁状态，            </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;            </span><br><span class="line">        <span class="comment">//修改同步状态，即加锁          </span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;        </span><br><span class="line">            <span class="comment">//将当前线程设置为锁的owner     </span></span><br><span class="line">            setExclusiveOwnerThread(current);    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="comment">//如果临界区处于锁定状态，且上次获取锁的线程为当前线程  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;   </span><br><span class="line">        <span class="comment">//则递增同步状态       </span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;     </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow      </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);   </span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;       </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功获取锁的线程再次获取锁，只是增加了同步状态值，在释放同步转态时，相应的减少同步状态值， 实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;       </span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;   </span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())       </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;         </span><br><span class="line">    <span class="comment">//在同步状态完全释放了，设置true    </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;              </span><br><span class="line">        free = <span class="keyword">true</span>;       </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);     </span><br><span class="line">    &#125;           </span><br><span class="line">    setState(c);    </span><br><span class="line">    <span class="keyword">return</span> free;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁和非公平锁的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections; </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLockMine(<span class="keyword">true</span>); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLockMine(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    </span><br><span class="line">        testLock(<span class="string">"unfair lock"</span>, unfairLock);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        testLock(<span class="string">"fair lock"</span>, fairLock);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(String type, Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        System.out.println(type);    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;      </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(lock))&#123;     </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">                    <span class="keyword">return</span> getName();</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;;       </span><br><span class="line">            thread.setName(<span class="string">""</span> + i);    </span><br><span class="line">            thread.start();      </span><br><span class="line">        &#125;     </span><br><span class="line">        Thread.sleep(<span class="number">11000</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    </span><br><span class="line">        <span class="keyword">private</span> Lock lock;     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123;      </span><br><span class="line">            <span class="keyword">this</span>.lock = lock;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;      </span><br><span class="line">                lock.lock();           </span><br><span class="line">                <span class="keyword">try</span> &#123;            </span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">                    System.out.println(<span class="string">"获取锁的当前线程["</span> + Thread.currentThread().getName() + <span class="string">"], 同步队列中的线程"</span> + ((ReentrantLockMine)lock).getQueuedThreads() + <span class="string">""</span>);      </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </span><br><span class="line">                    e.printStackTrace();        </span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;                </span><br><span class="line">                    lock.unlock();       </span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockMine</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//重新实 现ReentrantLock类是为了重写getQueuedThreads方法，便于我们试验的观察</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLockMine</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">super</span>(fair);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>   </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="comment">//获取同步队列中的 线程          </span></span><br><span class="line">            List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt; (<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);     </span><br><span class="line">            <span class="keyword">return</span> arrayList;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁的获取，只要获取了同步状态就可以获取锁，有可能导致饥饿现象，但是非公平锁，线程的切 换比较少，更高效。<br>ReentrantLock与synchronized的区别</p>
<ul>
<li><p>重入 </p>
<p>synchronized可重入，因为加锁和解锁自动进行，不必担心后是否释放锁；ReentrantLock也 可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。</p>
</li>
<li><p>实现</p>
<p>synchronized是JVM实现的、而ReentrantLock是JDK实现的。说白了就是，是操作系统来实现， 还是用户自己敲代码实现。 </p>
</li>
<li><p>性能 </p>
<p>在 Java 的 1.5 版本中，synchronized 性能不如 SDK 里面的 Lock，但 1.6 版本之后， synchronized 做了很多优化，将性能追了上来。</p>
</li>
<li><p>功能 </p>
<p>ReentrantLock锁的细粒度和灵活度，优于synchronized。 ReentrantLock不同点一：可在构造函数中指定是公平锁还是非公平锁，而synchronized只能是非公平锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>ReentrantLock不同点二：可以避免死锁问题，因为它可以非阻塞地获取锁。如果尝试获取 锁失败，并不进入阻塞状态，而是直接返回false，这时候线程不用阻塞等待，可以先去做其他事情。 所以不会造成死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持非阻塞获取锁的 API </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>tryLock还支持超时。调用tryLock时没有获取到锁，会等待一段时间，如果线程在一段时间之内还是 没有获取到锁，不是进入阻塞状态，而是throws InterruptedException，那这个线程也有机会释放 曾经持有的锁，这样也能破坏死锁不可抢占条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>

<p>ReentrantLock不同点三：提供能够中断等待锁机制。</p>
<p>synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦 发生死锁，就没有任何机会来唤醒阻塞的线程。</p>
<p>但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤 醒它，那它就有机会释放曾经持有的锁 A。ReentrantLock可以用lockInterruptibly方法来实现。</p>
<p>ReentrantLock不同点四：可以用J.U.C包中的Condition实现分组唤醒需要等待的线程。而 synchronized只能notify或者notifyAll。</p>
<h5 id="3-3-2-LockSupport"><a href="#3-3-2-LockSupport" class="headerlink" title="3.3.2 LockSupport"></a>3.3.2 LockSupport</h5><p>LockSupport类，是JUC包中的一个工具类，定义了一组静态方法，提供基本的线程阻塞和唤醒功 能，是构建同步组件的基础工具，用来创建锁和其他同步类的基本线程阻塞原语。<br>LockSupport类的核心方法其实就两个：park() 和 unpark()，其中 park() 方法用来阻塞线程， unpark()方法用于唤醒指定线程。<br>和Object类的wait() 和 signal() 方法有些类似，但是LockSupport的这两种方法从语意上讲比 Object类的方法更清晰，而且可以针对指定线程进行阻塞和唤醒。<br>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，可以把许可看 成是一种（0，1）信号量（Semaphore），但与Semaphore不同的是，许可的量加上限1。<br>初始时，permit为0，当调用 unpark() 方法时，线程的permit加1，当调用 park()方法时，如果 permit为0，则调用线程进入阻塞状态。</p>
<p>假设现在需要实现一种FIFO类型的独占锁，可以把这种锁看成是ReentrantLock的公平锁简单版本， 且是不可重入的，就是说当一个线程获得锁后，其他等待线程以FIFO的调度方式等待获取锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">FIFOMutex</span>  </span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean locked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Thread&gt; waiters = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        Thread current = Thread.currentThread();       </span><br><span class="line">        waiters.add(current);       </span><br><span class="line">        <span class="comment">// 如果当前线程不在队首，或锁已被占用，则当前线程阻塞 </span></span><br><span class="line">        <span class="comment">// 这个判断的内在意图：锁必须由队首元素拿到    </span></span><br><span class="line">        <span class="keyword">while</span> (waiters.peek() != current || !locked.compareAndSet(<span class="keyword">false</span>,<span class="keyword">true</span>))&#123;  </span><br><span class="line">            LockSupport.park();      </span><br><span class="line">        &#125;       </span><br><span class="line">        waiters.remove();</span><br><span class="line">        <span class="comment">// 删除队首元素  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123; </span><br><span class="line">        locked.set(<span class="keyword">false</span>);    </span><br><span class="line">        LockSupport.unpark(waiters.peek());  </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFIFOMutex</span> </span>&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">         FIFOMutex mutex = <span class="keyword">new</span> FIFOMutex(); </span><br><span class="line">         MyThread a1 = <span class="keyword">new</span> MyThread(<span class="string">"a"</span>, mutex);   </span><br><span class="line">         MyThread a2 = <span class="keyword">new</span> MyThread(<span class="string">"b"</span>, mutex);   </span><br><span class="line">         MyThread a3 = <span class="keyword">new</span> MyThread(<span class="string">"c"</span>, mutex);  </span><br><span class="line">         a1.start();     </span><br><span class="line">         a2.start();     </span><br><span class="line">         a3.start();     </span><br><span class="line">         a1.join();        </span><br><span class="line">         a2.join();  </span><br><span class="line">         a3.join();     </span><br><span class="line">         System.out.println(<span class="string">"Finished"</span>);  </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> FIFOMutex mutex;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, FIFOMutex mutex)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;    </span><br><span class="line">            mutex.lock();      </span><br><span class="line">            count++;         </span><br><span class="line">            System.out.println(<span class="string">"thread:"</span>+Thread.currentThread().getName()+<span class="string">" name:"</span> + name + <span class="string">" count:"</span> + count);  </span><br><span class="line">            mutex.unlock();   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述FIFOMutex类的实现中，当判断锁已被占用时，会调用 LockSupport.park(this) 方法，将当前 调用线程阻塞；当使用完锁时，会调用 LockSupport.unpark(waiters.peek()) 方法将等待队列中 的队首线程唤醒。<br>通过LockSupport的这两个方法，可以很方便的阻塞和唤醒线程。</p>
<ul>
<li>park 方法是会响应中断的，但是不会抛出异常。（也就是说如果当前调用线程被中断，则会立即 返回但不会抛出中断异常） </li>
<li>park 的重载方法 park(Object blocker)，会传入一个blocker对象，所谓Blocker对象，其实 就是当前线程调用时所在调用对象（如上述示例中的FIFOMutex对象）。该对象一般供监视、诊断 工具确定线程受阻塞的原因时使用。</li>
</ul>
<h5 id="3-3-3-Condition"><a href="#3-3-3-Condition" class="headerlink" title="3.3.3 Condition"></a>3.3.3 Condition</h5><p>在没有Lock之前，我们使用synchronized来控制同步，配合Object的wait()、wait(long timeout)、notify()、以及notifyAll 等方法可以实现等待/通知模式。<br>Condition接口也提供了类似于Object的监听器方法、与Lock接口配合可以实现等待/通知模式，但是 两者还是有很大区别的，下图是两者的对比：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img2.jpg"  alt></p>
<p>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便 通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中， Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。</p>
<p>条件（也称为条件队列 或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同 的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性 是：以原子方式 释放相关的锁，并挂起当前线程，就像 Object.wait 做的那样。</p>
<p>Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。<br>核心方法<br>Condition提供了一系列的方法来对阻塞和唤醒线程：</p>
<ul>
<li>await()：造成当前线程在接到信号或被中断之前一直处于等待状态。</li>
<li>await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时 间之前一直处于等待状态。 </li>
<li>awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间 之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。 </li>
<li>awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。 </li>
<li>awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定后期限之前一 直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返 回false。</li>
<li>signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</li>
<li>signalAll() ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的 锁。</li>
</ul>
<p>Condition是一种广义上的条件队列。他为线程提供了一种更为灵活的等待/通知模式，线程在调用 await方法后执行挂起操作，直到线程等待的某个条件为真时才会被唤醒。Condition必须要配合锁一 起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑 定，因此Condition一般都是作为Lock的内部实现。</p>
<h6 id="源码探索"><a href="#源码探索" class="headerlink" title="源码探索"></a>源码探索</h6><p>获取一个Condition必须要通过Lock的newCondition()方法。该方法定义在接口Lock下，返回的结果 是绑定到此 Lock 实例的新 Condition 实例。<br>Condition为一个接口，其下仅有一个实现类ConditionObject，由于Condition的操作需要获取相关 的锁，而AQS则是同步锁的实现基础，所以ConditionObject则定义为AQS的内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>等待队列</strong><br>每个Condition对象都包含着一个FIFO队列，该队列是Condition对象通知/等待功能的关键。<br>在队列中每一个节点都包含着一个线程引用，该线程就是在该Condition对象上等待的线程。<br>Condition的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>; </span><br><span class="line">    <span class="comment">/** First node of condition queue. */</span>     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;           </span><br><span class="line">    <span class="comment">/** Last node of condition queue. */</span>   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">/**   </span></span><br><span class="line"><span class="comment">         * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">	  */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">       <span class="comment">// Internal methods     </span></span><br><span class="line">    	<span class="comment">// 省略方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出Condition拥有首节点（firstWaiter），尾节点（lastWaiter）。</p>
<p>当前线程调用await()方法，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾 部。<br>Node里面包含了当前线程的引用。Node定义与AQS的CLH同步队列的节点使用的都是同一个类。</p>
<p>Condition的队列结构比CLH同步队列的结构简单些，新增过程较为简单只需要将原尾节点的 nextWaiter指向新增节点，然后更新lastWaiter即可。</p>
<p><strong>等待</strong><br>调用Condition的await()方法会使当前线程进入等待状态，同时会加入到Condition等待队列并释放 锁。</p>
<p>当从await()方法返回时，当前线程一定是获取了Condition相的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    <span class="comment">// 当前线程中断、直接异常   </span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();     </span><br><span class="line">    <span class="comment">//加入等待队列            </span></span><br><span class="line">    Node node = addConditionWaiter();    </span><br><span class="line">    <span class="comment">//释放锁           </span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);      </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;      </span><br><span class="line">    <span class="comment">//检测当前节点是否在同步队列上、如果不在则说明该节点没有资格竞争锁，继续等 待。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;      </span><br><span class="line">        <span class="comment">// 挂起线程           </span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);           </span><br><span class="line">        <span class="comment">// 线程释是否被中断，中断直接退出      </span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)       </span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">    &#125;                   </span><br><span class="line">    <span class="comment">// 获取同步状态    </span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)    </span><br><span class="line">        interruptMode = REINTERRUPT;            </span><br><span class="line">    <span class="comment">// 清理条件队列         </span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// clean up if cancelled      </span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">	<span class="keyword">if</span> (interruptMode != <span class="number">0</span>)    </span><br><span class="line">    	reportInterruptAfterWait(interruptMode);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此段代码的逻辑是： 首先将当前线程新建一个节点同时加入到等待队列中，然后释放当前线程持有的同步状态。<br>然后则是不断检测该节点代表的线程是否出现在CLH同步队列中（收到signal信号之后就会在AQS队列 中检测到），如果不存在则一直挂起，否则参与竞争同步状态。</p>
<p><strong>加入条件队列（addConditionWaiter()）源码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//队列的尾节点          </span></span><br><span class="line">    Node t = lastWaiter;      </span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.           </span></span><br><span class="line">    <span class="comment">// 如果该节点的状态的不是CONDITION，则说明该节点不在等待队列上，需要清除       </span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;       </span><br><span class="line">        <span class="comment">// 清除等待队列中状态不为CONDITION的节点         </span></span><br><span class="line">        unlinkCancelledWaiters();                 </span><br><span class="line">        <span class="comment">//清除后重新获取尾节点           </span></span><br><span class="line">        t = lastWaiter;       </span><br><span class="line">    &#125;                 </span><br><span class="line">    <span class="comment">// 将当前线程构造成等待节点     </span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);     </span><br><span class="line">    <span class="comment">// 将node节点添加到等待队列的尾部      </span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)           </span><br><span class="line">        firstWaiter = node;       </span><br><span class="line">    <span class="keyword">else</span>           </span><br><span class="line">        t.nextWaiter = node;     </span><br><span class="line">    lastWaiter = node;      </span><br><span class="line">    <span class="keyword">return</span> node;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是将当前线程加入到Condition条件队列中。当然在加入到尾节点之前会清除所有状态不为 Condition的节点。<br>fullyRelease(Node node)，负责释放该线程持有的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;    </span><br><span class="line">    <span class="keyword">try</span> &#123;                 </span><br><span class="line">        <span class="comment">// 获取节点持有锁的数量       </span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();        </span><br><span class="line">        <span class="comment">// 释放锁也就是释放共享状态       </span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;      </span><br><span class="line">            failed = <span class="keyword">false</span>;        </span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)       </span><br><span class="line">            node.waitStatus = Node.CANCELLED;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isOnSyncQueue(Node node)：如果一个节点刚开始在条件队列上，现在在同步队列上获取锁则返回 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;    </span><br><span class="line">	<span class="comment">// 状态为CONDITION 、前驱节点为空，返回false    </span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;       </span><br><span class="line">    <span class="comment">// 如果后继节点不为空，则说明节点肯定在同步队列中       </span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="comment">// If has successor, it must be on queue            </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;     </span><br><span class="line">    <span class="comment">/*         </span></span><br><span class="line"><span class="comment">    * node.prev can be non-null, but not yet on queue because    </span></span><br><span class="line"><span class="comment">    * the CAS to place it on queue can fail. So we have to         </span></span><br><span class="line"><span class="comment">    * traverse from tail to make sure it actually made it.  It   </span></span><br><span class="line"><span class="comment">    * will always be near the tail in calls to this method, and    </span></span><br><span class="line"><span class="comment">    * unless the CAS failed (which is unlikely), it will be     </span></span><br><span class="line"><span class="comment">    * there, so we hardly ever traverse much.  </span></span><br><span class="line"><span class="comment">    */</span>     </span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlinkCancelledWaiters()：负责将条件队列中状态不为Condition的节点删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    <span class="comment">// 首节点           </span></span><br><span class="line">    Node t = firstWaiter;      </span><br><span class="line">    Node trail = <span class="keyword">null</span>;      </span><br><span class="line">    <span class="comment">// 从头开始清除状态不为CONDITION的节点       </span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;          </span><br><span class="line">        Node next = t.nextWaiter;          </span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;   </span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;       </span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)        </span><br><span class="line">                firstWaiter = next;  </span><br><span class="line">            <span class="keyword">else</span>                      </span><br><span class="line">                trail.nextWaiter = next;      </span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)       </span><br><span class="line">                lastWaiter = trail;        </span><br><span class="line">        &#125;               </span><br><span class="line">        <span class="keyword">else</span>             </span><br><span class="line">            trail = t;       </span><br><span class="line">        t = next;</span><br><span class="line">	&#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通知</strong></p>
<p>调用Condition的signal()方法，将会唤醒在等待队列中等待长时间的节点（条件队列里的首节 点），在唤醒节点前，会将节点移到同步队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果同步是以独占方式进行的，则返回 true；其他情况则返回 false  </span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())           </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();         </span><br><span class="line">    <span class="comment">// 唤醒首节点         </span></span><br><span class="line">    Node first = firstWaiter;             </span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)        </span><br><span class="line">        doSignal(first);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先会判断当前线程是否已经获得了锁，这是前置条件。然后唤醒条件队列中的头节点。<br>doSignal(Node first)：唤醒头节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">do</span> &#123;             </span><br><span class="line">        <span class="comment">// 修改头节点、方便移除          </span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)      </span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;        </span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;              </span><br><span class="line">        <span class="comment">// 将该节点移到同步队列      </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;     </span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doSignal(Node first)主要是做两件事：</p>
<ul>
<li>修改头节点；</li>
<li>调用transferForSignal(Node first) 方法将节点移动到CLH同步队列中。</li>
</ul>
<p>整个通知的流程如下：</p>
<ul>
<li>判断当前线程是否已经获取了锁，如果没有获取则直接抛出异常，因为获取锁为通知的前置条件。 </li>
<li>如果线程已经获取了锁，则将唤醒条件队列的首节点。 </li>
<li>唤醒首节点是先将条件队列中的头节点移出，然后调用AQS的enq(Node node)方法将其安全地移 到CLH同步队列中 。 </li>
<li>最后判断如果该节点的同步状态是否为Cancel，或者修改状态为Signal失败时，则直接调用 LockSupport唤醒该节点的线程。</li>
</ul>
<p>一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到条件队列中，然后释 放锁，后通过isOnSyncQueue(Node node)方法不断自检看节点是否已经在CLH同步队列了，如果是 则尝试获取锁，否则一直挂起。<br>当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法唤醒CLH同步队列的首节点。被唤醒的线程，将从await()方法中的while循环中退出来， 然后调用acquireQueued()方法竞争同步状态。<br>栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition();  </span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        </span><br><span class="line">       lock.lock();     </span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">           <span class="keyword">while</span> (count == items.length)    </span><br><span class="line">               notFull.await();    </span><br><span class="line">            items[putptr] = x;    </span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;   </span><br><span class="line">            ++count;    </span><br><span class="line">            notEmpty.signal(); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">            lock.unlock();    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">       lock.lock();    </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"> 			<span class="keyword">while</span> (count == <span class="number">0</span>)   </span><br><span class="line">                notEmpty.await(); </span><br><span class="line">           Object x = items[takeptr];   </span><br><span class="line">           <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>; </span><br><span class="line">           --count;      </span><br><span class="line">           notFull.signal();     </span><br><span class="line">           <span class="keyword">return</span> x;  </span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">           lock.unlock();   </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-4-Synchronizers"><a href="#3-4-Synchronizers" class="headerlink" title="3.4 Synchronizers"></a>3.4 Synchronizers</h4><h5 id="3-4-1-Semaphore"><a href="#3-4-1-Semaphore" class="headerlink" title="3.4.1 Semaphore"></a>3.4.1 Semaphore</h5><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，通过协调各个线程，保证合理的使用 公共资源。<br>Semaphore维护了一个许可集，其实就是一定数量的“许可证”。 当有线程想要访问共享资源时，需要先获取(acquire)的许可；如果许可不够了，线程需要一直等待， 直到许可可用。当线程使用完共享资源后，可以归还(release)许可，以供其它需要的线程使用。<br>和ReentrantLock类似，Semaphore支持公平/非公平策略。<br>源码:略。<br>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个会实现print queue的类名为 PrintQueue。 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个对象为Semaphore，称它为semaphore。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;  </span><br><span class="line">    <span class="comment">// 实现类的构造函数并初始能保护print quere的访问的semaphore对象的值。  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintQueue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Implement the printJob()方法，此方法可以模拟打印文档，并接收document对象 作为参数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//在这方法内，首先，你必须调用acquire()方法获得demaphore。这个方法会抛出 InterruptedException异常，使用必须包含处理这个异常的代码。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;           </span><br><span class="line">            semaphore.acquire();</span><br><span class="line">             </span><br><span class="line"><span class="comment">//然后，实现能随机等待一段时间的模拟打印文档的行。   </span></span><br><span class="line">             <span class="keyword">long</span> duration = (<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line"> 			System.out.printf(<span class="string">"%s: PrintQueue: Printing a Job during %d seconds\n"</span>, Thread.currentThread().getName(), duration);</span><br><span class="line">            Thread.sleep(duration);</span><br><span class="line"><span class="comment">//最后，释放semaphore通过调用semaphore的relaser()方法。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;        </span><br><span class="line">            semaphore.release();   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个名为Job的类并一定实现Runnable 接口。这个类实现把文档传送到打印机的任务。 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//声明一个对象为PrintQueue，名为printQueue。   </span></span><br><span class="line">    <span class="keyword">private</span> PrintQueue printQueue;  </span><br><span class="line">    <span class="comment">//实现类的构造函数，初始化这个类里的PrintQueue对象。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.printQueue = printQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现方法run()。 </span></span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//首先， 此方法写信息到操控台表明任务已经开始执行了。    </span></span><br><span class="line">        System.out.printf(<span class="string">"%s: Going to print a job\n"</span>, Thread.currentThread().getName());          </span><br><span class="line">        <span class="comment">// 然后，调用PrintQueue 对象的printJob()方法。   </span></span><br><span class="line">        printQueue.printJob(<span class="keyword">new</span> Object());         </span><br><span class="line">        <span class="comment">//最后， 此方法写信息到操控台表明它已经结束运行了。 </span></span><br><span class="line">        System.out.printf(<span class="string">"%s: The document has been printed\n"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">                <span class="comment">// 创建PrintQueue对象名为printQueue。      </span></span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();      </span><br><span class="line">        <span class="comment">//创建10个threads。每个线程会执行一个发送文档到print queue的Job对象。   </span></span><br><span class="line">        Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;     </span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue), <span class="string">"Thread"</span> + i);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">            thread[i].start();    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-CountDownLatch"><a href="#3-4-2-CountDownLatch" class="headerlink" title="3.4.2 CountDownLatch"></a>3.4.2 CountDownLatch</h5><p>在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能，在这种的业务场景下，通常可以使用Thread类的join方法，让主线程等待被join的线程执 行完之后，主线程才能继续往下执行。当然，使用线程间消息通信机制也可以完成。其实，java并发工 具类中为我们提供了类似“倒计时”这样的工具类，可以十分方便的完成所说的这种业务场景。<br>CountDownLatch允许一个或多个线程等待其他线程完成工作。<br>CountDownLatch相关方法：</p>
<ul>
<li><p>public CountDownLatch(int count) 构造方法会传入一个整型数N，之后调用 CountDownLatch的 countDown 方法会对N减一，知道N减到0的时候，当前调用 await 方法的线程继续执行。</p>
</li>
<li><p>await() throws InterruptedException：调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行；</p>
</li>
<li><p>await(long timeout, TimeUnit unit)：与上面的await方法功能一致，只不过这里有了时间 限制，调用该方法的线程等到指定的timeout时间后，不管N是否减至为0，都会继续往下执行；</p>
</li>
<li><p>countDown()：使CountDownLatch初始值N减1；</p>
</li>
<li><p>long getCount()：获取当前CountDownLatch维护的值</p>
</li>
</ul>
<p>  栗子：运动员进行跑步比赛时，假设有6个运动员参与比赛，裁判员在终点会为这6个运动员分别计时， 可以想象没当一个运动员到达终点的时候，对于裁判员来说就少了一个计时任务。直到所有运动员都到 达终点了，裁判员的任务也才完成。这6个运动员可以类比成6个线程，当线程调用 CountDownLatch.countDown方法时就会对计数器的值减一，直到计数器的值为0的时候，裁判员（调 用await方法的线程）才能继续往下执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//用来表示裁判员需要维护的是6个运动员 </span></span><br><span class="line">    rivate <span class="keyword">static</span> CountDownLatch endSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;   </span><br><span class="line">        executorService.execute(() -&gt; &#123;        </span><br><span class="line">            <span class="keyword">try</span> &#123;              </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 运动 员等待裁判员响哨！！！"</span>);          </span><br><span class="line">                startSignal.await();     </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在 全力冲刺"</span>); </span><br><span class="line">                endSignal.countDown();    </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"  到 达终点"</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </span><br><span class="line">                e.printStackTrace();       </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(<span class="string">"裁判员响哨开始啦！！！"</span>);    </span><br><span class="line">    startSignal.countDown(); </span><br><span class="line">    endSignal.await();  </span><br><span class="line">    System.out.println(<span class="string">"所有运动员到达终点，比赛结束！"</span>);</span><br><span class="line"> 	executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例代码中设置了两个CountDownLatch，第一个endSignal用于控制让main线程（裁判员）必须等 到其他线程（运动员）让CountDownLatch维护的数值N减到0为止，相当于一个完成信号；另一个 startSignal用于让main线程对其他线程进行“发号施令”，相当于一个入口或者开关。</p>
<p>startSignal引用的CountDownLatch初始值为1，而其他线程执行的run方法中都会先通过 startSignal.await()让这些线程都被阻塞，直到main线程通过调用startSignal.countDown();， 将值N减1，CountDownLatch维护的数值N为0后，其他线程才能往下执行，并且，每个线程执行的run 方法中都会通过endSignal.countDown();对endSignal维护的数值进行减一，由于往线程池提交了6 个任务，会被减6次，所以endSignal维护的值终会变为0，因此main线程在latch.await();阻塞结 束，才能继续往下执行。</p>
<p><code>注意：当调用CountDownLatch的countDown方法时，当前线程是不会被阻塞，会继续往下执行。</code></p>
<h5 id="3-4-3-CyclicBarrier"><a href="#3-4-3-CyclicBarrier" class="headerlink" title="3.4.3 CyclicBarrier"></a>3.4.3 CyclicBarrier</h5><p>CountDownLatch是一个倒数计数器，在计数器不为0时，所有调用await的线程都会等待，当计数器降 为0，线程才会继续执行，且计数器一旦变为0，就不能再重置了。</p>
<p>CyclicBarrier可以认为是一个栅栏，栅栏的作用是什么？就是阻挡前行。</p>
<p>CyclicBarrier是一个可以循环使用的栅栏，它做的事情就是：让线程到达栅栏时被阻塞(调用await 方法)，直到到达栅栏的线程数满足指定数量要求时，栅栏才会打开放行，被栅栏拦截的线程才可以执行。</p>
<p>当多个线程都达到了指定点后，才能继续往下继续执行。这就有点像报数的感觉，假设6个线程就相当 于6个运动员，到赛道起点时会报数进行统计，如果刚好是6的话，这一波就凑齐了，才能往下执行。这 里的6个线程，也就是计数器的初始值6，是通过CyclicBarrier的构造方法传入的。</p>
<p>CyclicBarrier的主要方法：</p>
<ul>
<li><p>await() throws InterruptedException, BrokenBarrierException  等到所有的线程都到 达指定的临界点； </p>
</li>
<li><p>await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException 与上面的await方法功能基本一致，只不过这 里有超时限制，阻塞等待直至到达超时时间为止；</p>
</li>
<li><p>int getNumberWaiting()获取当前有多少个线程阻塞等待在临界点上；</p>
</li>
<li><p>boolean isBroken()用于查询阻塞等待的线程是否被中断 </p>
</li>
<li><p>void reset()将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出 BrokenBarrierException。 </p>
</li>
</ul>
<p>  另外需要注意的是，CyclicBarrier提供了这样的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure>

<p>可以用来，当指定的线程都到达了指定的临界点的时，接下来执行的操作可以由barrierAction传入即 可。</p>
<p>栗子：</p>
<p>6个运动员准备跑步比赛，运动员在赛跑需要在起点做好准备，当裁判发现所有运动员准备完毕后，就 举起发令枪，比赛开始。这里的起跑线就是屏障，是临界点，而这6个运动员就类比成线程的话，就是 这6个线程都必须到达指定点了，意味着凑齐了一波，然后才能继续执行，否则每个线程都得阻塞等待，直至凑齐一波即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">6</span>;  </span><br><span class="line">        <span class="comment">// 运动员数    </span></span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> Runnable() &#123;    </span><br><span class="line">            <span class="meta">@Override</span>         </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">                System.out.println(<span class="string">"所有运动员已准备完毕，发令枪：跑！"</span>);      </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;        </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrepareWork(cb), <span class="string">"运动员["</span> + i + <span class="string">"]"</span>); </span><br><span class="line">            t.start();      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrepareWork</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cb;</span><br><span class="line">        </span><br><span class="line">        PrepareWork(CyclicBarrier cb) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.cb = cb;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;        </span><br><span class="line">                Thread.sleep(<span class="number">500</span>);     </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": 准 备完成"</span>);  </span><br><span class="line">                cb.await();     </span><br><span class="line">                <span class="comment">// 在栅栏等待     </span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;         </span><br><span class="line">                e.printStackTrace();   </span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;      </span><br><span class="line">                e.printStackTrace();      </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，当6个运动员（线程）都到达了指定的临界点（barrier）时候，才能继续往下 执行，否则，则会阻塞等待在调用 await() 处。</p>
<h6 id="CyclicBarrier对异常的处理"><a href="#CyclicBarrier对异常的处理" class="headerlink" title="CyclicBarrier对异常的处理"></a>CyclicBarrier对异常的处理</h6><p><strong>线程在阻塞过程中，可能被中断，那么既然CyclicBarrier放行的条件是等待的线程数达到指定数目， 万一线程被中断导致终的等待线程数达不到栅栏的要求怎么办？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;    </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法除了抛出InterruptedException异常外，还会抛出 BrokenBarrierException 。<br>BrokenBarrierException表示当前的CyclicBarrier已经损坏了，等不到所有线程都到达栅栏了，所 以已经在等待的线程也没必要再等了，可以散伙了。<br>出现以下几种情况之一时，当前等待线程会抛出BrokenBarrierException异常：</p>
<ul>
<li><p>其它某个正在await等待的线程被中断了；</p>
</li>
<li><p>其它某个正在await等待的线程超时了；</p>
</li>
<li><p>某个线程重置了CyclicBarrier；</p>
<p>另外，只要正在Barrier上等待的任一线程抛出了异常，那么Barrier就会认为肯定是凑不齐所有线程了，就会将栅栏置为损坏（Broken）状态，并传播BrokenBarrierException给其它所有正在等待 （await）的线程。<br>异常情况模拟：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">6</span>;  </span><br><span class="line">        <span class="comment">// 运动员数   </span></span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>        </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">                System.out.println(<span class="string">"所有运动员已准备完毕，发令枪：跑！"</span>);    </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;     </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrepareWork(cb), <span class="string">"运动员["</span> + i + <span class="string">"]"</span>);  </span><br><span class="line">            list.add(t);        </span><br><span class="line">            t.start();        </span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;      </span><br><span class="line">                t.interrupt(); </span><br><span class="line">                <span class="comment">// 运动员[3]置中断标志位      </span></span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        System.out.println(<span class="string">"Barrier是否损坏："</span> + cb.isBroken());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrepareWork</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cb;</span><br><span class="line">        </span><br><span class="line">        PrepareWork(CyclicBarrier cb) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.cb = cb;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;           </span><br><span class="line">            <span class="keyword">try</span> &#123;          </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": 准 备完成"</span>);  </span><br><span class="line">                cb.await();      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  				System.out.println(Thread.currentThread().getName() + <span class="string">": 被 中断"</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;        </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": 抛 出BrokenBarrierException"</span>);       </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch与CyclicBarrier的比较<br>CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数 器，但是这两者还是各有不同侧重点的：</p>
<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大 家都完成，再携手共进。 </li>
<li>调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了 指定点的时候，才能继续往下执行； </li>
<li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过 getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的 构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；</li>
<li>CountDownLatch是不能复用的，而CyclicLatch是可以复用的。</li>
</ul>
<h5 id="3-4-4-Exchanger"><a href="#3-4-4-Exchanger" class="headerlink" title="3.4.4 Exchanger"></a>3.4.4 Exchanger</h5><p>Exchanger可以用来在两个线程之间交换持有的对象。当Exchanger在一个线程中调用exchange方法之 后，会等待另外的线程调用同样的exchange方法，两个线程都调用exchange方法之后，传入的参数就 会交换。<br>两个主要方法<br>public V exchange(V x) throws InterruptedException<br>当这个方法被调用的时候，当前线程将会等待直到其他的线程调用同样的方法。当其他的线程调用 exchange之后，当前线程将会继续执行。<br>在等待过程中，如果有其他的线程interrupt当前线程，则会抛出InterruptedException。<br>public V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException<br>多了一个timeout时间。如果在timeout时间之内没有其他线程调用exchange方法，抛出 TimeoutException。</p>
<p>栗子：<br>我们先定义一个带交换的类：</p>
<p>然后定义两个Runnable，在run方法中调用exchange方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">         Exchanger&lt;CustBook&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();    </span><br><span class="line">         <span class="comment">// Starting two threads    </span></span><br><span class="line">         <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExchangerOne(exchanger)).start();     </span><br><span class="line">         <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExchangerTwo(exchanger)).start();  </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustBook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerOne</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Exchanger&lt;CustBook&gt; ex;</span><br><span class="line">    </span><br><span class="line">    ExchangerOne(Exchanger&lt;CustBook&gt; ex)&#123;  </span><br><span class="line">        <span class="keyword">this</span>.ex=ex;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        CustBook custBook= <span class="keyword">new</span> CustBook();    </span><br><span class="line">        custBook.setName(<span class="string">"book one"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">            CustBook exhangeCustBook=ex.exchange(custBook);  </span><br><span class="line">            log.info(exhangeCustBook.getName());     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;      </span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTwo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Exchanger&lt;CustBook&gt; ex;</span><br><span class="line">    ExchangerTwo(Exchanger&lt;CustBook&gt; ex)&#123;   </span><br><span class="line">        <span class="keyword">this</span>.ex=ex;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CustBook custBook= <span class="keyword">new</span> CustBook();  </span><br><span class="line">        custBook.setName(<span class="string">"book two"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;     </span><br><span class="line">            CustBook exhangeCustBook=ex.exchange(custBook);  </span><br><span class="line">            log.info(exhangeCustBook.getName());     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-5-Phaser"><a href="#3-4-5-Phaser" class="headerlink" title="3.4.5 Phaser"></a>3.4.5 Phaser</h5><p>Phaser是一个同步工具类，适用于一些需要分阶段的任务的处理。它的功能与 CyclicBarrier和 CountDownLatch类似，类似于一个多阶段的栅栏，并且功能更强大，我们来比较下这三者的功能：</p>
<table>
<thead>
<tr>
<th><strong>CountDownLatch</strong></th>
<th>倒数计数器，初始时设定计数器值，线程可以在计数器上等待，当计数器 值归0后，所有等待的线程继续执行</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CyclicBarrier</strong></td>
<td><strong>循环栅栏，初始时设定参与线程数，当线程到达栅栏后，会等待其它线程的到达，当到达栅栏的总数满足指定数后，所有等待的线程继续执行</strong></td>
</tr>
<tr>
<td><strong>Phaser</strong></td>
<td><strong>多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与 者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级  （advance）</strong></td>
</tr>
</tbody></table>
<p>相关概念：</p>
<p><strong>phase(阶段)</strong></p>
<p>Phaser也有栅栏，在Phaser中，栅栏的名称叫做phase(阶段)，在任意时间点，Phaser只处于某一个 phase(阶段)，初始阶段为0，大达到Integerr.MAX_VALUE，然后再次归零。当所有parties参与者 都到达后，phase值会递增。</p>
<p><strong>parties(参与者)</strong></p>
<p>Phaser既可以在初始构造时指定参与者的数量，也可以中途通过register、bulkRegister、 arriveAndDeregister等方法注册/注销参与者。</p>
<p><strong>arrive(到达) / advance(进阶)</strong></p>
<p>Phaser注册完parties（参与者）之后，参与者的初始状态是unarrived的，当参与者到达 （arrive）当前阶段（phase）后，状态就会变成arrived。当阶段的到达参与者数满足条件后（注册 的数量等于到达的数量），阶段就会发生进阶（advance）——也就是phase值+1。</p>
<p><strong>Termination（终止）</strong></p>
<p>代表当前Phaser对象达到终止状态。</p>
<p><strong>Tiering（分层）</strong></p>
<p>Phaser支持分层（Tiering） —— 一种树形结构，通过构造函数可以指定当前待构造的Phaser对象 的父结点。之所以引入Tiering，是因为当一个Phaser有大量参与者（parties）的时候，内部的同步 操作会使性能急剧下降，而分层可以降低竞争，从而减小因同步导致的额外开销。<br>在一个分层Phasers的树结构中，注册和撤销子Phaser或父Phaser是自动被管理的。当一个Phaser参 与者（parties）数量变成0时，如果有该Phaser有父结点，就会将它从父结点中溢移除。<br>核心方法：</p>
<ul>
<li><p>arriveAndDeregister() 该方法立即返回下一阶段的序号，并且其它线程需要等待的个数减 一，     取消自己的注册、把当前线程从之后需要等待的成员中移除。     如果该Phaser是另外一个Phaser的子Phaser（层次化Phaser），     并且该操作导致当前Phaser的成员数为0，则该操作也会将当前Phaser从其父Phaser中移除。 </p>
</li>
<li><p>arrive() 某个参与者完成任务后调用，该方法不作任何等待，直接返回下一阶段的序号。</p>
</li>
<li><p>awaitAdvance(int phase) 该方法等待某一阶段执行完毕。     如果当前阶段不等于指定的阶段或者该Phaser已经被终止，则立即返回。     该阶段数一般由arrive()方法或者arriveAndDeregister()方法返回。 返回下一阶段的序号，或者返回参数指定的值（如果该参数为负数），或者直接返回当前阶 段序号（如果当前Phaser已经被终止）。 </p>
</li>
<li><p>awaitAdvanceInterruptibly(int phase) 效果与awaitAdvance(int phase)相当， 唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出InterruptedException。</p>
</li>
<li><p>awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)   效果与awaitAdvanceInterruptibly(int phase)相当，区别在于如果超时则抛出TimeoutException。 </p>
</li>
<li><p>bulkRegister(int parties) 动态调整注册任务parties的数量。如果当前phaser已经被终 止，则该方法无效，并返回负数。     如果调用该方法时，onAdvance方法正在执行，则该方法等待其执行完毕。     如果该Phaser有父Phaser则指定的party数大于0，且之前该Phaser的party数为0，那么该 Phaser会被注册到其父Phaser中。</p>
</li>
<li><p>forceTermination() 强制让该Phaser进入终止状态。 已经注册的party数不受影响。如果该Phaser有子Phaser，则其所有的子Phaser均进入终止 状态。如果该Phaser已经处于终止状态，该方法调用不造成任何影响。 </p>
</li>
</ul>
<p>栗子：3个线程，4个阶段，每个阶段都并发处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kaikeba.com;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> parties = <span class="number">3</span>;       </span><br><span class="line">        <span class="keyword">int</span> phases = <span class="number">4</span>;    </span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(parties) &#123;      </span><br><span class="line">            <span class="meta">@Override</span>         </span><br><span class="line">            <span class="comment">//每个阶段结束时      </span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">"====== Phase : "</span> + phase + <span class="string">"  end ======"</span>);  </span><br><span class="line">                <span class="keyword">return</span> registeredParties == <span class="number">0</span>;      </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parties; i++) &#123;   </span><br><span class="line">            <span class="keyword">int</span> threadId = i;      </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;         </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> phase = <span class="number">0</span>; phase &lt; phases; phase++) &#123;    </span><br><span class="line">                    <span class="keyword">if</span> (phase == <span class="number">0</span>) &#123;     </span><br><span class="line">                        System.out.println(String.format(<span class="string">"第一阶段操作  Thread %s, phase %s"</span>, threadId, phase));               </span><br><span class="line">                    &#125;          </span><br><span class="line">                    <span class="keyword">if</span> (phase == <span class="number">1</span>) &#123;  </span><br><span class="line">                        System.out.println(String.format(<span class="string">"第二阶段操作  Thread %s, phase %s"</span>, threadId, phase));             </span><br><span class="line">                    &#125;           </span><br><span class="line">                    <span class="keyword">if</span> (phase == <span class="number">2</span>) &#123;     </span><br><span class="line">                        System.out.println(String.format(<span class="string">"第三阶段操作  Thread %s, phase %s"</span>, threadId, phase));      </span><br><span class="line">                    &#125;          </span><br><span class="line">                    <span class="keyword">if</span> (phase == <span class="number">3</span>) &#123;    </span><br><span class="line">                        System.out.println(String.format(<span class="string">"第四阶段操作  Thread %s, phase %s"</span>, threadId, phase));   </span><br><span class="line">					 &#125;      </span><br><span class="line">                    <span class="comment">/**        </span></span><br><span class="line"><span class="comment">                      * arriveAndAwaitAdvance() 当前线程当前阶段执行完毕，等待其它线程完成当前 阶段。         </span></span><br><span class="line"><span class="comment">                      * 如果当前线程是该阶段最后一个未到达的，则该方法直接返回下一个阶段的序号（阶段 序号从0开始），         </span></span><br><span class="line"><span class="comment">                      * 同时其它线程的该方法也返回下一个阶段的序号。  </span></span><br><span class="line"><span class="comment">                      **/</span>              </span><br><span class="line">                    <span class="keyword">int</span> nextPhaser = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;);      </span><br><span class="line">            thread.start();  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-Executors"><a href="#3-5-Executors" class="headerlink" title="3.5 Executors"></a>3.5 Executors</h4><h5 id="3-5-1-Executor框架"><a href="#3-5-1-Executor框架" class="headerlink" title="3.5.1 Executor框架"></a>3.5.1 Executor框架</h5><p>Executor框架包括3大部分：</p>
<ul>
<li>任务。也就是工作单元，包括被执行任务需要实现的接口：Runnable接口或者Callable接口；</li>
<li>任务的执行。也就是把任务分派给多个线程的执行机制，包括Executor接口及继承自Executor接 口的ExecutorService接口。</li>
<li>异步计算的结果。包括Future接口及实现了Future接口的FutureTask类。</li>
</ul>
<p>Executor框架的成员及其关系可以用一下的关系图表示：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img3.jpg"  alt></p>
<p>Executor框架的使用示意图：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img4.jpg"  alt></p>
<p>使用步骤：</p>
<ul>
<li>创建Runnable并重写run（）方法或者Callable对象并重写call（）方法，得到一个任务对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">callableImp</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span> &gt;</span>&#123;     </span><br><span class="line">    <span class="meta">@Override</span>         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">try</span>&#123;             </span><br><span class="line">            String a = <span class="string">"return String"</span>;       </span><br><span class="line">            <span class="keyword">return</span> a;         </span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"exception"</span>;     </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建ExecutorService接口的实现类ThreadPoolExecutor类或者 ScheduledThreadPoolExecutor类的对象，然后调用其execute()方法或者submit()方法，提 交任务对象执行。</li>
<li>主线程调用Future对象的get()方法获取返回值，或者调用Future对象的cancel()方法取消当前 线程的执行。</li>
</ul>
<p>Executor框架成员：ThreadPoolExecutor实现类、ScheduledThreadPoolExecutor实现类、Future 接口、Runnable和Callable接口、Executors工厂类<br>Executor:执行器接口，也是顶层的抽象核心接口， 分离了任务和任务的执行。ExecutorService 在Executor的基础上提供了执行器生命周期管理，任务异步执行等功能。<br>Executors：生产具体的执行器的静态工厂。<br>ThreadPoolExecutor:线程池Executor，也是常用的Executor，通常使用Executors来创建，可以 创建三种类型的ThreadPoolExecutor：SingleThreadPoolExecutor，FixedThreadPool和 CachedThreadPool，以线程池的方式管理线程。<br>ScheduledThreadPoolExecutor：在ThreadPoolExecutor基础上，增加了对周期任务调度的支持。</p>
<p>Runnable和Callable接口：Runnable和Callable接口的实现类，可以被ThreadPoolExecutor和 ScheduledThreadPoolExecutor执行，区别是，亲着没有返回结果，候着可以返回结果。</p>
<h5 id="3-5-2-ThreadPoolExecutor"><a href="#3-5-2-ThreadPoolExecutor" class="headerlink" title="3.5.2 ThreadPoolExecutor"></a>3.5.2 ThreadPoolExecutor</h5><p>ThreadPoolExecutor一共提供了4种构造器，但其它三种内部其实都调用了下面的构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 使用给定的参数创建ThreadPoolExecutor. </span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize    核心线程池中的最大线程数 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 总线程池中的最大线程数 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime   空闲线程的存活时间 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit            keepAliveTime的单位 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue       任务队列, 保存已经提交但尚未被执行的线程 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory   线程创建工厂 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler         拒绝策略 (当任务太多导致工作队列满时的处理策略) </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,       </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,       </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,                 </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,     </span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,   </span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||        </span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||    </span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||   </span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();    </span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   </span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;     </span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;     </span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;     </span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);  </span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;   </span><br><span class="line">    <span class="keyword">this</span>.handler = handler; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池状态定义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*    </span></span><br><span class="line"><span class="comment">  * RUNNING -&gt; SHUTDOWN   </span></span><br><span class="line"><span class="comment">  *    On invocation of shutdown(), perhaps implicitly in finalize()  </span></span><br><span class="line"><span class="comment">  * (RUNNING or SHUTDOWN) -&gt; STOP     </span></span><br><span class="line"><span class="comment">  *    On invocation of shutdownNow()    </span></span><br><span class="line"><span class="comment">  * SHUTDOWN -&gt; TIDYING    </span></span><br><span class="line"><span class="comment">  *    When both queue and pool are empty   </span></span><br><span class="line"><span class="comment">  * STOP -&gt; TIDYING   </span></span><br><span class="line"><span class="comment">  *    When pool is empty     </span></span><br><span class="line"><span class="comment">  * TIDYING -&gt; TERMINATED    </span></span><br><span class="line"><span class="comment">  *    When the terminated() hook method has completed  </span></span><br><span class="line"><span class="comment">  * */</span>   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor一共定义了5种线程池状态：</p>
<ul>
<li>RUNNING : 接受新任务, 且处理已经进入阻塞队列的任务 </li>
<li>SHUTDOWN : 不接受新任务, 但处理已经进入阻塞队列的任务 </li>
<li>STOP : 不接受新任务, 且不处理已经进入阻塞队列的任务, 同时中断正在运行的任务 </li>
<li>TIDYING : 所有任务都已终止, 工作线程数为0, 线程转化为TIDYING状态并准备调用 </li>
<li>terminated方法 TERMINATED : terminated方法已经执行完成</li>
</ul>
<p>各个状态之间的流转图： </p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img5.jpg"  alt></p>
<p>执行execute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();       </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();    </span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;      </span><br><span class="line">        <span class="comment">// CASE1: 工作线程数 &lt; 核心 线程池上限   </span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))     </span><br><span class="line">            <span class="comment">// 添加工作线程并执行       </span></span><br><span class="line">            <span class="keyword">return</span>;     </span><br><span class="line">        c = ctl.get(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 执行到此处, 说明工作线程创建失败 或 工作线程数≥核心线程池上限  </span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   </span><br><span class="line">        <span class="comment">// CASE2: 插入任务至 队列</span></span><br><span class="line">        <span class="comment">// 再次检查线程池状态    </span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();    </span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))     </span><br><span class="line">            reject(command);     </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)      </span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))     </span><br><span class="line">        <span class="comment">// CASE3: 插入队列失败, 判断 工作线程数 &lt; 总线程池上限    </span></span><br><span class="line">        reject(command);   </span><br><span class="line">    	<span class="comment">// 执行拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述execute的执行流程可以用下图描述：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img6.jpg"  alt></p>
<p>execute的整个执行流程关键是下面两点：</p>
<ul>
<li>如果工作线程数小于核心线程池上限（CorePoolSize），则直接新建一个工作线程并执行任务；</li>
<li>如果工作线程数大于等于CorePoolSize，则尝试将任务加入到队列等待以后执行。如果加入队列 失败了（比如队列已满的情况），则在总线程池未满的情况下（ CorePoolSize ≤ 工作线程数 ＜ maximumPoolSize ）新建一个工作线程立即执行任务，否则执行拒绝策略。</li>
</ul>
<p>通过Executor框架的工具类Executors，可以创建三种类型的ThreadPoolExecutor：<br>FixedThreadPool：可重用固定线程数的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,  </span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,    </span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>newFixedThreadPool</strong>创建一个固定长度的线程池，每次提交一个任务的时候就会创建一个新的线程， 直到达到线程池的大数量限制。</p>
<ul>
<li>定长，可以控制线程大并发数， corePoolSize 和 maximumPoolSize 的数值都是 nThreads。</li>
<li>超出线程数的任务会在队列中等待。 </li>
<li>工作队列为LinkedBlockingQueue</li>
</ul>
<p>创建方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="keyword">int</span> nThreads);</span><br></pre></td></tr></table></figure>

<p>SingleThreadExecutor:使用单个线程的Executor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService      </span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,  </span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,    </span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),  </span><br><span class="line">                                threadFactory));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>newSingleThreadExecutor</strong>，只创建一个工作线程执行任务，若这个唯一的线程异常故障了，会新建 另一个线程来替代，newSingleThreadExecutor可以保证任务依照在工作队列的排队顺序来串行执 行。</p>
<ul>
<li>有且仅有一个工作线程执行任务；</li>
<li>所有任务按照工作队列的排队顺序执行，先进先出的顺序</li>
<li>工作队列LinkedBlockingQueue</li>
</ul>
<p>创建方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadPool = Executors.newSingleThreadPool();</span><br></pre></td></tr></table></figure>

<p>CachedThreadPool:会根据需要创建新线程的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,    </span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,    </span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),     </span><br><span class="line">                                  threadFactory);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>newCachedThreadPool</strong>将创建一个可缓存的线程池，如果当前线程数超过处理任务时，回收空闲线 程；当需求增加时，可以添加新线程去处理任务。<br>特点：</p>
<ul>
<li>线程数无限制，corePoolSize数值为0， maximumPoolSize 的数值都是为 Integer.MAX_VALUE。</li>
<li>若线程未回收，任务到达时，会复用空闲线程；</li>
<li>若无空闲线程，则新建线程执行任务。 因为复用性，一定程序减少频繁创建/销毁线程，减少系统开销。</li>
<li>工作队列选用SynchronousQueue。</li>
</ul>
<p>创建方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">2</span>;     </span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">4</span>;   </span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">10</span>;    </span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;       </span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);      </span><br><span class="line">        RejectedExecutionHandler handler = <span class="keyword">new</span> RejectedExecutionPolicy();   </span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,</span><br><span class="line">                                                             maximumPoolSize, </span><br><span class="line">                                                             keepAliveTime, unit,   </span><br><span class="line">                                                             workQueue, handler); </span><br><span class="line">        executor.prestartAllCoreThreads();</span><br><span class="line">        <span class="comment">// 预启动所有核心线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;    </span><br><span class="line">            ThreadTask task = <span class="keyword">new</span> ThreadTask(String.valueOf(i));     </span><br><span class="line">            executor.execute(task);     </span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read(); </span><br><span class="line">        <span class="comment">//阻塞主线程 </span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectedExecutionPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;     </span><br><span class="line">            doLog(r, e);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;     </span><br><span class="line">            System.err.println( r.toString() + <span class="string">" rejected"</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(String name)</span> </span>&#123;    </span><br><span class="line">            <span class="keyword">this</span>.name = name;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"> System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is running!"</span>);   </span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);     </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        </span><br><span class="line">                e.printStackTrace();      </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">            <span class="keyword">return</span> name;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>       </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ThreadTask [name="</span> + name + <span class="string">"]"</span>;      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-3-ScheduledExecutorService"><a href="#3-5-3-ScheduledExecutorService" class="headerlink" title="3.5.3 ScheduledExecutorService"></a>3.5.3 ScheduledExecutorService</h5><p><strong>构造线程池</strong><br>Executors使用 newScheduledThreadPool 工厂方法创建ScheduledThreadPoolExecutor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledThreadPoolExecutor的构造器，内部其实都是调用了父类ThreadPoolExecutor的构造 器，这里比较特别的是任务队列的选择——DelayedWorkQueue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, RejectedExecutionHandler handler)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), </span><br><span class="line">          handler); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池的调度</strong><br>该线程池的核心调度方法，是schedule、scheduleAtFixedRate、scheduleWithFixedDelay，通过 schedule方法来看下整个调度流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)      </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   </span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,                                                                                        triggerTime(delay, unit)));  </span><br><span class="line">    delayedExecute(t);   </span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的decorateTask方法把Runnable任务包装成ScheduledFutureTask，用户可以根据自己的需要 覆写该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledFutureTask是RunnableScheduledFuture接口的实现类，任务通过period字段来表示任务 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//任务序号, 自增唯一 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 首次执行的时间点   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">// 0: 非周期任务; &gt;0: fixed-rate任务;&lt;0: fixed-delay任务  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在堆中的索引    </span></span><br><span class="line">    <span class="keyword">int</span> heapIndex;</span><br><span class="line"> </span><br><span class="line">    ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;   </span><br><span class="line">        <span class="keyword">super</span>(r, result);       </span><br><span class="line">        <span class="keyword">this</span>.time = ns;     </span><br><span class="line">        <span class="keyword">this</span>.period = <span class="number">0</span>;       </span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement(); </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledThreadPoolExecutor中的任务队列——DelayedWorkQueue，保存的元素就是 ScheduledFutureTask。DelayedWorkQueue是一种堆结构，time小的任务会排在堆顶（表示早 过期），每次出队都是取堆顶元素，这样快到期的任务就会被先执行。如果两个 ScheduledFutureTask的time相同，就比较它们的序号——sequenceNumber，序号小的代表先被提 交，所以就会先执行。</p>
<p>schedule的核心是其中的delayedExecute方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isShutdown())  </span><br><span class="line">        <span class="comment">// 线程池已关闭        </span></span><br><span class="line">        reject(task);   </span><br><span class="line">    <span class="comment">// 任务拒绝策略 </span></span><br><span class="line">    <span class="keyword">else</span> &#123;     </span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);  </span><br><span class="line">        <span class="comment">// 将任务入队</span></span><br><span class="line">        <span class="comment">// 如果线程池已关闭且该任务是非周期任务, 则将其从队列移除     </span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))            task.cancel(<span class="keyword">false</span>); </span><br><span class="line">        <span class="comment">// 取消任务    </span></span><br><span class="line">        <span class="keyword">else</span>       </span><br><span class="line">            ensurePrestart();  </span><br><span class="line">        <span class="comment">// 添加一个工作线程  </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理过程：</p>
<ul>
<li>任务被提交到线程池后，会判断线程池的状态，如果不是RUNNING状态会执行拒绝策略；</li>
<li>然后，将任务添加到阻塞队列中，由于DelayedWorkQueue是无界队列，所以一定会add成功；</li>
<li>然后，会创建一个工作线程，加入到核心线程池或者非核心线程池；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());  </span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        <span class="comment">//如果核心线程池未满，则新建的工作线程会被放到核心线程 池中。   </span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)  </span><br><span class="line">        <span class="comment">//当通过setCorePoolSize方法设置核心线程池大小为0时，这 里必须要保证任务能够被执行，会创建一个工作线程，放到非核心线程池中。    </span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">    <span class="comment">//如果核心线程池已经满了,不会再去创建工作线程,直接返回。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后，线程池中的工作线程会去任务队列获取任务并执行，当任务被执行完成后，如果该任务是周 期任务，则会重置time字段，并重新插入队列中，等待下次执行。 </p>
</li>
<li><p>从队列中获取元素的方法：</p>
<p>​         对于核心线程池中的工作线程来说，如果没有超时设置（ allowCoreThreadTimeOut == false ），则会使用阻塞方法take获取任务（因为没有超时限制，所以会一直等待直到队列中有 任务）；如果设置了超时，则会使用poll方法（方法入参需要超时时间），超时还没拿到任务的 话，该工作线程就会被回收。</p>
<p> 对于非工作线程来说，都是调用poll获取队列元素，超时取不到任务就会被回收。</p>
</li>
</ul>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;   </span><br><span class="line">        ScheduledThreadPoolExecutorTest.scheduleWithFixedDelay();      </span><br><span class="line">        ScheduledThreadPoolExecutorTest.scheduleAtFixedRate();  </span><br><span class="line">        ScheduledThreadPoolExecutorTest.scheduleCaller();       </span><br><span class="line">        ScheduledThreadPoolExecutorTest.scheduleRunable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务以固定时间间隔执行，延迟5s后开始执行任务，任务执行完毕后间隔5s再次执行，依次往 复  </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;      </span><br><span class="line">        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        ScheduledFuture&lt;?&gt; result = executorService.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;          </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">                </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;, <span class="number">5000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 由于是定时任务，一直不会返回   </span></span><br><span class="line">        result.get();     </span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 相对开始加入任务的时间点固定频率执行：从加入任务开始算2s后开始执行任务，2+5s开始 执行，2+2*5s执行，2+n*5s开始执行；    </span></span><br><span class="line">    <span class="comment">// 但是如果执行任务时间大于5s,则不会并发执行，后续任务将会延迟。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123; </span><br><span class="line">        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        ScheduledFuture&lt;?&gt; result = executorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">                </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;, <span class="number">2000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于是定时任务，一直不会返回 </span></span><br><span class="line">        result.get();   </span><br><span class="line">        System.out.println(<span class="string">"over"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延迟2s后开始执行，只执行一次，没有返回值</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleRunable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">        ScheduledFuture&lt;?&gt; result = executorService.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span>            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                System.out.println(<span class="string">"gh"</span>);                <span class="keyword">try</span> &#123;                    Thread.sleep(<span class="number">3000</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="comment">// TODO Auto-generated catch block                    e.printStackTrace();                &#125;</span></span><br><span class="line">            &#125;        &#125;, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延迟2s后开始执行，只执行一次，有返回值   </span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleCaller</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;  </span><br><span class="line">     ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">     </span><br><span class="line">        ScheduledFuture&lt;String&gt; result = executorService.schedule(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;          </span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);        </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block    </span></span><br><span class="line">                    e.printStackTrace();      </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"gh"</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 阻塞，直到任务执行完成    </span></span><br><span class="line">     </span><br><span class="line">     	System.out.print(result.get());</span><br><span class="line">     </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Frosro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://frosro.github.io/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/">https://frosro.github.io/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://frosro.github.io" target="_blank">BETTER LATE THAN NEVER</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/02/08/SpringCloudAlibaba%E4%B9%8BSentinel/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringCloud Alibaba 之 Sentinel（一）</div></div></a></div><div class="next-post pull_right"><a href="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发编程（二）</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/01/08/并发编程（二）/" title="并发编程（二）"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-08</div><div class="relatedPosts_title">并发编程（二）</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/07/并发编程（一）/" title="并发编程（一）"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-07</div><div class="relatedPosts_title">并发编程（一）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/19/Lambda表达式常见应用场景/" title="Lambda表达式常见应用场景"><img class="relatedPosts_cover lazyload"data-src="https://i.loli.net/2020/04/19/iWxHeZF4SME5Psv.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-19</div><div class="relatedPosts_title">Lambda表达式常见应用场景</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/26/Java-synchronized原理总结/" title="Java synchronized原理总结"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-26</div><div class="relatedPosts_title">Java synchronized原理总结</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/06/Java虚拟机/" title="Java虚拟机"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-06</div><div class="relatedPosts_title">Java虚拟机</div></div></a></div><div class="relatedPosts_item"><a href="/2022/02/08/SpringCloudAlibaba之Sentinel/" title="SpringCloud Alibaba 之 Sentinel（一）"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-02-08</div><div class="relatedPosts_title">SpringCloud Alibaba 之 Sentinel（一）</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTMzNS8yNTgyNw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Frosro</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">-------------非常欢迎 <i class="fa fa-paw"></i> 来到我的博客-------------</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>