<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>并发编程（二） | BETTER LATE THAN NEVER</title><meta name="description" content="并发编程（二）"><meta name="keywords" content="JAVA,并发编程"><meta name="author" content="Frosro"><meta name="copyright" content="Frosro"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="并发编程（二）"><meta name="twitter:description" content="并发编程（二）"><meta name="twitter:image" content="https://frosro.github.io/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="并发编程（二）"><meta property="og:url" content="https://frosro.github.io/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"><meta property="og:site_name" content="BETTER LATE THAN NEVER"><meta property="og:description" content="并发编程（二）"><meta property="og:image" content="https://frosro.github.io/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://frosro.github.io/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"><link rel="prev" title="SpringCloud Alibaba 之 Sentinel" href="https://frosro.github.io/2021/01/09/SpringCloud-Alibaba-%E4%B9%8B-Sentinel/"><link rel="next" title="并发编程（一）" href="https://frosro.github.io/2021/01/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="BETTER LATE THAN NEVER" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#二、并发编程基础"><span class="toc-number">1.</span> <span class="toc-text">二、并发编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-临界资源"><span class="toc-number">1.0.1.</span> <span class="toc-text">2.1 临界资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-线程安全"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.2 线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-基本概念"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">2.2.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#竞态条件："><span class="toc-number">1.0.2.1.1.</span> <span class="toc-text">竞态条件：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#线程安全："><span class="toc-number">1.0.2.1.2.</span> <span class="toc-text">线程安全：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-对象的安全"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">2.2.2 对象的安全</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#局部基本类型变量"><span class="toc-number">1.0.2.2.1.</span> <span class="toc-text">局部基本类型变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#局部的对象引用"><span class="toc-number">1.0.2.2.2.</span> <span class="toc-text">局部的对象引用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#对象成员-成员变量"><span class="toc-number">1.0.2.2.3.</span> <span class="toc-text">对象成员(成员变量)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-不可变性"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">2.2.3 不可变性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Java内存模型"><span class="toc-number">1.0.3.</span> <span class="toc-text">2.3 Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#线程之间的通信"><span class="toc-number">1.0.3.0.1.</span> <span class="toc-text">线程之间的通信</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#线程之间的同步"><span class="toc-number">1.0.3.0.2.</span> <span class="toc-text">线程之间的同步</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Java的并发采用的是共享内存模型"><span class="toc-number">1.0.3.0.3.</span> <span class="toc-text">Java的并发采用的是共享内存模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Java内存模型结构"><span class="toc-number">1.0.3.0.4.</span> <span class="toc-text">Java内存模型结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-CAS乐观锁"><span class="toc-number">1.0.4.</span> <span class="toc-text">2.4 CAS乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Synchronized块"><span class="toc-number">1.0.5.</span> <span class="toc-text">2.5 Synchronized块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#有四种不同的同步块："><span class="toc-number">1.0.5.1.</span> <span class="toc-text">有四种不同的同步块：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#实例方法同步"><span class="toc-number">1.0.5.1.1.</span> <span class="toc-text">实例方法同步</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#静态方法同步"><span class="toc-number">1.0.5.1.2.</span> <span class="toc-text">静态方法同步</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#实例方法中的同步块"><span class="toc-number">1.0.5.1.3.</span> <span class="toc-text">实例方法中的同步块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#静态方法中的同步块"><span class="toc-number">1.0.5.1.4.</span> <span class="toc-text">静态方法中的同步块</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Synchronized锁的存储"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">Synchronized锁的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Java对象头的长度"><span class="toc-number">1.0.5.2.1.</span> <span class="toc-text">Java对象头的长度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Mark-Word的存储结构"><span class="toc-number">1.0.5.2.2.</span> <span class="toc-text">Mark Word的存储结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Mark-Word可能的存储结果："><span class="toc-number">1.0.5.2.3.</span> <span class="toc-text">Mark Word可能的存储结果：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#偏向锁"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#轻量级锁"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重量级锁"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">重量级锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-关键字Volatile"><span class="toc-number">1.0.6.</span> <span class="toc-text">2.6 关键字Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#可见性："><span class="toc-number">1.0.6.1.</span> <span class="toc-text">可见性：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#原子性："><span class="toc-number">1.0.6.2.</span> <span class="toc-text">原子性：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#有序性："><span class="toc-number">1.0.6.3.</span> <span class="toc-text">有序性：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-本地线程"><span class="toc-number">1.0.7.</span> <span class="toc-text">2.7 本地线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8、多线程问题"><span class="toc-number">1.0.8.</span> <span class="toc-text">2.8、多线程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-8-1-死锁"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">2.8.1 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#死锁的产生"><span class="toc-number">1.0.8.1.1.</span> <span class="toc-text">死锁的产生</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#更复杂的死锁"><span class="toc-number">1.0.8.1.2.</span> <span class="toc-text">更复杂的死锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#数据库的死锁"><span class="toc-number">1.0.8.1.3.</span> <span class="toc-text">数据库的死锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#死锁的避免"><span class="toc-number">1.0.8.1.4.</span> <span class="toc-text">死锁的避免</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-8-2-饥饿和公平"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">2.8.2 饥饿和公平</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Java中导致饥饿的原因"><span class="toc-number">1.0.8.2.1.</span> <span class="toc-text">Java中导致饥饿的原因</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BETTER LATE THAN NEVER</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">并发编程（二）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-01-08 22:06:31"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-01-08</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-01-09 23:01:54"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-01-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%F0%9F%90%BAJAVA/">🐺JAVA</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="二、并发编程基础"><a href="#二、并发编程基础" class="headerlink" title="二、并发编程基础"></a>二、并发编程基础</h2><h4 id="2-1-临界资源"><a href="#2-1-临界资源" class="headerlink" title="2.1 临界资源"></a>2.1 临界资源</h4><p>临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资 源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间 采取互斥方式，实现对这种资源的共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;         </span><br><span class="line">         <span class="keyword">this</span>.count = <span class="keyword">this</span>.count + value;    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-线程安全"><a href="#2-2-线程安全" class="headerlink" title="2.2 线程安全"></a>2.2 线程安全</h4><h5 id="2-2-1-基本概念"><a href="#2-2-1-基本概念" class="headerlink" title="2.2.1 基本概念"></a>2.2.1 基本概念</h5><h6 id="竞态条件："><a href="#竞态条件：" class="headerlink" title="竞态条件："></a>竞态条件：</h6><p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。<br>导致竞态条件发生的代码区称作临界区。<br>在临界区中使用适当的同步就可以避免竞态条件，如使用synchronized或者加锁机制。</p>
<h6 id="线程安全："><a href="#线程安全：" class="headerlink" title="线程安全："></a>线程安全：</h6><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。</p>
<h5 id="2-2-2-对象的安全"><a href="#2-2-2-对象的安全" class="headerlink" title="2.2.2 对象的安全"></a>2.2.2 对象的安全</h5><h6 id="局部基本类型变量"><a href="#局部基本类型变量" class="headerlink" title="局部基本类型变量"></a>局部基本类型变量</h6><p>局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。</p>
<p>下面是基础类型的局部变量的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;        </span><br><span class="line">        MyThread share = <span class="keyword">new</span> MyThread();        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;           </span><br><span class="line">            <span class="keyword">new</span> Thread(share,<span class="string">"线程"</span>+i).start();        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> a =<span class="number">0</span>;        </span><br><span class="line">        ++a;       		</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+a); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>无论多少个线程对run()方法中的基本类型a执行++a操作，只是更新当前线程栈的值，不会影响其他线程，也就是不共享数据；</p>
<h6 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h6><p>对象的局部引用和基础类型的局部变量不太一样，尽管引用本身没有被共享，但引用所指的对象并没有 存储在线程的栈内。所有的对象都存在共享堆中。 如果在某个方法中创建的对象不会逃逸出（即该对象不会被其它方法获得，也不会被非局部变量引用 到）该方法，那么它就是线程安全的。 实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    LocalObject localObject = <span class="keyword">new</span> LocalObject();</span><br><span class="line">    localObject.callMethod();</span><br><span class="line">    method2(localObject); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(LocalObject localObject)</span></span>&#123;</span><br><span class="line">    localObject.setValue(<span class="string">"value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="对象成员-成员变量"><a href="#对象成员-成员变量" class="headerlink" title="对象成员(成员变量)"></a>对象成员(成员变量)</h6><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        NotThreadSafe sharedInstance = <span class="keyword">new</span> NotThreadSafe();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(sharedInstance)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(sharedInstance)).start();</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">     NotThreadSafe instance = <span class="keyword">null</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(NotThreadSafe instance)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.instance = instance;    </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.instance.add(<span class="string">" "</span>+Thread.currentThread().getName());</span><br><span class="line">         System.out.println(<span class="keyword">this</span>.instance.builder.toString());</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotThreadSafe</span></span>&#123;</span><br><span class="line">     StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String text)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.builder.append(text);    </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。</p>
<h5 id="2-2-3-不可变性"><a href="#2-2-3-不可变性" class="headerlink" title="2.2.3 不可变性"></a>2.2.3 不可变性</h5><p>通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableValue</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意ImmutableValue类的成员变量 value 是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value 变量就不能再被修改，这就是不可变性。但你可以通过 getValue()方法读取这个变量的值。</p>
<h4 id="2-3-Java内存模型"><a href="#2-3-Java内存模型" class="headerlink" title="2.3 Java内存模型"></a>2.3 Java内存模型</h4><p><strong>Java内存模型</strong>即<strong>Java Memory Model</strong>，简称<strong>JMM</strong>。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p>
<h6 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h6><p>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种共享内 存和消息传递。<br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐 式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。<br>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通 信，在java中典型的消息传递方式就是wait()和notify()。</p>
<h6 id="线程之间的同步"><a href="#线程之间的同步" class="headerlink" title="线程之间的同步"></a>线程之间的同步</h6><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。<br>在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间 互斥执行。<br>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<h6 id="Java的并发采用的是共享内存模型"><a href="#Java的并发采用的是共享内存模型" class="headerlink" title="Java的并发采用的是共享内存模型"></a>Java的并发采用的是共享内存模型</h6><p>Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h6 id="Java内存模型结构"><a href="#Java内存模型结构" class="headerlink" title="Java内存模型结构"></a>Java内存模型结构</h6><p>Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度 来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory） 中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量 的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img1.png"  alt></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。 </li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<h4 id="2-4-CAS乐观锁"><a href="#2-4-CAS乐观锁" class="headerlink" title="2.4 CAS乐观锁"></a>2.4 CAS乐观锁</h4><p><strong>乐观锁</strong>：不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。其实现方式有一种比较典型的就是Compare and Swap( CAS )。<br>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应 的值修改为B。<br>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属 于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p><strong>CAS的缺点：</strong></p>
<ol>
<li>CPU开销较大在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>
<li>不能保证代码块的原子性 CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量 共同进行原子性的更新，就不得不使用Synchronized了。</li>
</ol>
<h4 id="2-5-Synchronized块"><a href="#2-5-Synchronized块" class="headerlink" title="2.5 Synchronized块"></a>2.5 Synchronized块</h4><p>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上 的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执 行该同步块中的线程退出。</p>
<h5 id="有四种不同的同步块："><a href="#有四种不同的同步块：" class="headerlink" title="有四种不同的同步块："></a>有四种不同的同步块：</h5><ul>
<li><p>实例方法 </p>
</li>
<li><p>静态方法 </p>
</li>
<li><p>实例方法中的同步块 </p>
</li>
<li><p>静态方法中的同步块</p>
<p>上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。</p>
</li>
</ul>
<blockquote>
<h6 id="实例方法同步"><a href="#实例方法同步" class="headerlink" title="实例方法同步"></a>实例方法同步</h6></blockquote>
<p>下面是一个同步的实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count += value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在方法声明中同步（synchronized ）关键字。<br>Java实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上， 即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线 程一次可以在一个实例同步块中执行操作。</p>
<blockquote>
<h6 id="静态方法同步"><a href="#静态方法同步" class="headerlink" title="静态方法同步"></a>静态方法同步</h6></blockquote>
<p>静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123; </span><br><span class="line">    count += value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，这里synchronized 关键字告诉Java这个方法是同步的。<br>静态方法的同步是指同步在该方法所在的类对象上。因为在Java虚拟机中一个类只能对应一个类对象， 所以同时只允许一个线程执行同一个类中的静态同步方法。<br>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那 个静态同步方法被调用，一个类只能由一个线程同时执行。</p>
<blockquote>
<h6 id="实例方法中的同步块"><a href="#实例方法中的同步块" class="headerlink" title="实例方法中的同步块"></a>实例方法中的同步块</h6></blockquote>
<p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。<br>在非同步的Java方法中的同步块的例子如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.count += value;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。<br>注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本 身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。<br>一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。<br>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">       log.writeln(msg1);       </span><br><span class="line">       log.writeln(msg2);    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;       </span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;          </span><br><span class="line">           log.writeln(msg1);          </span><br><span class="line">           log.writeln(msg2);       </span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。<br>如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。</p>
<blockquote>
<h6 id="静态方法中的同步块"><a href="#静态方法中的同步块" class="headerlink" title="静态方法中的同步块"></a>静态方法中的同步块</h6></blockquote>
<p>和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">        log.writeln(msg1);       </span><br><span class="line">        log.writeln(msg2);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;       </span><br><span class="line">        <span class="keyword">synchronized</span>(MyClass<span class="class">.<span class="keyword">class</span>)</span>&#123;          </span><br><span class="line">            log.writeln(msg1);          </span><br><span class="line">            log.writeln(msg2);       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法不允许同时被线程访问。<br>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p>
<h5 id="Synchronized锁的存储"><a href="#Synchronized锁的存储" class="headerlink" title="Synchronized锁的存储"></a>Synchronized锁的存储</h5><p>synchronized用的锁存储在Java对象头，如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果 对象是非数组类型，则用2字宽存储对象头，32位虚拟机，1字宽等于4字节，即32位.</p>
<h6 id="Java对象头的长度"><a href="#Java对象头的长度" class="headerlink" title="Java对象头的长度"></a>Java对象头的长度</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img2.jpg"  alt></p>
<h6 id="Mark-Word的存储结构"><a href="#Mark-Word的存储结构" class="headerlink" title="Mark Word的存储结构"></a>Mark Word的存储结构</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img3.jpg"  alt></p>
<h6 id="Mark-Word可能的存储结果："><a href="#Mark-Word可能的存储结果：" class="headerlink" title="Mark Word可能的存储结果："></a>Mark Word可能的存储结果：</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img4.jpg"  alt></p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的获取流程：<br> （1）查看Mark Word中偏向锁的标识以及锁标志位，若是否偏向锁为1且锁标志位为01，则该锁为可偏向状态。<br> （2）若为可偏向状态，则测试Mark Word中的线程ID是否与当前线程相同，若相同，表示线程已经获得了锁，如果不同，则进入（3）<br> （3）测试Mark Word的偏向锁的标识是否设置为1，如果没有设置，则使用CAS操作竞争锁，如何设置 了，则尝试使用CAS尝试将Mark Word中线程ID设置为当前线程ID，如果尝试失败，则执行（4）<br> （4）当前线程通过CAS竞争锁失败的情况下，说明有竞争。当到达全局安全点（在这个时间点，没有 正在执行的代码）时之前获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线 程继续往下执行同步代码。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，使用轻量级锁能够减少性 能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁。<br>轻量级锁的加锁过程：<br>（1）当线程执行代码进入同步块时，若Mark Word为无锁状态，虚拟机先在当前线程的栈帧中建立一 个名为Lock Record的空间，用于存储当前对象的Mark Word的拷贝，官方称之为“Dispalced Mark Word”，此时状态如下图：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img5.jpg"  alt></p>
<p>（2）复制对象头中的Mark Word到锁记录中。<br>（3）复制成功后，虚拟机将用CAS操作将对象的Mark Word更新为执行Lock  Record的指针，并将 Lock Record里的owner指针指向对象的Mark Word。如果更新成功，则执行4，否则执行5。；<br>（4）如果更新成功，则这个线程拥有了这个锁，并将锁标志设为00，表示处于轻量级锁状态，此时状态图：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img6.jpg"  alt></p>
<p>（5）如果更新失败，则说明有其他线程竞争锁，当前线程便通过自旋来获取锁。轻量级锁就会膨胀为 重量级锁，Mark Word中存储重量级锁（互斥锁）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>即当有其他线程占用锁时，当前线程会进入阻塞状态。</p>
<h4 id="2-6-关键字Volatile"><a href="#2-6-关键字Volatile" class="headerlink" title="2.6 关键字Volatile"></a>2.6 关键字Volatile</h4><p>Volatile是轻量级的synchronized,在多处理器环境下，可以保证共享变量的可见性。它不会引起线 程上下文的切换和调度，正确的使用Volatile,比synchronized的使用和执行成本更低。</p>
<h5 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h5><p>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改一 个共享变量时，另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。</p>
<p>volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但 是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比 如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原 子操作，也就是这个操作同样存在线程安全问题。<br>　　在 Java 中 volatile、synchronized 和 final 实现可见性。</p>
<h5 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h5><p>　　子是世界上的小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不 可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割 的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术 （sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的 concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如： AtomicInteger、AtomicLong、AtomicReference等。<br>　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p>
<h5 id="有序性："><a href="#有序性：" class="headerlink" title="有序性："></a>有序性：</h5><p>　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性， volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时 刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步 块只能串行执行。<br>　Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线 程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该 变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可 见的地方，因此在读取volatile类型的变量时总会返回新写入的值。<br>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是 一种比sychronized关键字更轻量级的同步机制。<br>当一个变量定义为 volatile 之后，将具备两种特性：<br>保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个 变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普 通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏 障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU 采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。</p>
<h4 id="2-7-本地线程"><a href="#2-7-本地线程" class="headerlink" title="2.7 本地线程"></a>2.7 本地线程</h4><p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个 ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变 量。<br>如何创建ThreadLocal变量<br>以下代码展示了如何创建一个ThreadLocal变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal();</span><br></pre></td></tr></table></figure>

<p>我们可以看到，通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却 只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个 ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。<br>如何访问ThreadLocal变量<br>一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThreadLocal.set(<span class="string">"A thread local value”);</span></span><br></pre></td></tr></table></figure>

<p>可以通过下面方法读取保存在ThreadLocal变量中的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String threadLocalValue = (String) myThreadLocal.get();</span><br></pre></td></tr></table></figure>

<p>ThreadLocal例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            threadLocal.set((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D));            </span><br><span class="line">            <span class="keyword">try</span> &#123;            </span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;            </span><br><span class="line">            System.out.println(threadLocal.get());        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;         </span><br><span class="line">        MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        thread1.start();         </span><br><span class="line">        thread2.start();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子创建了一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行 run()方法，并且都在ThreadLocal实例上保存了不同的值。如果它们访问的不是ThreadLocal对象并 且调用的set()方法被同步了，则第二个线程会覆盖掉第一个线程设置的值。但是，由于它们访问的是 一个ThreadLocal对象，因此这两个线程都无法看到对方保存的值。也就是说，它们存取的是两个不同 的值。<br>关于InheritableThreadLocal<br>InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与 ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以 访问它保存的值。</p>
<h4 id="2-8、多线程问题"><a href="#2-8、多线程问题" class="headerlink" title="2.8、多线程问题"></a>2.8、多线程问题</h4><h5 id="2-8-1-死锁"><a href="#2-8-1-死锁" class="headerlink" title="2.8.1 死锁"></a>2.8.1 死锁</h5><h6 id="死锁的产生"><a href="#死锁的产生" class="headerlink" title="死锁的产生"></a>死锁的产生</h6><p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时 但以不同的顺序请求同一组锁的时候。<br>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这 时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事 情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p>
<h6 id="更复杂的死锁"><a href="#更复杂的死锁" class="headerlink" title="更复杂的死锁"></a>更复杂的死锁</h6><p>死锁可能不止包含2个线程，这让检测死锁变得更加困难。</p>
<p>线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。</p>
<h6 id="数据库的死锁"><a href="#数据库的死锁" class="headerlink" title="数据库的死锁"></a>数据库的死锁</h6><p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。当在一个事 务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。同一个事务 中每一个更新请求都可能会锁住一些记录。<br>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction 1, request 1, locks record 1 for <span class="keyword">update</span> </span><br><span class="line"><span class="keyword">Transaction</span> <span class="number">2</span>, request <span class="number">1</span>, locks <span class="built_in">record</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">Transaction</span> <span class="number">1</span>, request <span class="number">2</span>, tries <span class="keyword">to</span> <span class="keyword">lock</span> <span class="built_in">record</span> <span class="number">2</span> <span class="keyword">for</span> update. </span><br><span class="line"><span class="keyword">Transaction</span> <span class="number">2</span>, request <span class="number">2</span>, tries <span class="keyword">to</span> <span class="keyword">lock</span> <span class="built_in">record</span> <span class="number">1</span> <span class="keyword">for</span> update.</span><br></pre></td></tr></table></figure>

<p>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。</p>
<h6 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h6><p><strong>加锁顺序</strong><br>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。<br>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread 1:  lock A   lock B</span><br><span class="line">Thread 2:   wait for A   lock C (when A locked)</span><br><span class="line">Thread 3:   wait for A   wait for B   wait for C</span><br></pre></td></tr></table></figure>

<p>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上 排在前面的锁之后，才能获取后面的锁。<br>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。<br>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者 注：并对这些锁做适当的排序)，但总有些时候是无法预知的。</p>
<p><strong>加锁时限</strong></p>
<p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过 程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的 锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让 其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加 锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。<br>以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 locks A </span><br><span class="line">Thread 2 locks B</span><br><span class="line">Thread 1 attempts to lock B but is blocked</span><br><span class="line">Thread 2 attempts to lock A but is blocked</span><br><span class="line">Thread 1&#39;s lock attempt on B times out </span><br><span class="line">Thread 1 backs up and releases A as well </span><br><span class="line">Thread 1 waits randomly (e.g. 257 millis) before retrying.</span><br><span class="line">Thread 2&#39;s lock attempt on A times out</span><br><span class="line">Thread 2 backs up and releases B as well </span><br><span class="line">Thread 2 waits randomly (e.g. 43 millis) before retrying.</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时， 线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2 或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。<br>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。</p>
<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些 线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间， 这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间 的概率就高的多（或者非常接近以至于会出现问题）。</p>
<p><code>**这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。**</code></p>
<p><strong>死锁检测</strong></p>
<p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。<br>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外， 每当有线程请求锁，也需要记录在这个数据结构中。<br>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7， 但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请 求锁1）。<br>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线 程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自 己持有着。这是它就知道发生了死锁。</p>
<p><strong><em>那么当检测出死锁时，这些线程该做些什么呢？</em></strong></p>
<p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似， 不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。<br>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一 样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的 优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</p>
<h5 id="2-8-2-饥饿和公平"><a href="#2-8-2-饥饿和公平" class="headerlink" title="2.8.2 饥饿和公平"></a>2.8.2 饥饿和公平</h5><p><strong><em>如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。</em></strong>而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。<strong>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。</strong></p>
<h6 id="Java中导致饥饿的原因"><a href="#Java中导致饥饿的原因" class="headerlink" title="Java中导致饥饿的原因"></a>Java中导致饥饿的原因</h6><p>在Java中，下面三个常见的原因会导致线程饥饿：</p>
<ul>
<li><p>高优先级线程吞噬所有的低优先级线程的CPU时间 </p>
<p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你好是不要改变其优先级值。 </p>
</li>
<li><p>线程被永久堵塞在一个等待进入同步块的状态 </p>
<p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p>
</li>
<li><p>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象 </p>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Frosro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://frosro.github.io/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/">https://frosro.github.io/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://frosro.github.io" target="_blank">BETTER LATE THAN NEVER</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/01/09/SpringCloud-Alibaba-%E4%B9%8B-Sentinel/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringCloud Alibaba 之 Sentinel</div></div></a></div><div class="next-post pull_right"><a href="/2021/01/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发编程（一）</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/01/09/并发编程（三）/" title="并发编程（三）"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-09</div><div class="relatedPosts_title">并发编程（三）</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/07/并发编程（一）/" title="并发编程（一）"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-07</div><div class="relatedPosts_title">并发编程（一）</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/09/SpringCloud-Alibaba-之-Sentinel/" title="SpringCloud Alibaba 之 Sentinel"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-09</div><div class="relatedPosts_title">SpringCloud Alibaba 之 Sentinel</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/29/JAVA集合的多种遍历方式总结/" title="JAVA集合的多种遍历方式总结"><img class="relatedPosts_cover lazyload"data-src="https://i.loli.net/2020/03/29/183Bi4j9ctYagso.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-29</div><div class="relatedPosts_title">JAVA集合的多种遍历方式总结</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/13/JAVA反射机制/" title="JAVA反射机制"><img class="relatedPosts_cover lazyload"data-src="https://i.loli.net/2020/04/13/rZzEn8GiO15t2Kx.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-13</div><div class="relatedPosts_title">JAVA反射机制</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/19/java-Hibernate-知识检验/" title="java Hibernate 知识检验"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-19</div><div class="relatedPosts_title">java Hibernate 知识检验</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTMzNS8yNTgyNw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Frosro</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">-------------非常欢迎 <i class="fa fa-paw"></i> 来到我的博客-------------</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>