<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>并发编程（三）</title>
    <url>/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="三、JUC-java-util-concurrent"><a href="#三、JUC-java-util-concurrent" class="headerlink" title="三、JUC:java.util.concurrent"></a>三、JUC:java.util.concurrent</h3><h4 id="3-1-集合"><a href="#3-1-集合" class="headerlink" title="3.1 集合"></a>3.1 集合</h4><h5 id="3-1-1-BlockingQueue"><a href="#3-1-1-BlockingQueue" class="headerlink" title="3.1.1 BlockingQueue"></a>3.1.1 BlockingQueue</h5><p><strong>什么是阻塞队列？</strong></p>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时， 获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>阻塞队列提供了四种处理方法:</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。 </li>
<li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元 素，如果没有则返回null</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直 到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻 塞消费者线程，直到队列可用。 </li>
<li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出</li>
</ul>
<p>阻塞队列接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue的核心方法：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，成功返回true, 否则抛出异常。如果向限定了容量的队列中插入值，推 荐使用offer()方法。    </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出 空指针异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入元素e到队列中，，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的 空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"> <span class="comment">//在给定的时间插入元素e到队列中，如果设置成功返回true, 否则返回false.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//检索并从队列的头部删除元素，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该 方法取得了该值。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//在给定的时间范围内，检索并从队列的头部删除元素，从队列中获取值，如果没有取到会抛出异常。</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>        </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//获取队列中剩余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从队列中移除指定的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//判断队列中是否包含该值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//将队列中值，全部移除，并追加到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line">    <span class="comment">//指定最多数量限制将队列中值，全部移除，并追加到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承关系</p>
<ul>
<li><p>子接口： </p>
<p><strong>BlockingDeque</strong></p>
</li>
</ul>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img1.jpg"  alt></p>
<p>​        <strong>TransferQueue</strong></p>
<p>TransferQueue继承了BlockingQueue,并扩展了一些新方法。 </p>
<p>BlockingQueue是指这样的一个队列：当生产者向队列添加元素但队列已满时，生产者会被阻塞；当消费者从队列移除元素但队列为空时，消费者会被阻塞。</p>
<p>TransferQueue则更进一步，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费 （不仅仅是添加到队列里就完事）。新添加的transfer方法用来实现这种约束。顾名思义，阻塞就是发生在元素从一个线程transfer到另一个线程的过程中，它有效地实现了元素在线程之间的传递（以建立Java内存模型中的happens-before关系的方式）。 TransferQueue还包括了其他的一些方法：两个tryTransfer方法，一个是非阻塞的，另一个带 有timeout参数设置超时时间的。还有两个辅助方法hasWaitingConsumer()和getWaitingConsumerCount()。 </p>
<ul>
<li><p>实现类 </p>
<p>ArrayBlockingQueue </p>
<p>DelayQueue</p>
<p>LinkedBlockingDeque</p>
<p>LinkedBlockingQueue</p>
<p>LinkedTransferQueue </p>
<p>PriorityBlockingQueue </p>
<p>SynchronousQueue</p>
</li>
</ul>
<h5 id="3-1-2-ArrayBlockingQueue"><a href="#3-1-2-ArrayBlockingQueue" class="headerlink" title="3.1.2 ArrayBlockingQueue"></a>3.1.2 ArrayBlockingQueue</h5><p><strong>ArrayBlockingQueue</strong> 是一个线程安全的、基于数组、有界的、阻塞的、FIFO 队列。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。<br>此类基于 java.util.concurrent.locks.ReentrantLock 来实现线程安全，所以提供了 ReentrantLock 所能支持的公平性选择。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>,<span class="keyword">true</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);</span><br><span class="line">                blockingQueue.put(element++);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-PriorityBlockingQueue"><a href="#3-1-3-PriorityBlockingQueue" class="headerlink" title="3.1.3 PriorityBlockingQueue"></a>3.1.3 PriorityBlockingQueue</h5><p><strong>PriorityBlockingQueue</strong>是带优先级的无界阻塞队列，每次出队都返回优先级高的元素，是二叉树小堆的实现。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 		PriorityBlockingQueue&lt;PriorityElement&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Random random=<span class="keyword">new</span> Random();</span><br><span class="line">            PriorityElement ele = <span class="keyword">new</span> PriorityElement(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            queue.put(ele);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityElement</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">PriorityElement</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;<span class="comment">//定义优先级    </span></span><br><span class="line">    PriorityElement(<span class="keyword">int</span> priority) &#123;</span><br><span class="line">        <span class="comment">//初始化优先级        </span></span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PriorityElement o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照优先级大小进行排序</span></span><br><span class="line">        <span class="keyword">return</span> priority &gt;= o.getPriority() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PriorityElement [priority="</span> + priority + <span class="string">"]"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-DelayQueue"><a href="#3-1-4-DelayQueue" class="headerlink" title="3.1.4 DelayQueue"></a>3.1.4 DelayQueue</h5><p><strong>DelayQueue</strong>队列中每个元素都有个过期时间，并且队列是个优先级队列，当从队列获取元素时候，只有过期元素才会出队列。</p>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueTest</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Item item1 = <span class="keyword">new</span> Item(<span class="string">"item1"</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        Item item2 = <span class="keyword">new</span> Item(<span class="string">"item2"</span>,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        Item item3 = <span class="keyword">new</span> Item(<span class="string">"item3"</span>,<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">        DelayQueue&lt;Item&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        queue.put(item1);</span><br><span class="line">        queue.put(item2);</span><br><span class="line">        queue.put(item3);</span><br><span class="line">        System.out.println(<span class="string">"begin time:"</span> + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Item take = queue.take();</span><br><span class="line">            System.out.format(<span class="string">"name:&#123;%s&#125;, time:&#123;%s&#125;\n"</span>,take.name, LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 触发时间*/</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String name, <span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.time = System.currentTimeMillis() + (time &gt; <span class="number">0</span>? unit.toMillis(time): <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> time - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;  </span><br><span class="line">        Item item = (Item) o;  </span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.time - item.time;  </span><br><span class="line">        <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Item&#123;"</span> + </span><br><span class="line">            <span class="string">"time="</span> + time +  </span><br><span class="line">            <span class="string">", name='"</span> + name + <span class="string">'\''</span> +  </span><br><span class="line">            <span class="string">'&#125;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-1-5-LinkedBlockingQueue"><a href="#3-1-5-LinkedBlockingQueue" class="headerlink" title="3.1.5 LinkedBlockingQueue"></a>3.1.5 LinkedBlockingQueue</h5><p><strong>LinkedBlockingQueue</strong>是一个基于单向链表的、范围任意的（其实是有界的）、FIFO 阻塞队列。访问 与移除操作是在队头进行，添加操作是在队尾进行，并分别使用不同的锁进行保护，只有在可能涉及多 个节点的操作才同时对两个锁进行加锁。</p>
<p>队列是否为空、是否已满仍然是通过元素数量的计数器（count）进行判断的，由于可以同时在队头、 队尾并发地进行访问、添加操作，所以这个计数器必须是线程安全的，这里使用了一个原子类 AtomicInteger ，这就决定了它的容量范围是： 1 – Integer.MAX_VALUE。<br>由于同时使用了两把锁，在需要同时使用两把锁时，加锁顺序与释放顺序是非常重要的：必须以固定的 顺序进行加锁，再以与加锁顺序的相反的顺序释放锁。<br>头结点和尾结点一开始总是指向一个哨兵的结点，它不持有实际数据，当队列中有数据时，头结点仍然 指向这个哨兵，尾结点指向有效数据的后一个结点。这样做的好处在于，与计数器 count 结合后， 对队头、队尾的访问可以独立进行，而不需要判断头结点与尾结点的关系。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);   </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);  </span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();      </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;          </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);                blockingQueue.put(element++);           </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;   </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;      </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;  </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());    </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;     </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);</span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-6-LinkedBlockingDeque"><a href="#3-1-6-LinkedBlockingDeque" class="headerlink" title="3.1.6 LinkedBlockingDeque"></a>3.1.6 LinkedBlockingDeque</h5><p><strong>LinkedBlockingDeque</strong>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两 端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的 竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst， offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移 除双端队列的第一个元素。以Last单词结尾的方法，表示插入，获取或移除双端队列的后一个元素。 另外插入方法add等同于addLast，移除方法remove等效于removeFirst。在初始化 LinkedBlockingDeque时可以初始化队列的容量，用来防止其再扩容时过渡膨胀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue; <span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;Integer&gt;();  </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);  </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);     </span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;     </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;    </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);  </span><br><span class="line">                blockingQueue.put(element++);        </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;      </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);            e.printStackTrace();  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    	System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">try</span> &#123;        </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;    </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());  </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;     </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;       </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-7-SynchronousQueue"><a href="#3-1-7-SynchronousQueue" class="headerlink" title="3.1.7 SynchronousQueue"></a>3.1.7 SynchronousQueue</h5><p><strong>SynchronousQueue</strong>是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待 消费者的移除操作take，反过来也一样。<br>SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因 为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列 的操作也是不允许的。<br>数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲到队列中。<br>SynchronousQueue支持公平访问队列，默认情况下，线程采用非公平策略，如果使用公平策略，等待 的线程采用先进先出的顺序访问队列。<br>SynchronousQueue适合传递性场景，一个使用场景是在线程池里。 Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到 来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();   </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);      </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();     </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);   </span><br><span class="line">                blockingQueue.put(element++);    </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;      </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);       </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;          </span><br><span class="line">                Thread.sleep(<span class="number">1000l</span>);   </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+blockingQueue.take());      </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>); </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-8-LinkedTransferQueue"><a href="#3-1-8-LinkedTransferQueue" class="headerlink" title="3.1.8 LinkedTransferQueue"></a>3.1.8 LinkedTransferQueue</h5><p><strong>LinkedTransferQueue</strong>是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列 LinkedTransferQueue多了tryTransfer和transfer方法。<br>transfer方法。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll() 方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者 在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返 回。transfer方法的关键代码如下：<br>第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元 素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线 程，并执行其他线程。<br>tryTransfer方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接 收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返 回。而transfer方法是必须等到消费者消费了才返回。<br>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者 传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没 消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedTransferQueueTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedTransferQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedTransferQueue&lt;Integer&gt;(); </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue); </span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> element = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.linkedTransferQueue = linkedTransferQueue;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="keyword">while</span>(element &lt; <span class="number">20</span>) &#123;     </span><br><span class="line">                System.out.println(<span class="string">"生产元素："</span>+element);      </span><br><span class="line">                linkedTransferQueue.put(element++);     </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;       </span><br><span class="line">            System.out.println(<span class="string">"生产者在等待空闲空间的时候发生异常！"</span>);  </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;    </span><br><span class="line">        System.out.println(<span class="string">"生产者终止了生产过程！"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(LinkedTransferQueue&lt;Integer&gt; linkedTransferQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.linkedTransferQueue = linkedTransferQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;      </span><br><span class="line">                Thread.sleep(<span class="number">1000l</span>);   </span><br><span class="line">                System.out.println(<span class="string">"消费元素："</span>+linkedTransferQueue.take());       </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;        </span><br><span class="line">            System.out.println(<span class="string">"消费者在等待新产品的时候发生异常！"</span>);    </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(<span class="string">"消费者终止了消费过程！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-9-ConcurrentHashMap"><a href="#3-1-9-ConcurrentHashMap" class="headerlink" title="3.1.9 ConcurrentHashMap"></a>3.1.9 ConcurrentHashMap</h5><h6 id="HashMap容量"><a href="#HashMap容量" class="headerlink" title="HashMap容量"></a>HashMap容量</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial </span></span><br><span class="line"><span class="comment">* capacity and load factor. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  initialCapacity the initial capacity </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  loadFactor      the load factor </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative </span></span><br><span class="line"><span class="comment">*         or the load factor is nonpositive </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +      </span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">     initialCapacity = MAXIMUM_CAPACITY;   </span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +                                           loadFactor);  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等 操作，所以非常消耗性能。<br>因此通常建议能提前预估 HashMap 的大小好，尽量的减少扩容带来的性能损耗。<br>线程不安全的 HashMap<br>因为多线程环境下，使用 HashMap 进行 put 操作会引起死循环，导致 CPU 利用率接近 100%，所以 在并发情况下不能使用 HashMap，如以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;      </span><br><span class="line">                <span class="meta">@Override</span>              </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">                    map.put(UUID.randomUUID().toString(), <span class="string">""</span>);     </span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;, <span class="string">"kaikeba"</span> + i).start();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"kaikeba"</span>);</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>

<h6 id="效率低下的-HashTable-容器"><a href="#效率低下的-HashTable-容器" class="headerlink" title="效率低下的 HashTable 容器"></a>效率低下的 HashTable 容器</h6><p>HashTable 容器使用 syncronized来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率 非常低下。因为当一个线程访问 HashTable 的同步方法时，其他线程访问 HashTable 的同步方法 时，可能会进入阻塞或轮询状态。如线程 1 使用 put 进行添加元素，线程 2 不但不能使用 put 方 法添加元素，并且也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();  </span><br><span class="line">        map.put(<span class="string">"key1"</span>, <span class="string">"1"</span>); </span><br><span class="line">        map.put(<span class="string">"key2"</span>, <span class="string">"2"</span>);  </span><br><span class="line">        map.put(<span class="string">"key3"</span>, <span class="string">"3"</span>);    </span><br><span class="line">        map.put(<span class="string">"key4"</span>, <span class="string">"4"</span>);    </span><br><span class="line">        Iterator&lt;String&gt; it = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">            String key = it.next();    </span><br><span class="line">            System.out.println(key + <span class="string">","</span>+ map.get(key));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-10-ConcurrentSkipListMap"><a href="#3-1-10-ConcurrentSkipListMap" class="headerlink" title="3.1.10 ConcurrentSkipListMap"></a>3.1.10 ConcurrentSkipListMap</h5><p>JDK1.6时，为了对高并发环境下的有序Map提供更好的支持，J.U.C新增了一个 ConcurrentNavigableMap接口，ConcurrentNavigableMap很简单，它同时实现了NavigableMap和 ConcurrentMap接口。<br>ConcurrentNavigableMap接口提供的功能也和NavigableMap几乎完全一致，很多方法仅仅是返回的 类型不同。<br>NavigableMap接口，进一步扩展了SortedMap的功能，提供了根据指定Key返回接近项、按升序/降 序返回所有键的视图等功能。<br>J.U.C提供了基于ConcurrentNavigableMap接口的一个实现—— ConcurrentSkipListMap 。 ConcurrentSkipListMap可以看成是并发版本的TreeMap，但是和TreeMap不同是， ConcurrentSkipListMap并不是基于红黑树实现的，其底层是一种类似跳表（Skip List）的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentNavigableMap; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">        ConcurrentSkipListMap&lt;String, Contact&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">        Thread threads[]=<span class="keyword">new</span> Thread[<span class="number">25</span>];    </span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;     </span><br><span class="line">        <span class="comment">//创建和启动25个任务，对于每个任务指定一个大写字母作为ID    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i=<span class="string">'A'</span>; i&lt;<span class="string">'Z'</span>; i++) &#123;   </span><br><span class="line">            Task0 task=<span class="keyword">new</span> Task0(map, String.valueOf(i));     </span><br><span class="line">            threads[counter]=<span class="keyword">new</span> Thread(task);    </span><br><span class="line">            threads[counter].start();   </span><br><span class="line">            counter++;      </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="comment">//使用join()方法等待线程的结束    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">25</span>; i++) &#123;</span><br><span class="line"> 			<span class="keyword">try</span> &#123;               </span><br><span class="line">                threads[i].join();          </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;          </span><br><span class="line">                e.printStackTrace();          </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;          </span><br><span class="line">        System.out.printf(<span class="string">"Size of the map: %d\n"</span>,map.size());   </span><br><span class="line">        Map.Entry&lt;String, Contact&gt; element;           </span><br><span class="line">        Contact contact;      </span><br><span class="line">        <span class="comment">// 使用firstEntry()方法获取map的第一个实体，并输出。 </span></span><br><span class="line">        element=map.firstEntry();     </span><br><span class="line">        contact=element.getValue();        </span><br><span class="line">        System.out.printf(<span class="string">"First Entry: %s: %s\n"</span>,contact.  </span><br><span class="line">                          getName(),contact.getPhone());   </span><br><span class="line">        <span class="comment">//使用lastEntry()方法获取map的最后一个实体，并输出。   </span></span><br><span class="line">        element=map.lastEntry();         </span><br><span class="line">        contact=element.getValue();     </span><br><span class="line">        System.out.printf(<span class="string">"Last Entry: %s: %s\n"</span>,contact.                    getName(),contact.getPhone());        </span><br><span class="line">        <span class="comment">//使用subMap()方法获取map的子map，并输出。</span></span><br><span class="line">        System.out.printf(<span class="string">"Submap from A1996 to B1002: \n"</span>);</span><br><span class="line">        ConcurrentNavigableMap&lt;String, Contact&gt; submap=map.</span><br><span class="line">            subMap(<span class="string">"A1996"</span>, <span class="string">"B1001"</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;     </span><br><span class="line">              </span><br><span class="line">            element=submap.pollFirstEntry();  </span><br><span class="line">            <span class="keyword">if</span> (element!=<span class="keyword">null</span>) &#123;     </span><br><span class="line">                contact=element.getValue();      </span><br><span class="line">                System.out.printf(<span class="string">"%s: %s\n"</span>,contact.getName(),contact.                            getPhone());            </span><br><span class="line">            &#125;         </span><br><span class="line">        &#125; <span class="keyword">while</span> (element!=<span class="keyword">null</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contact</span><span class="params">(String name, String phone)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name;      </span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> phone;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task0</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentSkipListMap&lt;String, Contact&gt; map; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task0</span><span class="params">(ConcurrentSkipListMap&lt;String, Contact&gt; map, String id)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;   </span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;   </span><br><span class="line">            Contact contact = <span class="keyword">new</span> Contact(id, String.valueOf(i + <span class="number">1000</span>));  </span><br><span class="line">            map.put(id + contact.getPhone(), contact);   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-11-ConcurrentSkipListSet"><a href="#3-1-11-ConcurrentSkipListSet" class="headerlink" title="3.1.11 ConcurrentSkipListSet"></a>3.1.11 ConcurrentSkipListSet</h5><p><strong>ConcurrentSkipListSet</strong>，是JDK1.6时J.U.C新增的一个集合工具类，它是一种有序的SET类型。<br>ConcurrentSkipListSet实现了NavigableSet接口，ConcurrentSkipListMap实现了NavigableMap 接口，以提供和排序相关的功能，维持元素的有序性，所以ConcurrentSkipListSet就是一种为并发 环境设计的有序SET工具类。<br>ConcurrentSkipListSet底层实现引用了ConcurrentSkipListMap。<br>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSetTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ConcurrentSkipListSet&lt;Contact1&gt; set = <span class="keyword">new</span> ConcurrentSkipListSet&lt;&gt; ();     </span><br><span class="line">        Thread threads[]=<span class="keyword">new</span> Thread[<span class="number">25</span>];     </span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;     </span><br><span class="line">        <span class="comment">//创建和启动25个任务，对于每个任务指定一个大写字母作为ID     </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i=<span class="string">'A'</span>; i&lt;<span class="string">'Z'</span>; i++) &#123;       </span><br><span class="line">            Task1 task=<span class="keyword">new</span> Task1(set, String.valueOf(i));   </span><br><span class="line">            threads[counter]=<span class="keyword">new</span> Thread(task);    </span><br><span class="line">            threads[counter].start();       </span><br><span class="line">            counter++;   </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用join()方法等待线程的结束    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">25</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                threads[i].join();       </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;      </span><br><span class="line">                e.printStackTrace();           </span><br><span class="line">            &#125;    </span><br><span class="line"> 		&#125;       </span><br><span class="line">        System.out.printf(<span class="string">"Size of the set: %d\n"</span>,set.size());  </span><br><span class="line">        Contact1 contact;     </span><br><span class="line">        <span class="comment">// 使用first方法获取set的第一个实体，并输出。  </span></span><br><span class="line">        contact=set.first();    </span><br><span class="line">        System.out.printf(<span class="string">"First Entry: %s: %s\n"</span>,contact.                getName(),contact.getPhone()); </span><br><span class="line">        <span class="comment">//使用last方法获取set的最后一个实体，并输出。      </span></span><br><span class="line">        contact=set.last();        </span><br><span class="line">        System.out.printf(<span class="string">"Last Entry: %s: %s\n"</span>,contact.                getName(),contact.getPhone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact1</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Contact1</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contact1</span><span class="params">(String name, String phone)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> phone; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Contact1 o)</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> name.compareTo(o.name);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentSkipListSet&lt;Contact1&gt; set;    </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task1</span><span class="params">(ConcurrentSkipListSet&lt;Contact1&gt; set, String id)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;     </span><br><span class="line">        <span class="keyword">this</span>.set = set;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;        </span><br><span class="line">            Contact1 contact = <span class="keyword">new</span> Contact1(id, String.valueOf(i + <span class="number">100</span>));            set.add(contact);      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-12-CopyOnWriteArrayList"><a href="#3-1-12-CopyOnWriteArrayList" class="headerlink" title="3.1.12 CopyOnWriteArrayList"></a>3.1.12 CopyOnWriteArrayList</h5><p><strong>Copy-On-Write</strong>简称COW，是一种用于程序设计中的优化策略。</p>
<p>其基本思路是，从一开始大家都在共享 同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并 发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<p> <strong>什么是CopyOnWrite容器</strong></p>
<p> CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前 容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素 之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读， 而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读 和写不同的容器。 </p>
<p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在 开发的时候需要注意一下内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个 对象的内存，旧的对象和新写入的对象（<code>注意:在复制的时候只是复制容器里的引用，只是在写的时候 会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存</code>）。如果这些对象占用 的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有 可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制 更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p> 针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是 10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。 数据一致性问题。CopyOnWrite容器只能保证数据的终一致性，不能保证数据的实时一致性。所以如 果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list = list;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.print(<span class="string">"size:="</span>+list.size()+<span class="string">",::"</span>);  </span><br><span class="line">        <span class="keyword">for</span> (Integer ele : list) &#123;</span><br><span class="line">            System.out.print(ele + <span class="string">","</span>);   </span><br><span class="line">        &#125;       </span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriteThread</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list = list; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.list.add(<span class="number">9</span>);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//1、初始化CopyOnWriteArrayList   </span></span><br><span class="line">        List&lt;Integer&gt; tempList = Arrays.asList(<span class="keyword">new</span> Integer [] &#123;<span class="number">1</span>,<span class="number">2</span>&#125;); </span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; copyList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt; (tempList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、模拟多线程对list进行读和写    </span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));     </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList)); </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));  </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));   </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));    </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));    </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ReadThread(copyList));  </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> WriteThread(copyList));  </span><br><span class="line">        <span class="keyword">try</span> &#123;           </span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(<span class="string">"copyList size:"</span>+copyList.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> TestCopyOnWriteArrayList().test();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-13-CopyOnWriteArraySet"><a href="#3-1-13-CopyOnWriteArraySet" class="headerlink" title="3.1.13 CopyOnWriteArraySet"></a>3.1.13 CopyOnWriteArraySet</h5><p>CopyOnWriteArraySet相对CopyOnWriteArrayList用来存储不重复的对象，是线程安全的。虽然继承了AbstractSet类，但CopyOnWriteArraySet与HashMap 完全不同，内部是用 CopyOnWriteArrayList实现的，实现不重复的特性也是直接调用CopyOnWriteArrayList的方法实现 的，感觉加的有用的函数就是eq函数判断对象是否相同</p>
<h4 id="3-2-原子操作类"><a href="#3-2-原子操作类" class="headerlink" title="3.2 原子操作类"></a>3.2 原子操作类</h4><p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程 执行i++操作，就有可能获取不到正确的值，而这个问题，常用的方法是通过Synchronized进行控制 来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去 更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的 是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p>
<h5 id="3-2-1-原子基本数据类型"><a href="#3-2-1-原子基本数据类型" class="headerlink" title="3.2.1 原子基本数据类型"></a>3.2.1 原子基本数据类型</h5><p>原子更新基本类型<br>atomic包提高原子更新基本类型的工具类，主要有这些：</p>
<ul>
<li>AtomicBoolean：以原子更新的方式更新boolean；</li>
<li>AtomicInteger：以原子更新的方式更新Integer; </li>
<li>AtomicLong：以原子更新的方式更新Long；</li>
<li>AtomicInteger常用的方法:</li>
<li>addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回后的结 果； </li>
<li>incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回终相加后的结果； </li>
<li>getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值； </li>
<li>getAndIncrement()：以原子的方式将实例中的原值加1，返回的是自增前的旧值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，该方法实际上是调用了unsafe实例的getAndAddInt方法，unsafe实例的获取时通过 UnSafe类的静态方法getUnsafe获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure>

<p>Unsafe类在sun.misc包下，Unsafer类提供了一些底层操作，atomic包下的原子操作类的也主要是通 过Unsafe类提供的compareAndSwapInt，compareAndSwapLong等一系列提供CAS操作的方法来进行实现。</p>
<p>atomicInteger借助了UnSafe提供的CAS操作能够保证数据更新的时候是线程安全的，并且由于CAS是 采用乐观锁策略，因此，这种数据更新的方法也具有高效性。</p>
<p>AtomicLong的实现原理和AtomicInteger一致，只不过一个针对的是long变量，一个针对的是int变 量。而boolean变量的更新类AtomicBoolean类是怎样实现更新的呢?核心方法是 compareAndSet t方 法，</p>
<p>其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，compareAndSet方法的实际上也是先转换成0,1的整型变量，然后是通过针对int型变量的 原子更新方法compareAndSwapInt来实现的。可以看出atomic包中只提供了对boolean,int ,long这 三种基本类型的原子更新的方法，参考对boolean更新的方式，原子更新char,double,float也可以采 用类似的思路进行实现。<br>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;      </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Accumlator(ai), <span class="string">"thread-"</span> + i);     </span><br><span class="line">            list.add(t);       </span><br><span class="line">            t.start();    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;    </span><br><span class="line">            t.join();     </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ai.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumlator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> AtomicInteger ai;</span><br><span class="line">        Accumlator(AtomicInteger ai) &#123;      </span><br><span class="line">            <span class="keyword">this</span>.ai = ai;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="number">1000</span>; i &lt; len; i++) &#123;   </span><br><span class="line">                ai.incrementAndGet();      </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-原子数组"><a href="#3-2-2-原子数组" class="headerlink" title="3.2.2 原子数组"></a>3.2.2 原子数组</h5><p>atomic包下提供能原子更新数组中元素的类有：</p>
<ul>
<li>AtomicIntegerArray：原子更新整型数组中的元素；</li>
<li>AtomicLongArray：原子更新长整型数组中的元素； </li>
<li>AtomicReferenceArray：原子更新引用类型数组中的元素</li>
</ul>
<p>这几个类的用法一致，就以AtomicIntegerArray来总结下常用的方法：</p>
<ul>
<li>addAndGet(int i, int delta)：以原子更新的方式将数组中索引为i的元素与输入值相加；</li>
<li>getAndIncrement(int i)：以原子更新的方式将数组中索引为i的元素自增加1； </li>
<li>compareAndSet(int i, int expect, int update)：将数组中索引为i的位置的元素进行更新</li>
</ul>
<p>可以看出，AtomicIntegerArray与AtomicInteger的方法基本一致，只不过在AtomicIntegerArray 的方法中会多一个指定数组索引位i。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//创建给定长度的AtomicIntegerArray。  </span></span><br><span class="line">        AtomicIntegerArray atomicIntegerArray = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>);   </span><br><span class="line">        <span class="comment">//将位置 i 的元素设置为给定值,默认值为0     </span></span><br><span class="line">        atomicIntegerArray.set(<span class="number">9</span>,<span class="number">10</span>);   </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> + atomicIntegerArray.get(<span class="number">9</span>) + <span class="string">"默认值："</span> + atomicIntegerArray.get(<span class="number">0</span>));      </span><br><span class="line">        <span class="comment">//返回该数组的长度     </span></span><br><span class="line">        System.out.println(<span class="string">"数组长度："</span> + atomicIntegerArray.length());  </span><br><span class="line">        <span class="comment">//以原子方式先对给定下标加上特定的值，再获取相加后的值      </span></span><br><span class="line">        atomicIntegerArray.set(<span class="number">0</span>,<span class="number">10</span>);    </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> + atomicIntegerArray.get(<span class="number">0</span>));  </span><br><span class="line">        System.out.println(<span class="string">"Value: "</span> +  atomicIntegerArray.addAndGet(<span class="number">5</span>,<span class="number">10</span>));  </span><br><span class="line">        <span class="comment">//如果当前值 == 预期值，将位置 i 的元素设置为给定的更新值。    </span></span><br><span class="line">        Boolean bool = atomicIntegerArray.compareAndSet(<span class="number">5</span>,<span class="number">10</span>,<span class="number">30</span>);    </span><br><span class="line">        System.out.println(<span class="string">"结果值： "</span> + atomicIntegerArray.get(<span class="number">5</span>) + <span class="string">" Result: "</span> + bool);</span><br><span class="line">        <span class="comment">//以原子方式先将当前下标的值减1，再获取减1后的结果    </span></span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> +  atomicIntegerArray.decrementAndGet(<span class="number">5</span>)); </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + atomicIntegerArray.get(<span class="number">5</span>));     </span><br><span class="line">        <span class="comment">//以原子方式先获取当前下标的值，再将当前下标的值加上给定的值    </span></span><br><span class="line">        Integer result2 = atomicIntegerArray.getAndAdd(<span class="number">5</span>,<span class="number">5</span>);    </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + result2);   </span><br><span class="line">        System.out.println(<span class="string">"下标为5的值为："</span> + atomicIntegerArray.get(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//以原子方式先获取当前下标的值，再对当前下标的值减1   </span></span><br><span class="line">        System.out.println(<span class="string">"下标为1的值为："</span> + atomicIntegerArray.getAndDecrement(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"下标为1的值为："</span> + atomicIntegerArray.get(<span class="number">1</span>));    </span><br><span class="line">        <span class="comment">// 以原子方式先获取当前下标的值，再对当前下标的值加1   </span></span><br><span class="line">        System.out.println(<span class="string">"下标为2的值为："</span> + atomicIntegerArray.getAndIncrement(<span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">"下标为2的值为："</span> + atomicIntegerArray.get(<span class="number">2</span>));     </span><br><span class="line">        <span class="comment">//将位置 i 的元素以原子方式设置为给定值，并返回旧值。</span></span><br><span class="line">        System.out.println(<span class="string">"下标为3的值为："</span> + atomicIntegerArray.getAndSet(<span class="number">3</span>,<span class="number">50</span>));  </span><br><span class="line">        System.out.println(<span class="string">"下标为3的值为："</span> + atomicIntegerArray.get(<span class="number">3</span>));  </span><br><span class="line">        <span class="comment">//以原子方式先对下标加1再获取值     </span></span><br><span class="line">        System.out.println(<span class="string">"下标为4的值为："</span> + atomicIntegerArray.incrementAndGet(<span class="number">4</span>));  </span><br><span class="line">        System.out.println(<span class="string">"下标为4的值为："</span> + atomicIntegerArray.get(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerArray arr = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++)     </span><br><span class="line">                arr.getAndIncrement(k % arr.length()); </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">        Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;        </span><br><span class="line">            ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread()); </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;    </span><br><span class="line">            ts[k].start();      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;       </span><br><span class="line">            ts[k].join();     </span><br><span class="line">        &#125;     </span><br><span class="line">        System.out.println(arr);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-原子引用类型"><a href="#3-2-3-原子引用类型" class="headerlink" title="3.2.3 原子引用类型"></a>3.2.3 原子引用类型</h5><p>如果需要原子更新引用类型变量的话，为了保证线程安全，atomic也提供了相关的类：</p>
<ul>
<li><p>AtomicReference </p>
</li>
<li><p>AtomicStampedReference </p>
</li>
<li><p>AtomicMarkableReference</p>
</li>
</ul>
<p>AtomicReference的引入是为了可以用一种类似乐观锁的方式操作共享资源，在某些情景下以提升性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;       </span><br><span class="line">        AtomicReference&lt;Integer&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> Integer(<span class="number">1000</span>));</span><br><span class="line">        </span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;      </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(ref), <span class="string">"Thread-"</span> + i);     </span><br><span class="line">            list.add(t);        </span><br><span class="line">            t.start();</span><br><span class="line">            </span><br><span class="line"> &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;   </span><br><span class="line">            t.join();     </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ref.get());   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Integer&gt; ref;</span><br><span class="line">    Task(AtomicReference&lt;Integer&gt; ref) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.ref = ref; </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;  </span><br><span class="line">            <span class="comment">//自旋操作       </span></span><br><span class="line">            Integer oldV = ref.get();   </span><br><span class="line">            <span class="keyword">if</span> (ref.compareAndSet(oldV, oldV + <span class="number">1</span>)) </span><br><span class="line">                <span class="comment">// CAS操作            </span></span><br><span class="line">                <span class="keyword">break</span>;      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该案例并没有使用锁，是使用自旋+CAS的无锁操作保证共享变量的线程安全。<br>CAS操作可能存在ABA的问题： 假如一个值原来是A，变成了B，又变成了A，那么CAS检查时会发现它的值没有发生变化，但是实际上却 变化了。<br>一般来讲这并不是什么问题，比如数值运算，线程其实根本不关心变量中途如何变化，只要终的状态 和预期值一样即可。<br>但是，有些操作会依赖于对象的变化过程，此时的解决思路一般就是使用版本号。在变量前面追加上版 本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A - 2B - 3A。<br>AtomicStampedReference就是上面所说的加了版本号的AtomicReference。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> T reference;     </span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> stamp;    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;   </span><br><span class="line">         <span class="keyword">this</span>.reference = reference;   </span><br><span class="line">         <span class="keyword">this</span>.stamp = stamp;    </span><br><span class="line">     &#125;      </span><br><span class="line">     <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;     </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);     </span><br><span class="line">     &#125;   </span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AtomicStampedReference&#125; with the given</span></span><br><span class="line"><span class="comment">	 * initial values.     </span></span><br><span class="line"><span class="comment">	 *     </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> initialRef the initial reference     </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> initialStamp the initial stamp     </span></span><br><span class="line"><span class="comment">	 */</span>    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;   </span><br><span class="line">    	pair = Pair.of(initialRef, initialStamp);   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决ABA问题，引入了AtomicStampedReference。</p>
<p>AtomicStampedReference可以给引用加上版本号，追踪引用的整个变化过程，如： A -&gt; B -&gt; C -&gt; D - &gt; A，通过AtomicStampedReference，可以知道，引用变量中途被更改了3 次。</p>
<p>但是，有时候，我们并不关心引用变量更改了几次，只关心是否更改过，就有了 AtomicMarkableReference：<br>    AtomicMarkableReference和AtomicStampedReference的唯一区别就是不再用int标识引用，而是使 用boolean变量——表示引用变量是否被更改过。<br>    AtomicMarkableReference对于那些不关心引用变化过程，只关心引用变量是否变化过的应用会更加友好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMarkableReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">        <span class="keyword">final</span> T reference;     </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> mark;    </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">this</span>.reference = reference;    </span><br><span class="line">            <span class="keyword">this</span>.mark = mark;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, mark);       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">      * Creates a new &#123;<span class="doctag">@code</span> AtomicMarkableReference&#125; with the given   </span></span><br><span class="line"><span class="comment">      * initial values.   </span></span><br><span class="line"><span class="comment">      *    </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> initialRef the initial reference     </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> initialMark the initial mark </span></span><br><span class="line"><span class="comment">      */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicMarkableReference</span><span class="params">(V initialRef, <span class="keyword">boolean</span> initialMark)</span> </span>&#123; </span><br><span class="line">        pair = Pair.of(initialRef, initialMark);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-4-原子更新字段类型"><a href="#3-2-4-原子更新字段类型" class="headerlink" title="3.2.4 原子更新字段类型"></a>3.2.4 原子更新字段类型</h5><p>如果需要更新对象的某个字段，并在多线程的情况下，能够保证线程安全，atomic同样也提供了相应的 原子操作类：</p>
<ul>
<li>AtomicIntegeFieldUpdater：原子更新整型字段类； </li>
<li>AtomicLongFieldUpdater：原子更新长整型字段类；</li>
<li>AtomicReferenceFieldUpdater：</li>
</ul>
<p>原子更新引用字段类型；</p>
<p>要想使用原子更新字段需要两步操作：</p>
<ul>
<li>原子更新字段类都是抽象类，只能通过静态方法 newUpdater 来创建一个更新器，并且需要设置想 要更新的类和属性； </li>
<li>更新类的属性必须使用 public volatile 进行修饰；</li>
<li>字段必须是volatile类型的，在线程之间共享变量时保证立即可见 </li>
<li>字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的 关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。</li>
<li>对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</li>
<li>只能是实例变量，不能是类变量，也就是说不能加static关键字。 </li>
<li>只能是可修改变量，不能使final变量，因为final的语义就是不可修改。 </li>
<li>对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字 段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用 AtomicReferenceFieldUpdater。</li>
</ul>
<p>这几个类提供的方法基本一致，以AtomicIntegerFieldUpdater为例来看看具体的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = </span><br><span class="line">        AtomicIntegerFieldUpdater.newUpdater(User.class, "age");</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);       </span><br><span class="line">        System.out.println(a.getAndIncrement(user));  </span><br><span class="line">        System.out.println(a.get(user));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">private</span> String name;      </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;      </span><br><span class="line">            <span class="keyword">this</span>.name = name;    </span><br><span class="line">            <span class="keyword">this</span>.age = age;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">return</span> name;     </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">return</span> age;        </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从示例中可以看出，创建 AtomicIntegerFieldUpdater 是通过它提供的静态方法进行创建， getAndAdd 方法会将指定的字段加上输入的值，并且返回相加之前的值。user对象中age字段原值为 1，加5之后，可以看出user对象中的age字段的值已经变成了6。</p>
<h4 id="3-3-锁：Lock"><a href="#3-3-锁：Lock" class="headerlink" title="3.3 锁：Lock"></a>3.3 锁：Lock</h4><p>java.util.concurrent.locks 包，该包提供了一系列基础的锁工具，用以对synchronizd、wait、 notify等进行补充、增强。 juc-locks锁框架中一共就三个接口：Lock、Condition、ReadWriteLock。</p>
<h5 id="3-3-1-ReentrantLock"><a href="#3-3-1-ReentrantLock" class="headerlink" title="3.3.1 ReentrantLock"></a>3.3.1 ReentrantLock</h5><p>ReentrantLock叫做可重入锁，指的是线程可以重复获取同一把锁，或者说该锁支持一个线程对资源的 重复加锁。同时该锁还支持获取锁的公平性和非公平性选择，锁的公平性是指，在绝对时间上，先对锁 获取的请求一定先被满足，也就是等待时间长的那个线程优先获得，可以说，锁的获取是顺序的，即 符合FIFO规则。<br>ReentrantLock也是互斥锁，因此也可以保证原子性。<br>ReentrantLock 重入锁的基本原理是判断上次获取锁的线程是否为当前线程，如果是则可再次进入临 界区，如果不是，则阻塞。<br>由于ReentrantLock是基于AQS实现的，底层通过操作同步状态来获取锁.，下面看一下非公平锁的实 现逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//获取当前线程         </span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();        </span><br><span class="line">    <span class="comment">//通过AQS获取同步状态       </span></span><br><span class="line">    <span class="keyword">int</span> c = getState();            </span><br><span class="line">    <span class="comment">//同步状态为0，说明临界区处于无锁状态，            </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;            </span><br><span class="line">        <span class="comment">//修改同步状态，即加锁          </span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;        </span><br><span class="line">            <span class="comment">//将当前线程设置为锁的owner     </span></span><br><span class="line">            setExclusiveOwnerThread(current);    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="comment">//如果临界区处于锁定状态，且上次获取锁的线程为当前线程  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;   </span><br><span class="line">        <span class="comment">//则递增同步状态       </span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;     </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow      </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);   </span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;       </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功获取锁的线程再次获取锁，只是增加了同步状态值，在释放同步转态时，相应的减少同步状态值， 实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;       </span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;   </span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())       </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;         </span><br><span class="line">    <span class="comment">//在同步状态完全释放了，设置true    </span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;              </span><br><span class="line">        free = <span class="keyword">true</span>;       </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);     </span><br><span class="line">    &#125;           </span><br><span class="line">    setState(c);    </span><br><span class="line">    <span class="keyword">return</span> free;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁和非公平锁的测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections; </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLockMine(<span class="keyword">true</span>); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLockMine(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    </span><br><span class="line">        testLock(<span class="string">"unfair lock"</span>, unfairLock);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        testLock(<span class="string">"fair lock"</span>, fairLock);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(String type, Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </span><br><span class="line">        System.out.println(type);    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;      </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(lock))&#123;     </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">                    <span class="keyword">return</span> getName();</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;;       </span><br><span class="line">            thread.setName(<span class="string">""</span> + i);    </span><br><span class="line">            thread.start();      </span><br><span class="line">        &#125;     </span><br><span class="line">        Thread.sleep(<span class="number">11000</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    </span><br><span class="line">        <span class="keyword">private</span> Lock lock;     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123;      </span><br><span class="line">            <span class="keyword">this</span>.lock = lock;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;      </span><br><span class="line">                lock.lock();           </span><br><span class="line">                <span class="keyword">try</span> &#123;            </span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">                    System.out.println(<span class="string">"获取锁的当前线程["</span> + Thread.currentThread().getName() + <span class="string">"], 同步队列中的线程"</span> + ((ReentrantLockMine)lock).getQueuedThreads() + <span class="string">""</span>);      </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </span><br><span class="line">                    e.printStackTrace();        </span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;                </span><br><span class="line">                    lock.unlock();       </span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockMine</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//重新实 现ReentrantLock类是为了重写getQueuedThreads方法，便于我们试验的观察</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLockMine</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">super</span>(fair);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>   </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="comment">//获取同步队列中的 线程          </span></span><br><span class="line">            List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt; (<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);     </span><br><span class="line">            <span class="keyword">return</span> arrayList;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁的获取，只要获取了同步状态就可以获取锁，有可能导致饥饿现象，但是非公平锁，线程的切 换比较少，更高效。<br>ReentrantLock与synchronized的区别</p>
<ul>
<li><p>重入 </p>
<p>synchronized可重入，因为加锁和解锁自动进行，不必担心后是否释放锁；ReentrantLock也 可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。</p>
</li>
<li><p>实现</p>
<p>synchronized是JVM实现的、而ReentrantLock是JDK实现的。说白了就是，是操作系统来实现， 还是用户自己敲代码实现。 </p>
</li>
<li><p>性能 </p>
<p>在 Java 的 1.5 版本中，synchronized 性能不如 SDK 里面的 Lock，但 1.6 版本之后， synchronized 做了很多优化，将性能追了上来。</p>
</li>
<li><p>功能 </p>
<p>ReentrantLock锁的细粒度和灵活度，优于synchronized。 ReentrantLock不同点一：可在构造函数中指定是公平锁还是非公平锁，而synchronized只能是非公平锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>ReentrantLock不同点二：可以避免死锁问题，因为它可以非阻塞地获取锁。如果尝试获取 锁失败，并不进入阻塞状态，而是直接返回false，这时候线程不用阻塞等待，可以先去做其他事情。 所以不会造成死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持非阻塞获取锁的 API </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>tryLock还支持超时。调用tryLock时没有获取到锁，会等待一段时间，如果线程在一段时间之内还是 没有获取到锁，不是进入阻塞状态，而是throws InterruptedException，那这个线程也有机会释放 曾经持有的锁，这样也能破坏死锁不可抢占条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>

<p>ReentrantLock不同点三：提供能够中断等待锁机制。</p>
<p>synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦 发生死锁，就没有任何机会来唤醒阻塞的线程。</p>
<p>但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤 醒它，那它就有机会释放曾经持有的锁 A。ReentrantLock可以用lockInterruptibly方法来实现。</p>
<p>ReentrantLock不同点四：可以用J.U.C包中的Condition实现分组唤醒需要等待的线程。而 synchronized只能notify或者notifyAll。</p>
<h5 id="3-3-2-LockSupport"><a href="#3-3-2-LockSupport" class="headerlink" title="3.3.2 LockSupport"></a>3.3.2 LockSupport</h5><p>LockSupport类，是JUC包中的一个工具类，定义了一组静态方法，提供基本的线程阻塞和唤醒功 能，是构建同步组件的基础工具，用来创建锁和其他同步类的基本线程阻塞原语。<br>LockSupport类的核心方法其实就两个：park() 和 unpark()，其中 park() 方法用来阻塞线程， unpark()方法用于唤醒指定线程。<br>和Object类的wait() 和 signal() 方法有些类似，但是LockSupport的这两种方法从语意上讲比 Object类的方法更清晰，而且可以针对指定线程进行阻塞和唤醒。<br>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，可以把许可看 成是一种（0，1）信号量（Semaphore），但与Semaphore不同的是，许可的量加上限1。<br>初始时，permit为0，当调用 unpark() 方法时，线程的permit加1，当调用 park()方法时，如果 permit为0，则调用线程进入阻塞状态。</p>
<p>假设现在需要实现一种FIFO类型的独占锁，可以把这种锁看成是ReentrantLock的公平锁简单版本， 且是不可重入的，就是说当一个线程获得锁后，其他等待线程以FIFO的调度方式等待获取锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">FIFOMutex</span>  </span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean locked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Thread&gt; waiters = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        Thread current = Thread.currentThread();       </span><br><span class="line">        waiters.add(current);       </span><br><span class="line">        <span class="comment">// 如果当前线程不在队首，或锁已被占用，则当前线程阻塞 </span></span><br><span class="line">        <span class="comment">// 这个判断的内在意图：锁必须由队首元素拿到    </span></span><br><span class="line">        <span class="keyword">while</span> (waiters.peek() != current || !locked.compareAndSet(<span class="keyword">false</span>,<span class="keyword">true</span>))&#123;  </span><br><span class="line">            LockSupport.park();      </span><br><span class="line">        &#125;       </span><br><span class="line">        waiters.remove();</span><br><span class="line">        <span class="comment">// 删除队首元素  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123; </span><br><span class="line">        locked.set(<span class="keyword">false</span>);    </span><br><span class="line">        LockSupport.unpark(waiters.peek());  </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFIFOMutex</span> </span>&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">         FIFOMutex mutex = <span class="keyword">new</span> FIFOMutex(); </span><br><span class="line">         MyThread a1 = <span class="keyword">new</span> MyThread(<span class="string">"a"</span>, mutex);   </span><br><span class="line">         MyThread a2 = <span class="keyword">new</span> MyThread(<span class="string">"b"</span>, mutex);   </span><br><span class="line">         MyThread a3 = <span class="keyword">new</span> MyThread(<span class="string">"c"</span>, mutex);  </span><br><span class="line">         a1.start();     </span><br><span class="line">         a2.start();     </span><br><span class="line">         a3.start();     </span><br><span class="line">         a1.join();        </span><br><span class="line">         a2.join();  </span><br><span class="line">         a3.join();     </span><br><span class="line">         System.out.println(<span class="string">"Finished"</span>);  </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> FIFOMutex mutex;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, FIFOMutex mutex)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;    </span><br><span class="line">            mutex.lock();      </span><br><span class="line">            count++;         </span><br><span class="line">            System.out.println(<span class="string">"thread:"</span>+Thread.currentThread().getName()+<span class="string">" name:"</span> + name + <span class="string">" count:"</span> + count);  </span><br><span class="line">            mutex.unlock();   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述FIFOMutex类的实现中，当判断锁已被占用时，会调用 LockSupport.park(this) 方法，将当前 调用线程阻塞；当使用完锁时，会调用 LockSupport.unpark(waiters.peek()) 方法将等待队列中 的队首线程唤醒。<br>通过LockSupport的这两个方法，可以很方便的阻塞和唤醒线程。</p>
<ul>
<li>park 方法是会响应中断的，但是不会抛出异常。（也就是说如果当前调用线程被中断，则会立即 返回但不会抛出中断异常） </li>
<li>park 的重载方法 park(Object blocker)，会传入一个blocker对象，所谓Blocker对象，其实 就是当前线程调用时所在调用对象（如上述示例中的FIFOMutex对象）。该对象一般供监视、诊断 工具确定线程受阻塞的原因时使用。</li>
</ul>
<h5 id="3-3-3-Condition"><a href="#3-3-3-Condition" class="headerlink" title="3.3.3 Condition"></a>3.3.3 Condition</h5><p>在没有Lock之前，我们使用synchronized来控制同步，配合Object的wait()、wait(long timeout)、notify()、以及notifyAll 等方法可以实现等待/通知模式。<br>Condition接口也提供了类似于Object的监听器方法、与Lock接口配合可以实现等待/通知模式，但是 两者还是有很大区别的，下图是两者的对比：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img2.jpg"  alt></p>
<p>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便 通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中， Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。</p>
<p>条件（也称为条件队列 或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同 的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性 是：以原子方式 释放相关的锁，并挂起当前线程，就像 Object.wait 做的那样。</p>
<p>Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。<br>核心方法<br>Condition提供了一系列的方法来对阻塞和唤醒线程：</p>
<ul>
<li>await()：造成当前线程在接到信号或被中断之前一直处于等待状态。</li>
<li>await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时 间之前一直处于等待状态。 </li>
<li>awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间 之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。 </li>
<li>awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。 </li>
<li>awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定后期限之前一 直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返 回false。</li>
<li>signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</li>
<li>signalAll() ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的 锁。</li>
</ul>
<p>Condition是一种广义上的条件队列。他为线程提供了一种更为灵活的等待/通知模式，线程在调用 await方法后执行挂起操作，直到线程等待的某个条件为真时才会被唤醒。Condition必须要配合锁一 起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑 定，因此Condition一般都是作为Lock的内部实现。</p>
<h6 id="源码探索"><a href="#源码探索" class="headerlink" title="源码探索"></a>源码探索</h6><p>获取一个Condition必须要通过Lock的newCondition()方法。该方法定义在接口Lock下，返回的结果 是绑定到此 Lock 实例的新 Condition 实例。<br>Condition为一个接口，其下仅有一个实现类ConditionObject，由于Condition的操作需要获取相关 的锁，而AQS则是同步锁的实现基础，所以ConditionObject则定义为AQS的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>等待队列</strong><br>每个Condition对象都包含着一个FIFO队列，该队列是Condition对象通知/等待功能的关键。<br>在队列中每一个节点都包含着一个线程引用，该线程就是在该Condition对象上等待的线程。<br>Condition的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>; </span><br><span class="line">    <span class="comment">/** First node of condition queue. */</span>     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;           </span><br><span class="line">    <span class="comment">/** Last node of condition queue. */</span>   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">/**   </span></span><br><span class="line"><span class="comment">         * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">	  */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">       <span class="comment">// Internal methods     </span></span><br><span class="line">    	<span class="comment">// 省略方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出Condition拥有首节点（firstWaiter），尾节点（lastWaiter）。</p>
<p>当前线程调用await()方法，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾 部。<br>Node里面包含了当前线程的引用。Node定义与AQS的CLH同步队列的节点使用的都是同一个类。</p>
<p>Condition的队列结构比CLH同步队列的结构简单些，新增过程较为简单只需要将原尾节点的 nextWaiter指向新增节点，然后更新lastWaiter即可。</p>
<p><strong>等待</strong><br>调用Condition的await()方法会使当前线程进入等待状态，同时会加入到Condition等待队列并释放 锁。</p>
<p>当从await()方法返回时，当前线程一定是获取了Condition相的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    <span class="comment">// 当前线程中断、直接异常   </span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();     </span><br><span class="line">    <span class="comment">//加入等待队列            </span></span><br><span class="line">    Node node = addConditionWaiter();    </span><br><span class="line">    <span class="comment">//释放锁           </span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);      </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;      </span><br><span class="line">    <span class="comment">//检测当前节点是否在同步队列上、如果不在则说明该节点没有资格竞争锁，继续等 待。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;      </span><br><span class="line">        <span class="comment">// 挂起线程           </span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);           </span><br><span class="line">        <span class="comment">// 线程释是否被中断，中断直接退出      </span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)       </span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">    &#125;                   </span><br><span class="line">    <span class="comment">// 获取同步状态    </span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)    </span><br><span class="line">        interruptMode = REINTERRUPT;            </span><br><span class="line">    <span class="comment">// 清理条件队列         </span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// clean up if cancelled      </span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">	<span class="keyword">if</span> (interruptMode != <span class="number">0</span>)    </span><br><span class="line">    	reportInterruptAfterWait(interruptMode);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此段代码的逻辑是： 首先将当前线程新建一个节点同时加入到等待队列中，然后释放当前线程持有的同步状态。<br>然后则是不断检测该节点代表的线程是否出现在CLH同步队列中（收到signal信号之后就会在AQS队列 中检测到），如果不存在则一直挂起，否则参与竞争同步状态。</p>
<p><strong>加入条件队列（addConditionWaiter()）源码如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//队列的尾节点          </span></span><br><span class="line">    Node t = lastWaiter;      </span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.           </span></span><br><span class="line">    <span class="comment">// 如果该节点的状态的不是CONDITION，则说明该节点不在等待队列上，需要清除       </span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;       </span><br><span class="line">        <span class="comment">// 清除等待队列中状态不为CONDITION的节点         </span></span><br><span class="line">        unlinkCancelledWaiters();                 </span><br><span class="line">        <span class="comment">//清除后重新获取尾节点           </span></span><br><span class="line">        t = lastWaiter;       </span><br><span class="line">    &#125;                 </span><br><span class="line">    <span class="comment">// 将当前线程构造成等待节点     </span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);     </span><br><span class="line">    <span class="comment">// 将node节点添加到等待队列的尾部      </span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)           </span><br><span class="line">        firstWaiter = node;       </span><br><span class="line">    <span class="keyword">else</span>           </span><br><span class="line">        t.nextWaiter = node;     </span><br><span class="line">    lastWaiter = node;      </span><br><span class="line">    <span class="keyword">return</span> node;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是将当前线程加入到Condition条件队列中。当然在加入到尾节点之前会清除所有状态不为 Condition的节点。<br>fullyRelease(Node node)，负责释放该线程持有的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;    </span><br><span class="line">    <span class="keyword">try</span> &#123;                 </span><br><span class="line">        <span class="comment">// 获取节点持有锁的数量       </span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();        </span><br><span class="line">        <span class="comment">// 释放锁也就是释放共享状态       </span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;      </span><br><span class="line">            failed = <span class="keyword">false</span>;        </span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)       </span><br><span class="line">            node.waitStatus = Node.CANCELLED;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isOnSyncQueue(Node node)：如果一个节点刚开始在条件队列上，现在在同步队列上获取锁则返回 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;    </span><br><span class="line">	<span class="comment">// 状态为CONDITION 、前驱节点为空，返回false    </span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;       </span><br><span class="line">    <span class="comment">// 如果后继节点不为空，则说明节点肯定在同步队列中       </span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="comment">// If has successor, it must be on queue            </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;     </span><br><span class="line">    <span class="comment">/*         </span></span><br><span class="line"><span class="comment">    * node.prev can be non-null, but not yet on queue because    </span></span><br><span class="line"><span class="comment">    * the CAS to place it on queue can fail. So we have to         </span></span><br><span class="line"><span class="comment">    * traverse from tail to make sure it actually made it.  It   </span></span><br><span class="line"><span class="comment">    * will always be near the tail in calls to this method, and    </span></span><br><span class="line"><span class="comment">    * unless the CAS failed (which is unlikely), it will be     </span></span><br><span class="line"><span class="comment">    * there, so we hardly ever traverse much.  </span></span><br><span class="line"><span class="comment">    */</span>     </span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlinkCancelledWaiters()：负责将条件队列中状态不为Condition的节点删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    <span class="comment">// 首节点           </span></span><br><span class="line">    Node t = firstWaiter;      </span><br><span class="line">    Node trail = <span class="keyword">null</span>;      </span><br><span class="line">    <span class="comment">// 从头开始清除状态不为CONDITION的节点       </span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;          </span><br><span class="line">        Node next = t.nextWaiter;          </span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;   </span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;       </span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)        </span><br><span class="line">                firstWaiter = next;  </span><br><span class="line">            <span class="keyword">else</span>                      </span><br><span class="line">                trail.nextWaiter = next;      </span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)       </span><br><span class="line">                lastWaiter = trail;        </span><br><span class="line">        &#125;               </span><br><span class="line">        <span class="keyword">else</span>             </span><br><span class="line">            trail = t;       </span><br><span class="line">        t = next;</span><br><span class="line">	&#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通知</strong></p>
<p>调用Condition的signal()方法，将会唤醒在等待队列中等待长时间的节点（条件队列里的首节 点），在唤醒节点前，会将节点移到同步队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果同步是以独占方式进行的，则返回 true；其他情况则返回 false  </span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())           </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();         </span><br><span class="line">    <span class="comment">// 唤醒首节点         </span></span><br><span class="line">    Node first = firstWaiter;             </span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)        </span><br><span class="line">        doSignal(first);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先会判断当前线程是否已经获得了锁，这是前置条件。然后唤醒条件队列中的头节点。<br>doSignal(Node first)：唤醒头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">do</span> &#123;             </span><br><span class="line">        <span class="comment">// 修改头节点、方便移除          </span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)      </span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;        </span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;              </span><br><span class="line">        <span class="comment">// 将该节点移到同步队列      </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;     </span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doSignal(Node first)主要是做两件事：</p>
<ul>
<li>修改头节点；</li>
<li>调用transferForSignal(Node first) 方法将节点移动到CLH同步队列中。</li>
</ul>
<p>整个通知的流程如下：</p>
<ul>
<li>判断当前线程是否已经获取了锁，如果没有获取则直接抛出异常，因为获取锁为通知的前置条件。 </li>
<li>如果线程已经获取了锁，则将唤醒条件队列的首节点。 </li>
<li>唤醒首节点是先将条件队列中的头节点移出，然后调用AQS的enq(Node node)方法将其安全地移 到CLH同步队列中 。 </li>
<li>最后判断如果该节点的同步状态是否为Cancel，或者修改状态为Signal失败时，则直接调用 LockSupport唤醒该节点的线程。</li>
</ul>
<p>一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到条件队列中，然后释 放锁，后通过isOnSyncQueue(Node node)方法不断自检看节点是否已经在CLH同步队列了，如果是 则尝试获取锁，否则一直挂起。<br>当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法唤醒CLH同步队列的首节点。被唤醒的线程，将从await()方法中的while循环中退出来， 然后调用acquireQueued()方法竞争同步状态。<br>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition();  </span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        </span><br><span class="line">       lock.lock();     </span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">           <span class="keyword">while</span> (count == items.length)    </span><br><span class="line">               notFull.await();    </span><br><span class="line">            items[putptr] = x;    </span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;   </span><br><span class="line">            ++count;    </span><br><span class="line">            notEmpty.signal(); </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;      </span><br><span class="line">            lock.unlock();    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">       lock.lock();    </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"> 			<span class="keyword">while</span> (count == <span class="number">0</span>)   </span><br><span class="line">                notEmpty.await(); </span><br><span class="line">           Object x = items[takeptr];   </span><br><span class="line">           <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>; </span><br><span class="line">           --count;      </span><br><span class="line">           notFull.signal();     </span><br><span class="line">           <span class="keyword">return</span> x;  </span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">           lock.unlock();   </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-4-Synchronizers"><a href="#3-4-Synchronizers" class="headerlink" title="3.4 Synchronizers"></a>3.4 Synchronizers</h4><h5 id="3-4-1-Semaphore"><a href="#3-4-1-Semaphore" class="headerlink" title="3.4.1 Semaphore"></a>3.4.1 Semaphore</h5><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，通过协调各个线程，保证合理的使用 公共资源。<br>Semaphore维护了一个许可集，其实就是一定数量的“许可证”。 当有线程想要访问共享资源时，需要先获取(acquire)的许可；如果许可不够了，线程需要一直等待， 直到许可可用。当线程使用完共享资源后，可以归还(release)许可，以供其它需要的线程使用。<br>和ReentrantLock类似，Semaphore支持公平/非公平策略。<br>源码:略。<br>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个会实现print queue的类名为 PrintQueue。 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个对象为Semaphore，称它为semaphore。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;  </span><br><span class="line">    <span class="comment">// 实现类的构造函数并初始能保护print quere的访问的semaphore对象的值。  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintQueue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Implement the printJob()方法，此方法可以模拟打印文档，并接收document对象 作为参数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//在这方法内，首先，你必须调用acquire()方法获得demaphore。这个方法会抛出 InterruptedException异常，使用必须包含处理这个异常的代码。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;           </span><br><span class="line">            semaphore.acquire();</span><br><span class="line">             </span><br><span class="line"><span class="comment">//然后，实现能随机等待一段时间的模拟打印文档的行。   </span></span><br><span class="line">             <span class="keyword">long</span> duration = (<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line"> 			System.out.printf(<span class="string">"%s: PrintQueue: Printing a Job during %d seconds\n"</span>, Thread.currentThread().getName(), duration);</span><br><span class="line">            Thread.sleep(duration);</span><br><span class="line"><span class="comment">//最后，释放semaphore通过调用semaphore的relaser()方法。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;        </span><br><span class="line">            semaphore.release();   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个名为Job的类并一定实现Runnable 接口。这个类实现把文档传送到打印机的任务。 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//声明一个对象为PrintQueue，名为printQueue。   </span></span><br><span class="line">    <span class="keyword">private</span> PrintQueue printQueue;  </span><br><span class="line">    <span class="comment">//实现类的构造函数，初始化这个类里的PrintQueue对象。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.printQueue = printQueue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现方法run()。 </span></span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//首先， 此方法写信息到操控台表明任务已经开始执行了。    </span></span><br><span class="line">        System.out.printf(<span class="string">"%s: Going to print a job\n"</span>, Thread.currentThread().getName());          </span><br><span class="line">        <span class="comment">// 然后，调用PrintQueue 对象的printJob()方法。   </span></span><br><span class="line">        printQueue.printJob(<span class="keyword">new</span> Object());         </span><br><span class="line">        <span class="comment">//最后， 此方法写信息到操控台表明它已经结束运行了。 </span></span><br><span class="line">        System.out.printf(<span class="string">"%s: The document has been printed\n"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">                <span class="comment">// 创建PrintQueue对象名为printQueue。      </span></span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();      </span><br><span class="line">        <span class="comment">//创建10个threads。每个线程会执行一个发送文档到print queue的Job对象。   </span></span><br><span class="line">        Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;     </span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue), <span class="string">"Thread"</span> + i);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">            thread[i].start();    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-CountDownLatch"><a href="#3-4-2-CountDownLatch" class="headerlink" title="3.4.2 CountDownLatch"></a>3.4.2 CountDownLatch</h5><p>在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能，在这种的业务场景下，通常可以使用Thread类的join方法，让主线程等待被join的线程执 行完之后，主线程才能继续往下执行。当然，使用线程间消息通信机制也可以完成。其实，java并发工 具类中为我们提供了类似“倒计时”这样的工具类，可以十分方便的完成所说的这种业务场景。<br>CountDownLatch允许一个或多个线程等待其他线程完成工作。<br>CountDownLatch相关方法：</p>
<ul>
<li><p>public CountDownLatch(int count) 构造方法会传入一个整型数N，之后调用 CountDownLatch的 countDown 方法会对N减一，知道N减到0的时候，当前调用 await 方法的线程继续执行。</p>
</li>
<li><p>await() throws InterruptedException：调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行；</p>
</li>
<li><p>await(long timeout, TimeUnit unit)：与上面的await方法功能一致，只不过这里有了时间 限制，调用该方法的线程等到指定的timeout时间后，不管N是否减至为0，都会继续往下执行；</p>
</li>
<li><p>countDown()：使CountDownLatch初始值N减1；</p>
</li>
<li><p>long getCount()：获取当前CountDownLatch维护的值</p>
</li>
</ul>
<p>  栗子：运动员进行跑步比赛时，假设有6个运动员参与比赛，裁判员在终点会为这6个运动员分别计时， 可以想象没当一个运动员到达终点的时候，对于裁判员来说就少了一个计时任务。直到所有运动员都到 达终点了，裁判员的任务也才完成。这6个运动员可以类比成6个线程，当线程调用 CountDownLatch.countDown方法时就会对计数器的值减一，直到计数器的值为0的时候，裁判员（调 用await方法的线程）才能继续往下执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//用来表示裁判员需要维护的是6个运动员 </span></span><br><span class="line">    rivate <span class="keyword">static</span> CountDownLatch endSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;   </span><br><span class="line">        executorService.execute(() -&gt; &#123;        </span><br><span class="line">            <span class="keyword">try</span> &#123;              </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 运动 员等待裁判员响哨！！！"</span>);          </span><br><span class="line">                startSignal.await();     </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"正在 全力冲刺"</span>); </span><br><span class="line">                endSignal.countDown();    </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"  到 达终点"</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </span><br><span class="line">                e.printStackTrace();       </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(<span class="string">"裁判员响哨开始啦！！！"</span>);    </span><br><span class="line">    startSignal.countDown(); </span><br><span class="line">    endSignal.await();  </span><br><span class="line">    System.out.println(<span class="string">"所有运动员到达终点，比赛结束！"</span>);</span><br><span class="line"> 	executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例代码中设置了两个CountDownLatch，第一个endSignal用于控制让main线程（裁判员）必须等 到其他线程（运动员）让CountDownLatch维护的数值N减到0为止，相当于一个完成信号；另一个 startSignal用于让main线程对其他线程进行“发号施令”，相当于一个入口或者开关。</p>
<p>startSignal引用的CountDownLatch初始值为1，而其他线程执行的run方法中都会先通过 startSignal.await()让这些线程都被阻塞，直到main线程通过调用startSignal.countDown();， 将值N减1，CountDownLatch维护的数值N为0后，其他线程才能往下执行，并且，每个线程执行的run 方法中都会通过endSignal.countDown();对endSignal维护的数值进行减一，由于往线程池提交了6 个任务，会被减6次，所以endSignal维护的值终会变为0，因此main线程在latch.await();阻塞结 束，才能继续往下执行。</p>
<p><code>注意：当调用CountDownLatch的countDown方法时，当前线程是不会被阻塞，会继续往下执行。</code></p>
<h5 id="3-4-3-CyclicBarrier"><a href="#3-4-3-CyclicBarrier" class="headerlink" title="3.4.3 CyclicBarrier"></a>3.4.3 CyclicBarrier</h5><p>CountDownLatch是一个倒数计数器，在计数器不为0时，所有调用await的线程都会等待，当计数器降 为0，线程才会继续执行，且计数器一旦变为0，就不能再重置了。</p>
<p>CyclicBarrier可以认为是一个栅栏，栅栏的作用是什么？就是阻挡前行。</p>
<p>CyclicBarrier是一个可以循环使用的栅栏，它做的事情就是：让线程到达栅栏时被阻塞(调用await 方法)，直到到达栅栏的线程数满足指定数量要求时，栅栏才会打开放行，被栅栏拦截的线程才可以执行。</p>
<p>当多个线程都达到了指定点后，才能继续往下继续执行。这就有点像报数的感觉，假设6个线程就相当 于6个运动员，到赛道起点时会报数进行统计，如果刚好是6的话，这一波就凑齐了，才能往下执行。这 里的6个线程，也就是计数器的初始值6，是通过CyclicBarrier的构造方法传入的。</p>
<p>CyclicBarrier的主要方法：</p>
<ul>
<li><p>await() throws InterruptedException, BrokenBarrierException  等到所有的线程都到 达指定的临界点； </p>
</li>
<li><p>await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException 与上面的await方法功能基本一致，只不过这 里有超时限制，阻塞等待直至到达超时时间为止；</p>
</li>
<li><p>int getNumberWaiting()获取当前有多少个线程阻塞等待在临界点上；</p>
</li>
<li><p>boolean isBroken()用于查询阻塞等待的线程是否被中断 </p>
</li>
<li><p>void reset()将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出 BrokenBarrierException。 </p>
</li>
</ul>
<p>  另外需要注意的是，CyclicBarrier提供了这样的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure>

<p>可以用来，当指定的线程都到达了指定的临界点的时，接下来执行的操作可以由barrierAction传入即 可。</p>
<p>栗子：</p>
<p>6个运动员准备跑步比赛，运动员在赛跑需要在起点做好准备，当裁判发现所有运动员准备完毕后，就 举起发令枪，比赛开始。这里的起跑线就是屏障，是临界点，而这6个运动员就类比成线程的话，就是 这6个线程都必须到达指定点了，意味着凑齐了一波，然后才能继续执行，否则每个线程都得阻塞等待，直至凑齐一波即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">6</span>;  </span><br><span class="line">        <span class="comment">// 运动员数    </span></span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> Runnable() &#123;    </span><br><span class="line">            <span class="meta">@Override</span>         </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">                System.out.println(<span class="string">"所有运动员已准备完毕，发令枪：跑！"</span>);      </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;        </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrepareWork(cb), <span class="string">"运动员["</span> + i + <span class="string">"]"</span>); </span><br><span class="line">            t.start();      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrepareWork</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cb;</span><br><span class="line">        </span><br><span class="line">        PrepareWork(CyclicBarrier cb) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.cb = cb;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;        </span><br><span class="line">                Thread.sleep(<span class="number">500</span>);     </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": 准 备完成"</span>);  </span><br><span class="line">                cb.await();     </span><br><span class="line">                <span class="comment">// 在栅栏等待     </span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;         </span><br><span class="line">                e.printStackTrace();   </span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;      </span><br><span class="line">                e.printStackTrace();      </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，当6个运动员（线程）都到达了指定的临界点（barrier）时候，才能继续往下 执行，否则，则会阻塞等待在调用 await() 处。</p>
<h6 id="CyclicBarrier对异常的处理"><a href="#CyclicBarrier对异常的处理" class="headerlink" title="CyclicBarrier对异常的处理"></a>CyclicBarrier对异常的处理</h6><p><strong>线程在阻塞过程中，可能被中断，那么既然CyclicBarrier放行的条件是等待的线程数达到指定数目， 万一线程被中断导致终的等待线程数达不到栅栏的要求怎么办？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;    </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法除了抛出InterruptedException异常外，还会抛出 BrokenBarrierException 。<br>BrokenBarrierException表示当前的CyclicBarrier已经损坏了，等不到所有线程都到达栅栏了，所 以已经在等待的线程也没必要再等了，可以散伙了。<br>出现以下几种情况之一时，当前等待线程会抛出BrokenBarrierException异常：</p>
<ul>
<li><p>其它某个正在await等待的线程被中断了；</p>
</li>
<li><p>其它某个正在await等待的线程超时了；</p>
</li>
<li><p>某个线程重置了CyclicBarrier；</p>
<p>另外，只要正在Barrier上等待的任一线程抛出了异常，那么Barrier就会认为肯定是凑不齐所有线程了，就会将栅栏置为损坏（Broken）状态，并传播BrokenBarrierException给其它所有正在等待 （await）的线程。<br>异常情况模拟：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">6</span>;  </span><br><span class="line">        <span class="comment">// 运动员数   </span></span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>        </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">                System.out.println(<span class="string">"所有运动员已准备完毕，发令枪：跑！"</span>);    </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;     </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrepareWork(cb), <span class="string">"运动员["</span> + i + <span class="string">"]"</span>);  </span><br><span class="line">            list.add(t);        </span><br><span class="line">            t.start();        </span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;      </span><br><span class="line">                t.interrupt(); </span><br><span class="line">                <span class="comment">// 运动员[3]置中断标志位      </span></span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">        System.out.println(<span class="string">"Barrier是否损坏："</span> + cb.isBroken());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrepareWork</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cb;</span><br><span class="line">        </span><br><span class="line">        PrepareWork(CyclicBarrier cb) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.cb = cb;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;           </span><br><span class="line">            <span class="keyword">try</span> &#123;          </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": 准 备完成"</span>);  </span><br><span class="line">                cb.await();      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  				System.out.println(Thread.currentThread().getName() + <span class="string">": 被 中断"</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;        </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": 抛 出BrokenBarrierException"</span>);       </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch与CyclicBarrier的比较<br>CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数 器，但是这两者还是各有不同侧重点的：</p>
<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大 家都完成，再携手共进。 </li>
<li>调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了 指定点的时候，才能继续往下执行； </li>
<li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过 getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的 构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；</li>
<li>CountDownLatch是不能复用的，而CyclicLatch是可以复用的。</li>
</ul>
<h5 id="3-4-4-Exchanger"><a href="#3-4-4-Exchanger" class="headerlink" title="3.4.4 Exchanger"></a>3.4.4 Exchanger</h5><p>Exchanger可以用来在两个线程之间交换持有的对象。当Exchanger在一个线程中调用exchange方法之 后，会等待另外的线程调用同样的exchange方法，两个线程都调用exchange方法之后，传入的参数就 会交换。<br>两个主要方法<br>public V exchange(V x) throws InterruptedException<br>当这个方法被调用的时候，当前线程将会等待直到其他的线程调用同样的方法。当其他的线程调用 exchange之后，当前线程将会继续执行。<br>在等待过程中，如果有其他的线程interrupt当前线程，则会抛出InterruptedException。<br>public V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException<br>多了一个timeout时间。如果在timeout时间之内没有其他线程调用exchange方法，抛出 TimeoutException。</p>
<p>栗子：<br>我们先定义一个带交换的类：</p>
<p>然后定义两个Runnable，在run方法中调用exchange方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">         Exchanger&lt;CustBook&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();    </span><br><span class="line">         <span class="comment">// Starting two threads    </span></span><br><span class="line">         <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExchangerOne(exchanger)).start();     </span><br><span class="line">         <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExchangerTwo(exchanger)).start();  </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustBook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerOne</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Exchanger&lt;CustBook&gt; ex;</span><br><span class="line">    </span><br><span class="line">    ExchangerOne(Exchanger&lt;CustBook&gt; ex)&#123;  </span><br><span class="line">        <span class="keyword">this</span>.ex=ex;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        CustBook custBook= <span class="keyword">new</span> CustBook();    </span><br><span class="line">        custBook.setName(<span class="string">"book one"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">            CustBook exhangeCustBook=ex.exchange(custBook);  </span><br><span class="line">            log.info(exhangeCustBook.getName());     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;      </span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTwo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Exchanger&lt;CustBook&gt; ex;</span><br><span class="line">    ExchangerTwo(Exchanger&lt;CustBook&gt; ex)&#123;   </span><br><span class="line">        <span class="keyword">this</span>.ex=ex;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CustBook custBook= <span class="keyword">new</span> CustBook();  </span><br><span class="line">        custBook.setName(<span class="string">"book two"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;     </span><br><span class="line">            CustBook exhangeCustBook=ex.exchange(custBook);  </span><br><span class="line">            log.info(exhangeCustBook.getName());     </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-5-Phaser"><a href="#3-4-5-Phaser" class="headerlink" title="3.4.5 Phaser"></a>3.4.5 Phaser</h5><p>Phaser是一个同步工具类，适用于一些需要分阶段的任务的处理。它的功能与 CyclicBarrier和 CountDownLatch类似，类似于一个多阶段的栅栏，并且功能更强大，我们来比较下这三者的功能：</p>
<table>
<thead>
<tr>
<th><strong>CountDownLatch</strong></th>
<th>倒数计数器，初始时设定计数器值，线程可以在计数器上等待，当计数器 值归0后，所有等待的线程继续执行</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CyclicBarrier</strong></td>
<td><strong>循环栅栏，初始时设定参与线程数，当线程到达栅栏后，会等待其它线程的到达，当到达栅栏的总数满足指定数后，所有等待的线程继续执行</strong></td>
</tr>
<tr>
<td><strong>Phaser</strong></td>
<td><strong>多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与 者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级  （advance）</strong></td>
</tr>
</tbody></table>
<p>相关概念：</p>
<p><strong>phase(阶段)</strong></p>
<p>Phaser也有栅栏，在Phaser中，栅栏的名称叫做phase(阶段)，在任意时间点，Phaser只处于某一个 phase(阶段)，初始阶段为0，大达到Integerr.MAX_VALUE，然后再次归零。当所有parties参与者 都到达后，phase值会递增。</p>
<p><strong>parties(参与者)</strong></p>
<p>Phaser既可以在初始构造时指定参与者的数量，也可以中途通过register、bulkRegister、 arriveAndDeregister等方法注册/注销参与者。</p>
<p><strong>arrive(到达) / advance(进阶)</strong></p>
<p>Phaser注册完parties（参与者）之后，参与者的初始状态是unarrived的，当参与者到达 （arrive）当前阶段（phase）后，状态就会变成arrived。当阶段的到达参与者数满足条件后（注册 的数量等于到达的数量），阶段就会发生进阶（advance）——也就是phase值+1。</p>
<p><strong>Termination（终止）</strong></p>
<p>代表当前Phaser对象达到终止状态。</p>
<p><strong>Tiering（分层）</strong></p>
<p>Phaser支持分层（Tiering） —— 一种树形结构，通过构造函数可以指定当前待构造的Phaser对象 的父结点。之所以引入Tiering，是因为当一个Phaser有大量参与者（parties）的时候，内部的同步 操作会使性能急剧下降，而分层可以降低竞争，从而减小因同步导致的额外开销。<br>在一个分层Phasers的树结构中，注册和撤销子Phaser或父Phaser是自动被管理的。当一个Phaser参 与者（parties）数量变成0时，如果有该Phaser有父结点，就会将它从父结点中溢移除。<br>核心方法：</p>
<ul>
<li><p>arriveAndDeregister() 该方法立即返回下一阶段的序号，并且其它线程需要等待的个数减 一，     取消自己的注册、把当前线程从之后需要等待的成员中移除。     如果该Phaser是另外一个Phaser的子Phaser（层次化Phaser），     并且该操作导致当前Phaser的成员数为0，则该操作也会将当前Phaser从其父Phaser中移除。 </p>
</li>
<li><p>arrive() 某个参与者完成任务后调用，该方法不作任何等待，直接返回下一阶段的序号。</p>
</li>
<li><p>awaitAdvance(int phase) 该方法等待某一阶段执行完毕。     如果当前阶段不等于指定的阶段或者该Phaser已经被终止，则立即返回。     该阶段数一般由arrive()方法或者arriveAndDeregister()方法返回。 返回下一阶段的序号，或者返回参数指定的值（如果该参数为负数），或者直接返回当前阶 段序号（如果当前Phaser已经被终止）。 </p>
</li>
<li><p>awaitAdvanceInterruptibly(int phase) 效果与awaitAdvance(int phase)相当， 唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出InterruptedException。</p>
</li>
<li><p>awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)   效果与awaitAdvanceInterruptibly(int phase)相当，区别在于如果超时则抛出TimeoutException。 </p>
</li>
<li><p>bulkRegister(int parties) 动态调整注册任务parties的数量。如果当前phaser已经被终 止，则该方法无效，并返回负数。     如果调用该方法时，onAdvance方法正在执行，则该方法等待其执行完毕。     如果该Phaser有父Phaser则指定的party数大于0，且之前该Phaser的party数为0，那么该 Phaser会被注册到其父Phaser中。</p>
</li>
<li><p>forceTermination() 强制让该Phaser进入终止状态。 已经注册的party数不受影响。如果该Phaser有子Phaser，则其所有的子Phaser均进入终止 状态。如果该Phaser已经处于终止状态，该方法调用不造成任何影响。 </p>
</li>
</ul>
<p>栗子：3个线程，4个阶段，每个阶段都并发处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> kaikeba.com;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> parties = <span class="number">3</span>;       </span><br><span class="line">        <span class="keyword">int</span> phases = <span class="number">4</span>;    </span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(parties) &#123;      </span><br><span class="line">            <span class="meta">@Override</span>         </span><br><span class="line">            <span class="comment">//每个阶段结束时      </span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">"====== Phase : "</span> + phase + <span class="string">"  end ======"</span>);  </span><br><span class="line">                <span class="keyword">return</span> registeredParties == <span class="number">0</span>;      </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parties; i++) &#123;   </span><br><span class="line">            <span class="keyword">int</span> threadId = i;      </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;         </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> phase = <span class="number">0</span>; phase &lt; phases; phase++) &#123;    </span><br><span class="line">                    <span class="keyword">if</span> (phase == <span class="number">0</span>) &#123;     </span><br><span class="line">                        System.out.println(String.format(<span class="string">"第一阶段操作  Thread %s, phase %s"</span>, threadId, phase));               </span><br><span class="line">                    &#125;          </span><br><span class="line">                    <span class="keyword">if</span> (phase == <span class="number">1</span>) &#123;  </span><br><span class="line">                        System.out.println(String.format(<span class="string">"第二阶段操作  Thread %s, phase %s"</span>, threadId, phase));             </span><br><span class="line">                    &#125;           </span><br><span class="line">                    <span class="keyword">if</span> (phase == <span class="number">2</span>) &#123;     </span><br><span class="line">                        System.out.println(String.format(<span class="string">"第三阶段操作  Thread %s, phase %s"</span>, threadId, phase));      </span><br><span class="line">                    &#125;          </span><br><span class="line">                    <span class="keyword">if</span> (phase == <span class="number">3</span>) &#123;    </span><br><span class="line">                        System.out.println(String.format(<span class="string">"第四阶段操作  Thread %s, phase %s"</span>, threadId, phase));   </span><br><span class="line">					 &#125;      </span><br><span class="line">                    <span class="comment">/**        </span></span><br><span class="line"><span class="comment">                      * arriveAndAwaitAdvance() 当前线程当前阶段执行完毕，等待其它线程完成当前 阶段。         </span></span><br><span class="line"><span class="comment">                      * 如果当前线程是该阶段最后一个未到达的，则该方法直接返回下一个阶段的序号（阶段 序号从0开始），         </span></span><br><span class="line"><span class="comment">                      * 同时其它线程的该方法也返回下一个阶段的序号。  </span></span><br><span class="line"><span class="comment">                      **/</span>              </span><br><span class="line">                    <span class="keyword">int</span> nextPhaser = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;);      </span><br><span class="line">            thread.start();  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-Executors"><a href="#3-5-Executors" class="headerlink" title="3.5 Executors"></a>3.5 Executors</h4><h5 id="3-5-1-Executor框架"><a href="#3-5-1-Executor框架" class="headerlink" title="3.5.1 Executor框架"></a>3.5.1 Executor框架</h5><p>Executor框架包括3大部分：</p>
<ul>
<li>任务。也就是工作单元，包括被执行任务需要实现的接口：Runnable接口或者Callable接口；</li>
<li>任务的执行。也就是把任务分派给多个线程的执行机制，包括Executor接口及继承自Executor接 口的ExecutorService接口。</li>
<li>异步计算的结果。包括Future接口及实现了Future接口的FutureTask类。</li>
</ul>
<p>Executor框架的成员及其关系可以用一下的关系图表示：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img3.jpg"  alt></p>
<p>Executor框架的使用示意图：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img4.jpg"  alt></p>
<p>使用步骤：</p>
<ul>
<li>创建Runnable并重写run（）方法或者Callable对象并重写call（）方法，得到一个任务对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">callableImp</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span> &gt;</span>&#123;     </span><br><span class="line">    <span class="meta">@Override</span>         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">try</span>&#123;             </span><br><span class="line">            String a = <span class="string">"return String"</span>;       </span><br><span class="line">            <span class="keyword">return</span> a;         </span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"exception"</span>;     </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建ExecutorService接口的实现类ThreadPoolExecutor类或者 ScheduledThreadPoolExecutor类的对象，然后调用其execute()方法或者submit()方法，提 交任务对象执行。</li>
<li>主线程调用Future对象的get()方法获取返回值，或者调用Future对象的cancel()方法取消当前 线程的执行。</li>
</ul>
<p>Executor框架成员：ThreadPoolExecutor实现类、ScheduledThreadPoolExecutor实现类、Future 接口、Runnable和Callable接口、Executors工厂类<br>Executor:执行器接口，也是顶层的抽象核心接口， 分离了任务和任务的执行。ExecutorService 在Executor的基础上提供了执行器生命周期管理，任务异步执行等功能。<br>Executors：生产具体的执行器的静态工厂。<br>ThreadPoolExecutor:线程池Executor，也是常用的Executor，通常使用Executors来创建，可以 创建三种类型的ThreadPoolExecutor：SingleThreadPoolExecutor，FixedThreadPool和 CachedThreadPool，以线程池的方式管理线程。<br>ScheduledThreadPoolExecutor：在ThreadPoolExecutor基础上，增加了对周期任务调度的支持。</p>
<p>Runnable和Callable接口：Runnable和Callable接口的实现类，可以被ThreadPoolExecutor和 ScheduledThreadPoolExecutor执行，区别是，亲着没有返回结果，候着可以返回结果。</p>
<h5 id="3-5-2-ThreadPoolExecutor"><a href="#3-5-2-ThreadPoolExecutor" class="headerlink" title="3.5.2 ThreadPoolExecutor"></a>3.5.2 ThreadPoolExecutor</h5><p>ThreadPoolExecutor一共提供了4种构造器，但其它三种内部其实都调用了下面的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 使用给定的参数创建ThreadPoolExecutor. </span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize    核心线程池中的最大线程数 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 总线程池中的最大线程数 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime   空闲线程的存活时间 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit            keepAliveTime的单位 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue       任务队列, 保存已经提交但尚未被执行的线程 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory   线程创建工厂 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler         拒绝策略 (当任务太多导致工作队列满时的处理策略) </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,       </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,       </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,                 </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,     </span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,   </span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||        </span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||    </span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||   </span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();    </span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   </span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;     </span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;     </span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;     </span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);  </span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;   </span><br><span class="line">    <span class="keyword">this</span>.handler = handler; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池状态定义；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*    </span></span><br><span class="line"><span class="comment">  * RUNNING -&gt; SHUTDOWN   </span></span><br><span class="line"><span class="comment">  *    On invocation of shutdown(), perhaps implicitly in finalize()  </span></span><br><span class="line"><span class="comment">  * (RUNNING or SHUTDOWN) -&gt; STOP     </span></span><br><span class="line"><span class="comment">  *    On invocation of shutdownNow()    </span></span><br><span class="line"><span class="comment">  * SHUTDOWN -&gt; TIDYING    </span></span><br><span class="line"><span class="comment">  *    When both queue and pool are empty   </span></span><br><span class="line"><span class="comment">  * STOP -&gt; TIDYING   </span></span><br><span class="line"><span class="comment">  *    When pool is empty     </span></span><br><span class="line"><span class="comment">  * TIDYING -&gt; TERMINATED    </span></span><br><span class="line"><span class="comment">  *    When the terminated() hook method has completed  </span></span><br><span class="line"><span class="comment">  * */</span>   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor一共定义了5种线程池状态：</p>
<ul>
<li>RUNNING : 接受新任务, 且处理已经进入阻塞队列的任务 </li>
<li>SHUTDOWN : 不接受新任务, 但处理已经进入阻塞队列的任务 </li>
<li>STOP : 不接受新任务, 且不处理已经进入阻塞队列的任务, 同时中断正在运行的任务 </li>
<li>TIDYING : 所有任务都已终止, 工作线程数为0, 线程转化为TIDYING状态并准备调用 </li>
<li>terminated方法 TERMINATED : terminated方法已经执行完成</li>
</ul>
<p>各个状态之间的流转图： </p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img5.jpg"  alt></p>
<p>执行execute</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();       </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();    </span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;      </span><br><span class="line">        <span class="comment">// CASE1: 工作线程数 &lt; 核心 线程池上限   </span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))     </span><br><span class="line">            <span class="comment">// 添加工作线程并执行       </span></span><br><span class="line">            <span class="keyword">return</span>;     </span><br><span class="line">        c = ctl.get(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 执行到此处, 说明工作线程创建失败 或 工作线程数≥核心线程池上限  </span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   </span><br><span class="line">        <span class="comment">// CASE2: 插入任务至 队列</span></span><br><span class="line">        <span class="comment">// 再次检查线程池状态    </span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();    </span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))     </span><br><span class="line">            reject(command);     </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)      </span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))     </span><br><span class="line">        <span class="comment">// CASE3: 插入队列失败, 判断 工作线程数 &lt; 总线程池上限    </span></span><br><span class="line">        reject(command);   </span><br><span class="line">    	<span class="comment">// 执行拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述execute的执行流程可以用下图描述：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/img6.jpg"  alt></p>
<p>execute的整个执行流程关键是下面两点：</p>
<ul>
<li>如果工作线程数小于核心线程池上限（CorePoolSize），则直接新建一个工作线程并执行任务；</li>
<li>如果工作线程数大于等于CorePoolSize，则尝试将任务加入到队列等待以后执行。如果加入队列 失败了（比如队列已满的情况），则在总线程池未满的情况下（ CorePoolSize ≤ 工作线程数 ＜ maximumPoolSize ）新建一个工作线程立即执行任务，否则执行拒绝策略。</li>
</ul>
<p>通过Executor框架的工具类Executors，可以创建三种类型的ThreadPoolExecutor：<br>FixedThreadPool：可重用固定线程数的线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,  </span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,    </span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>newFixedThreadPool</strong>创建一个固定长度的线程池，每次提交一个任务的时候就会创建一个新的线程， 直到达到线程池的大数量限制。</p>
<ul>
<li>定长，可以控制线程大并发数， corePoolSize 和 maximumPoolSize 的数值都是 nThreads。</li>
<li>超出线程数的任务会在队列中等待。 </li>
<li>工作队列为LinkedBlockingQueue</li>
</ul>
<p>创建方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="keyword">int</span> nThreads);</span><br></pre></td></tr></table></figure>

<p>SingleThreadExecutor:使用单个线程的Executor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService      </span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,  </span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,    </span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),  </span><br><span class="line">                                threadFactory));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>newSingleThreadExecutor</strong>，只创建一个工作线程执行任务，若这个唯一的线程异常故障了，会新建 另一个线程来替代，newSingleThreadExecutor可以保证任务依照在工作队列的排队顺序来串行执 行。</p>
<ul>
<li>有且仅有一个工作线程执行任务；</li>
<li>所有任务按照工作队列的排队顺序执行，先进先出的顺序</li>
<li>工作队列LinkedBlockingQueue</li>
</ul>
<p>创建方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService singleThreadPool = Executors.newSingleThreadPool();</span><br></pre></td></tr></table></figure>

<p>CachedThreadPool:会根据需要创建新线程的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,    </span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,    </span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),     </span><br><span class="line">                                  threadFactory);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>newCachedThreadPool</strong>将创建一个可缓存的线程池，如果当前线程数超过处理任务时，回收空闲线 程；当需求增加时，可以添加新线程去处理任务。<br>特点：</p>
<ul>
<li>线程数无限制，corePoolSize数值为0， maximumPoolSize 的数值都是为 Integer.MAX_VALUE。</li>
<li>若线程未回收，任务到达时，会复用空闲线程；</li>
<li>若无空闲线程，则新建线程执行任务。 因为复用性，一定程序减少频繁创建/销毁线程，减少系统开销。</li>
<li>工作队列选用SynchronousQueue。</li>
</ul>
<p>创建方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">2</span>;     </span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">4</span>;   </span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">10</span>;    </span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;       </span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);      </span><br><span class="line">        RejectedExecutionHandler handler = <span class="keyword">new</span> RejectedExecutionPolicy();   </span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,</span><br><span class="line">                                                             maximumPoolSize, </span><br><span class="line">                                                             keepAliveTime, unit,   </span><br><span class="line">                                                             workQueue, handler); </span><br><span class="line">        executor.prestartAllCoreThreads();</span><br><span class="line">        <span class="comment">// 预启动所有核心线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;    </span><br><span class="line">            ThreadTask task = <span class="keyword">new</span> ThreadTask(String.valueOf(i));     </span><br><span class="line">            executor.execute(task);     </span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read(); </span><br><span class="line">        <span class="comment">//阻塞主线程 </span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectedExecutionPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;     </span><br><span class="line">            doLog(r, e);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;     </span><br><span class="line">            System.err.println( r.toString() + <span class="string">" rejected"</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(String name)</span> </span>&#123;    </span><br><span class="line">            <span class="keyword">this</span>.name = name;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"> System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is running!"</span>);   </span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);     </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        </span><br><span class="line">                e.printStackTrace();      </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">            <span class="keyword">return</span> name;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>       </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ThreadTask [name="</span> + name + <span class="string">"]"</span>;      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-3-ScheduledExecutorService"><a href="#3-5-3-ScheduledExecutorService" class="headerlink" title="3.5.3 ScheduledExecutorService"></a>3.5.3 ScheduledExecutorService</h5><p><strong>构造线程池</strong><br>Executors使用 newScheduledThreadPool 工厂方法创建ScheduledThreadPoolExecutor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledThreadPoolExecutor的构造器，内部其实都是调用了父类ThreadPoolExecutor的构造 器，这里比较特别的是任务队列的选择——DelayedWorkQueue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, RejectedExecutionHandler handler)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), </span><br><span class="line">          handler); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池的调度</strong><br>该线程池的核心调度方法，是schedule、scheduleAtFixedRate、scheduleWithFixedDelay，通过 schedule方法来看下整个调度流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)      </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   </span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,                                                                                        triggerTime(delay, unit)));  </span><br><span class="line">    delayedExecute(t);   </span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的decorateTask方法把Runnable任务包装成ScheduledFutureTask，用户可以根据自己的需要 覆写该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledFutureTask是RunnableScheduledFuture接口的实现类，任务通过period字段来表示任务 类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//任务序号, 自增唯一 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 首次执行的时间点   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">// 0: 非周期任务; &gt;0: fixed-rate任务;&lt;0: fixed-delay任务  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在堆中的索引    </span></span><br><span class="line">    <span class="keyword">int</span> heapIndex;</span><br><span class="line"> </span><br><span class="line">    ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;   </span><br><span class="line">        <span class="keyword">super</span>(r, result);       </span><br><span class="line">        <span class="keyword">this</span>.time = ns;     </span><br><span class="line">        <span class="keyword">this</span>.period = <span class="number">0</span>;       </span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement(); </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledThreadPoolExecutor中的任务队列——DelayedWorkQueue，保存的元素就是 ScheduledFutureTask。DelayedWorkQueue是一种堆结构，time小的任务会排在堆顶（表示早 过期），每次出队都是取堆顶元素，这样快到期的任务就会被先执行。如果两个 ScheduledFutureTask的time相同，就比较它们的序号——sequenceNumber，序号小的代表先被提 交，所以就会先执行。</p>
<p>schedule的核心是其中的delayedExecute方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isShutdown())  </span><br><span class="line">        <span class="comment">// 线程池已关闭        </span></span><br><span class="line">        reject(task);   </span><br><span class="line">    <span class="comment">// 任务拒绝策略 </span></span><br><span class="line">    <span class="keyword">else</span> &#123;     </span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);  </span><br><span class="line">        <span class="comment">// 将任务入队</span></span><br><span class="line">        <span class="comment">// 如果线程池已关闭且该任务是非周期任务, 则将其从队列移除     </span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))            task.cancel(<span class="keyword">false</span>); </span><br><span class="line">        <span class="comment">// 取消任务    </span></span><br><span class="line">        <span class="keyword">else</span>       </span><br><span class="line">            ensurePrestart();  </span><br><span class="line">        <span class="comment">// 添加一个工作线程  </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理过程：</p>
<ul>
<li>任务被提交到线程池后，会判断线程池的状态，如果不是RUNNING状态会执行拒绝策略；</li>
<li>然后，将任务添加到阻塞队列中，由于DelayedWorkQueue是无界队列，所以一定会add成功；</li>
<li>然后，会创建一个工作线程，加入到核心线程池或者非核心线程池；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());  </span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        <span class="comment">//如果核心线程池未满，则新建的工作线程会被放到核心线程 池中。   </span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)  </span><br><span class="line">        <span class="comment">//当通过setCorePoolSize方法设置核心线程池大小为0时，这 里必须要保证任务能够被执行，会创建一个工作线程，放到非核心线程池中。    </span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">    <span class="comment">//如果核心线程池已经满了,不会再去创建工作线程,直接返回。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后，线程池中的工作线程会去任务队列获取任务并执行，当任务被执行完成后，如果该任务是周 期任务，则会重置time字段，并重新插入队列中，等待下次执行。 </p>
</li>
<li><p>从队列中获取元素的方法：</p>
<p>​         对于核心线程池中的工作线程来说，如果没有超时设置（ allowCoreThreadTimeOut == false ），则会使用阻塞方法take获取任务（因为没有超时限制，所以会一直等待直到队列中有 任务）；如果设置了超时，则会使用poll方法（方法入参需要超时时间），超时还没拿到任务的 话，该工作线程就会被回收。</p>
<p> 对于非工作线程来说，都是调用poll获取队列元素，超时取不到任务就会被回收。</p>
</li>
</ul>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;   </span><br><span class="line">        ScheduledThreadPoolExecutorTest.scheduleWithFixedDelay();      </span><br><span class="line">        ScheduledThreadPoolExecutorTest.scheduleAtFixedRate();  </span><br><span class="line">        ScheduledThreadPoolExecutorTest.scheduleCaller();       </span><br><span class="line">        ScheduledThreadPoolExecutorTest.scheduleRunable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务以固定时间间隔执行，延迟5s后开始执行任务，任务执行完毕后间隔5s再次执行，依次往 复  </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;      </span><br><span class="line">        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        ScheduledFuture&lt;?&gt; result = executorService.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;          </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">                </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;, <span class="number">5000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 由于是定时任务，一直不会返回   </span></span><br><span class="line">        result.get();     </span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 相对开始加入任务的时间点固定频率执行：从加入任务开始算2s后开始执行任务，2+5s开始 执行，2+2*5s执行，2+n*5s开始执行；    </span></span><br><span class="line">    <span class="comment">// 但是如果执行任务时间大于5s,则不会并发执行，后续任务将会延迟。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123; </span><br><span class="line">        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        ScheduledFuture&lt;?&gt; result = executorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">                </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;, <span class="number">2000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于是定时任务，一直不会返回 </span></span><br><span class="line">        result.get();   </span><br><span class="line">        System.out.println(<span class="string">"over"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延迟2s后开始执行，只执行一次，没有返回值</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleRunable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">        ScheduledFuture&lt;?&gt; result = executorService.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span>            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                System.out.println(<span class="string">"gh"</span>);                <span class="keyword">try</span> &#123;                    Thread.sleep(<span class="number">3000</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="comment">// TODO Auto-generated catch block                    e.printStackTrace();                &#125;</span></span><br><span class="line">            &#125;        &#125;, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延迟2s后开始执行，只执行一次，有返回值   </span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleCaller</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;  </span><br><span class="line">     ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">     </span><br><span class="line">        ScheduledFuture&lt;String&gt; result = executorService.schedule(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;          </span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);        </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block    </span></span><br><span class="line">                    e.printStackTrace();      </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"gh"</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 阻塞，直到任务执行完成    </span></span><br><span class="line">     </span><br><span class="line">     	System.out.print(result.get());</span><br><span class="line">     </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud Alibaba 之 Sentinel</title>
    <url>/2021/01/09/SpringCloud-Alibaba-%E4%B9%8B-Sentinel/</url>
    <content><![CDATA[<p>test</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring Cloud Alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程（二）</title>
    <url>/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="二、并发编程基础"><a href="#二、并发编程基础" class="headerlink" title="二、并发编程基础"></a>二、并发编程基础</h2><h4 id="2-1-临界资源"><a href="#2-1-临界资源" class="headerlink" title="2.1 临界资源"></a>2.1 临界资源</h4><p>临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资 源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间 采取互斥方式，实现对这种资源的共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;         </span><br><span class="line">         <span class="keyword">this</span>.count = <span class="keyword">this</span>.count + value;    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-线程安全"><a href="#2-2-线程安全" class="headerlink" title="2.2 线程安全"></a>2.2 线程安全</h4><h5 id="2-2-1-基本概念"><a href="#2-2-1-基本概念" class="headerlink" title="2.2.1 基本概念"></a>2.2.1 基本概念</h5><h6 id="竞态条件："><a href="#竞态条件：" class="headerlink" title="竞态条件："></a>竞态条件：</h6><p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。<br>导致竞态条件发生的代码区称作临界区。<br>在临界区中使用适当的同步就可以避免竞态条件，如使用synchronized或者加锁机制。</p>
<h6 id="线程安全："><a href="#线程安全：" class="headerlink" title="线程安全："></a>线程安全：</h6><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。</p>
<h5 id="2-2-2-对象的安全"><a href="#2-2-2-对象的安全" class="headerlink" title="2.2.2 对象的安全"></a>2.2.2 对象的安全</h5><h6 id="局部基本类型变量"><a href="#局部基本类型变量" class="headerlink" title="局部基本类型变量"></a>局部基本类型变量</h6><p>局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。</p>
<p>下面是基础类型的局部变量的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;        </span><br><span class="line">        MyThread share = <span class="keyword">new</span> MyThread();        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;           </span><br><span class="line">            <span class="keyword">new</span> Thread(share,<span class="string">"线程"</span>+i).start();        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> a =<span class="number">0</span>;        </span><br><span class="line">        ++a;       		</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+a); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>无论多少个线程对run()方法中的基本类型a执行++a操作，只是更新当前线程栈的值，不会影响其他线程，也就是不共享数据；</p>
<h6 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h6><p>对象的局部引用和基础类型的局部变量不太一样，尽管引用本身没有被共享，但引用所指的对象并没有 存储在线程的栈内。所有的对象都存在共享堆中。 如果在某个方法中创建的对象不会逃逸出（即该对象不会被其它方法获得，也不会被非局部变量引用 到）该方法，那么它就是线程安全的。 实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    LocalObject localObject = <span class="keyword">new</span> LocalObject();</span><br><span class="line">    localObject.callMethod();</span><br><span class="line">    method2(localObject); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(LocalObject localObject)</span></span>&#123;</span><br><span class="line">    localObject.setValue(<span class="string">"value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="对象成员-成员变量"><a href="#对象成员-成员变量" class="headerlink" title="对象成员(成员变量)"></a>对象成员(成员变量)</h6><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        NotThreadSafe sharedInstance = <span class="keyword">new</span> NotThreadSafe();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(sharedInstance)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(sharedInstance)).start();</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">     NotThreadSafe instance = <span class="keyword">null</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(NotThreadSafe instance)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.instance = instance;    </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.instance.add(<span class="string">" "</span>+Thread.currentThread().getName());</span><br><span class="line">         System.out.println(<span class="keyword">this</span>.instance.builder.toString());</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotThreadSafe</span></span>&#123;</span><br><span class="line">     StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String text)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.builder.append(text);    </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。</p>
<h5 id="2-2-3-不可变性"><a href="#2-2-3-不可变性" class="headerlink" title="2.2.3 不可变性"></a>2.2.3 不可变性</h5><p>通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableValue</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意ImmutableValue类的成员变量 value 是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value 变量就不能再被修改，这就是不可变性。但你可以通过 getValue()方法读取这个变量的值。</p>
<h4 id="2-3-Java内存模型"><a href="#2-3-Java内存模型" class="headerlink" title="2.3 Java内存模型"></a>2.3 Java内存模型</h4><p><strong>Java内存模型</strong>即<strong>Java Memory Model</strong>，简称<strong>JMM</strong>。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p>
<h6 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h6><p>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种共享内 存和消息传递。<br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐 式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。<br>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通 信，在java中典型的消息传递方式就是wait()和notify()。</p>
<h6 id="线程之间的同步"><a href="#线程之间的同步" class="headerlink" title="线程之间的同步"></a>线程之间的同步</h6><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。<br>在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间 互斥执行。<br>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<h6 id="Java的并发采用的是共享内存模型"><a href="#Java的并发采用的是共享内存模型" class="headerlink" title="Java的并发采用的是共享内存模型"></a>Java的并发采用的是共享内存模型</h6><p>Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h6 id="Java内存模型结构"><a href="#Java内存模型结构" class="headerlink" title="Java内存模型结构"></a>Java内存模型结构</h6><p>Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度 来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory） 中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量 的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img1.png"  alt></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。 </li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<h4 id="2-4-CAS乐观锁"><a href="#2-4-CAS乐观锁" class="headerlink" title="2.4 CAS乐观锁"></a>2.4 CAS乐观锁</h4><p><strong>乐观锁</strong>：不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。其实现方式有一种比较典型的就是Compare and Swap( CAS )。<br>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应 的值修改为B。<br>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属 于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p><strong>CAS的缺点：</strong></p>
<ol>
<li>CPU开销较大在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>
<li>不能保证代码块的原子性 CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量 共同进行原子性的更新，就不得不使用Synchronized了。</li>
</ol>
<h4 id="2-5-Synchronized块"><a href="#2-5-Synchronized块" class="headerlink" title="2.5 Synchronized块"></a>2.5 Synchronized块</h4><p>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上 的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执 行该同步块中的线程退出。</p>
<h5 id="有四种不同的同步块："><a href="#有四种不同的同步块：" class="headerlink" title="有四种不同的同步块："></a>有四种不同的同步块：</h5><ul>
<li><p>实例方法 </p>
</li>
<li><p>静态方法 </p>
</li>
<li><p>实例方法中的同步块 </p>
</li>
<li><p>静态方法中的同步块</p>
<p>上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。</p>
</li>
</ul>
<blockquote>
<h6 id="实例方法同步"><a href="#实例方法同步" class="headerlink" title="实例方法同步"></a>实例方法同步</h6></blockquote>
<p>下面是一个同步的实例方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count += value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在方法声明中同步（synchronized ）关键字。<br>Java实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上， 即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线 程一次可以在一个实例同步块中执行操作。</p>
<blockquote>
<h6 id="静态方法同步"><a href="#静态方法同步" class="headerlink" title="静态方法同步"></a>静态方法同步</h6></blockquote>
<p>静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123; </span><br><span class="line">    count += value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，这里synchronized 关键字告诉Java这个方法是同步的。<br>静态方法的同步是指同步在该方法所在的类对象上。因为在Java虚拟机中一个类只能对应一个类对象， 所以同时只允许一个线程执行同一个类中的静态同步方法。<br>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那 个静态同步方法被调用，一个类只能由一个线程同时执行。</p>
<blockquote>
<h6 id="实例方法中的同步块"><a href="#实例方法中的同步块" class="headerlink" title="实例方法中的同步块"></a>实例方法中的同步块</h6></blockquote>
<p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。<br>在非同步的Java方法中的同步块的例子如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.count += value;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。<br>注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本 身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。<br>一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。<br>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">       log.writeln(msg1);       </span><br><span class="line">       log.writeln(msg2);    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;       </span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;          </span><br><span class="line">           log.writeln(msg1);          </span><br><span class="line">           log.writeln(msg2);       </span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。<br>如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。</p>
<blockquote>
<h6 id="静态方法中的同步块"><a href="#静态方法中的同步块" class="headerlink" title="静态方法中的同步块"></a>静态方法中的同步块</h6></blockquote>
<p>和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">        log.writeln(msg1);       </span><br><span class="line">        log.writeln(msg2);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;       </span><br><span class="line">        <span class="keyword">synchronized</span>(MyClass<span class="class">.<span class="keyword">class</span>)</span>&#123;          </span><br><span class="line">            log.writeln(msg1);          </span><br><span class="line">            log.writeln(msg2);       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法不允许同时被线程访问。<br>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p>
<h5 id="Synchronized锁的存储"><a href="#Synchronized锁的存储" class="headerlink" title="Synchronized锁的存储"></a>Synchronized锁的存储</h5><p>synchronized用的锁存储在Java对象头，如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果 对象是非数组类型，则用2字宽存储对象头，32位虚拟机，1字宽等于4字节，即32位.</p>
<h6 id="Java对象头的长度"><a href="#Java对象头的长度" class="headerlink" title="Java对象头的长度"></a>Java对象头的长度</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img2.jpg"  alt></p>
<h6 id="Mark-Word的存储结构"><a href="#Mark-Word的存储结构" class="headerlink" title="Mark Word的存储结构"></a>Mark Word的存储结构</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img3.jpg"  alt></p>
<h6 id="Mark-Word可能的存储结果："><a href="#Mark-Word可能的存储结果：" class="headerlink" title="Mark Word可能的存储结果："></a>Mark Word可能的存储结果：</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img4.jpg"  alt></p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的获取流程：<br> （1）查看Mark Word中偏向锁的标识以及锁标志位，若是否偏向锁为1且锁标志位为01，则该锁为可偏向状态。<br> （2）若为可偏向状态，则测试Mark Word中的线程ID是否与当前线程相同，若相同，表示线程已经获得了锁，如果不同，则进入（3）<br> （3）测试Mark Word的偏向锁的标识是否设置为1，如果没有设置，则使用CAS操作竞争锁，如何设置 了，则尝试使用CAS尝试将Mark Word中线程ID设置为当前线程ID，如果尝试失败，则执行（4）<br> （4）当前线程通过CAS竞争锁失败的情况下，说明有竞争。当到达全局安全点（在这个时间点，没有 正在执行的代码）时之前获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线 程继续往下执行同步代码。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，使用轻量级锁能够减少性 能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁。<br>轻量级锁的加锁过程：<br>（1）当线程执行代码进入同步块时，若Mark Word为无锁状态，虚拟机先在当前线程的栈帧中建立一 个名为Lock Record的空间，用于存储当前对象的Mark Word的拷贝，官方称之为“Dispalced Mark Word”，此时状态如下图：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img5.jpg"  alt></p>
<p>（2）复制对象头中的Mark Word到锁记录中。<br>（3）复制成功后，虚拟机将用CAS操作将对象的Mark Word更新为执行Lock  Record的指针，并将 Lock Record里的owner指针指向对象的Mark Word。如果更新成功，则执行4，否则执行5。；<br>（4）如果更新成功，则这个线程拥有了这个锁，并将锁标志设为00，表示处于轻量级锁状态，此时状态图：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/img6.jpg"  alt></p>
<p>（5）如果更新失败，则说明有其他线程竞争锁，当前线程便通过自旋来获取锁。轻量级锁就会膨胀为 重量级锁，Mark Word中存储重量级锁（互斥锁）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>即当有其他线程占用锁时，当前线程会进入阻塞状态。</p>
<h4 id="2-6-关键字Volatile"><a href="#2-6-关键字Volatile" class="headerlink" title="2.6 关键字Volatile"></a>2.6 关键字Volatile</h4><p>Volatile是轻量级的synchronized,在多处理器环境下，可以保证共享变量的可见性。它不会引起线 程上下文的切换和调度，正确的使用Volatile,比synchronized的使用和执行成本更低。</p>
<h5 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h5><p>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改一 个共享变量时，另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。</p>
<p>volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但 是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比 如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原 子操作，也就是这个操作同样存在线程安全问题。<br>　　在 Java 中 volatile、synchronized 和 final 实现可见性。</p>
<h5 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h5><p>　　子是世界上的小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不 可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割 的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术 （sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的 concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如： AtomicInteger、AtomicLong、AtomicReference等。<br>　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p>
<h5 id="有序性："><a href="#有序性：" class="headerlink" title="有序性："></a>有序性：</h5><p>　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性， volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时 刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步 块只能串行执行。<br>　Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线 程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该 变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可 见的地方，因此在读取volatile类型的变量时总会返回新写入的值。<br>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是 一种比sychronized关键字更轻量级的同步机制。<br>当一个变量定义为 volatile 之后，将具备两种特性：<br>保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个 变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普 通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏 障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU 采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。</p>
<h4 id="2-7-本地线程"><a href="#2-7-本地线程" class="headerlink" title="2.7 本地线程"></a>2.7 本地线程</h4><p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个 ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变 量。<br>如何创建ThreadLocal变量<br>以下代码展示了如何创建一个ThreadLocal变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal();</span><br></pre></td></tr></table></figure>

<p>我们可以看到，通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却 只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个 ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。<br>如何访问ThreadLocal变量<br>一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myThreadLocal.set(<span class="string">"A thread local value”);</span></span><br></pre></td></tr></table></figure>

<p>可以通过下面方法读取保存在ThreadLocal变量中的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String threadLocalValue = (String) myThreadLocal.get();</span><br></pre></td></tr></table></figure>

<p>ThreadLocal例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            threadLocal.set((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D));            </span><br><span class="line">            <span class="keyword">try</span> &#123;            </span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;            </span><br><span class="line">            System.out.println(threadLocal.get());        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;         </span><br><span class="line">        MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        thread1.start();         </span><br><span class="line">        thread2.start();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子创建了一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行 run()方法，并且都在ThreadLocal实例上保存了不同的值。如果它们访问的不是ThreadLocal对象并 且调用的set()方法被同步了，则第二个线程会覆盖掉第一个线程设置的值。但是，由于它们访问的是 一个ThreadLocal对象，因此这两个线程都无法看到对方保存的值。也就是说，它们存取的是两个不同 的值。<br>关于InheritableThreadLocal<br>InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与 ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以 访问它保存的值。</p>
<h4 id="2-8、多线程问题"><a href="#2-8、多线程问题" class="headerlink" title="2.8、多线程问题"></a>2.8、多线程问题</h4><h5 id="2-8-1-死锁"><a href="#2-8-1-死锁" class="headerlink" title="2.8.1 死锁"></a>2.8.1 死锁</h5><h6 id="死锁的产生"><a href="#死锁的产生" class="headerlink" title="死锁的产生"></a>死锁的产生</h6><p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时 但以不同的顺序请求同一组锁的时候。<br>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这 时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事 情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p>
<h6 id="更复杂的死锁"><a href="#更复杂的死锁" class="headerlink" title="更复杂的死锁"></a>更复杂的死锁</h6><p>死锁可能不止包含2个线程，这让检测死锁变得更加困难。</p>
<p>线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。</p>
<h6 id="数据库的死锁"><a href="#数据库的死锁" class="headerlink" title="数据库的死锁"></a>数据库的死锁</h6><p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。当在一个事 务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。同一个事务 中每一个更新请求都可能会锁住一些记录。<br>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Transaction 1, request 1, locks record 1 for <span class="keyword">update</span> </span><br><span class="line"><span class="keyword">Transaction</span> <span class="number">2</span>, request <span class="number">1</span>, locks <span class="built_in">record</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">Transaction</span> <span class="number">1</span>, request <span class="number">2</span>, tries <span class="keyword">to</span> <span class="keyword">lock</span> <span class="built_in">record</span> <span class="number">2</span> <span class="keyword">for</span> update. </span><br><span class="line"><span class="keyword">Transaction</span> <span class="number">2</span>, request <span class="number">2</span>, tries <span class="keyword">to</span> <span class="keyword">lock</span> <span class="built_in">record</span> <span class="number">1</span> <span class="keyword">for</span> update.</span><br></pre></td></tr></table></figure>

<p>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。</p>
<h6 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h6><p><strong>加锁顺序</strong><br>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。<br>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread 1:  lock A   lock B</span><br><span class="line">Thread 2:   wait for A   lock C (when A locked)</span><br><span class="line">Thread 3:   wait for A   wait for B   wait for C</span><br></pre></td></tr></table></figure>

<p>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上 排在前面的锁之后，才能获取后面的锁。<br>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。<br>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者 注：并对这些锁做适当的排序)，但总有些时候是无法预知的。</p>
<p><strong>加锁时限</strong></p>
<p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过 程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的 锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让 其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加 锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。<br>以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread 1 locks A </span><br><span class="line">Thread 2 locks B</span><br><span class="line">Thread 1 attempts to lock B but is blocked</span><br><span class="line">Thread 2 attempts to lock A but is blocked</span><br><span class="line">Thread 1&#39;s lock attempt on B times out </span><br><span class="line">Thread 1 backs up and releases A as well </span><br><span class="line">Thread 1 waits randomly (e.g. 257 millis) before retrying.</span><br><span class="line">Thread 2&#39;s lock attempt on A times out</span><br><span class="line">Thread 2 backs up and releases B as well </span><br><span class="line">Thread 2 waits randomly (e.g. 43 millis) before retrying.</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时， 线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2 或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。<br>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。</p>
<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些 线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间， 这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间 的概率就高的多（或者非常接近以至于会出现问题）。</p>
<p><code>**这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。**</code></p>
<p><strong>死锁检测</strong></p>
<p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。<br>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外， 每当有线程请求锁，也需要记录在这个数据结构中。<br>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7， 但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请 求锁1）。<br>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线 程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自 己持有着。这是它就知道发生了死锁。</p>
<p><strong><em>那么当检测出死锁时，这些线程该做些什么呢？</em></strong></p>
<p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似， 不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。<br>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一 样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的 优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</p>
<h5 id="2-8-2-饥饿和公平"><a href="#2-8-2-饥饿和公平" class="headerlink" title="2.8.2 饥饿和公平"></a>2.8.2 饥饿和公平</h5><p><strong><em>如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。</em></strong>而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。<strong>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。</strong></p>
<h6 id="Java中导致饥饿的原因"><a href="#Java中导致饥饿的原因" class="headerlink" title="Java中导致饥饿的原因"></a>Java中导致饥饿的原因</h6><p>在Java中，下面三个常见的原因会导致线程饥饿：</p>
<ul>
<li><p>高优先级线程吞噬所有的低优先级线程的CPU时间 </p>
<p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你好是不要改变其优先级值。 </p>
</li>
<li><p>线程被永久堵塞在一个等待进入同步块的状态 </p>
<p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p>
</li>
<li><p>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象 </p>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程（一）</title>
    <url>/2021/01/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、并发编程入门"><a href="#一、并发编程入门" class="headerlink" title="一、并发编程入门"></a>一、并发编程入门</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><h4 id="1-1-1进程和线程进程"><a href="#1-1-1进程和线程进程" class="headerlink" title="1.1.1进程和线程进程"></a>1.1.1进程和线程进程</h4><p><strong>进程</strong>：</p>
<p>进程指正在运行的程序，进程拥有一个完整的、私有的基本运行资源集合。通常，每个进程都有</p>
<p>自己的内存空间。</p>
<p>进程往往被看作是程序或应用的代名词，然而，用户看到的一个单独的应用程序实际上可能是一组相互 协作的进程集合。</p>
<p>为了便于进程之间的通信，大多数操作系统都支持进程间通信（IPC），如pipes 和sockets。IPC不仅支持同一系统上的通信，也支持不同的系统。IPC通信方式包括管道（包括无名管道和命名管道）、 消息队列、信号量、共享存储、Socket、Streams等方式，其中  Socket和Streams支持不同主机上的两个进程IPC。</p>
<p><strong>线程</strong>：</p>
<p>线程有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。</p>
<p>线程是在进程中存在的 — 每个进程最少有一个线程。线程共享进程的资源，包括内存和打开的文件。这样提高了效率，但潜在的问题就是线程间的通信。</p>
<p>多线程的执行是Java平台的一个基本特征。每个应用都至少有一个线程 – 或几个，如果算上“系</p>
<p>统”线程的话，比如内存管理和信号处理等。但是从程序员的角度来看，启动的只有一个线程，叫主线 程。</p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</p>
<h4 id="1-1-2-线程实践"><a href="#1-1-2-线程实践" class="headerlink" title="1.1.2 线程实践"></a>1.1.2 线程实践</h4><h5 id="1-1-2-1-线程的创建"><a href="#1-1-2-1-线程的创建" class="headerlink" title="1.1.2.1 线程的创建"></a>1.1.2.1 线程的创建</h5><p>两种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"Hello from a thread!"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;        </span><br><span class="line">        (<span class="keyword">new</span> HelloThread()).start();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"Hello from a thread!"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;        </span><br><span class="line">        (<span class="keyword">new</span> Thread(<span class="keyword">new</span> HelloRunnable())).start();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-2-线程启动和停止"><a href="#1-1-2-2-线程启动和停止" class="headerlink" title="1.1.2.2 线程启动和停止"></a>1.1.2.2 线程启动和停止</h5><p><strong>启动线程</strong>：调用start方法</p>
<p><strong>停止线程</strong>：线程自带的stop方法，一方面已经过时，另一方面，不会对停止的线程做状态保存，使得线程中涉及的 对象处于未知状态，如果这些状态，其他线程也会使用，将会使得其他线程出现无法预料的异常，所   以，停止程序的功能，需要自己实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopThread thread = <span class="keyword">new</span> StopThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">        <span class="keyword">while</span> (thread.isAlive()) &#123;&#125;        </span><br><span class="line">        thread.print();    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;                </span><br><span class="line">                ++x;                </span><br><span class="line">                <span class="keyword">try</span> &#123;                    </span><br><span class="line">                    Thread.sleep(<span class="number">3000L</span>);                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();                </span><br><span class="line">                &#125;</span><br><span class="line">                ++y;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"x="</span> + x + <span class="string">" y="</span> + y);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，run方法里是一个同步的原子操作，x和y必须要共同增加，然而这里如果调用 thread.stop()方法强制中断线程，输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>没有异常，也破坏了我们的预期。如果这种问题出现在我们的程序中，会引发难以预期的异常。因此这 种不安全的方式很早就被废弃了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> doStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doStop = <span class="keyword">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">keepRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doStop == <span class="keyword">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">while</span>(keepRunning()) &#123;            </span><br><span class="line">            <span class="comment">// keep doing what this thread should do. </span></span><br><span class="line">            System.out.println(<span class="string">"Running"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                Thread.sleep(<span class="number">3L</span> * <span class="number">1000L</span>);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            Thread.sleep(<span class="number">10L</span> * <span class="number">1000L</span>);        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            </span><br><span class="line">            e.printStackTrace();        </span><br><span class="line">        &#125;</span><br><span class="line">        myRunnable.doStop();   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-3-线程暂停和中断"><a href="#1-1-2-3-线程暂停和中断" class="headerlink" title="1.1.2.3 线程暂停和中断"></a>1.1.2.3 线程暂停和中断</h5><p><strong>暂停</strong>：<br>Java中线程的暂停是调用 java.lang.Thread 类的 sleep 方法。该方法会使当前正在执行的线程暂停 指定的一段时间，如果线程持有锁， sleep 方法结束前并不会释放该锁。<br><strong>中断</strong>：<br>java.lang.Thread类有一个 interrupt 方法，该方法直接对线程调用。当被interrupt的线程正在 sleep或wait时，会抛出 InterruptedException 异常。 事实上， interrupt 方法只是改变目标线程的中断状态（interrupt status），而那些会抛出 InterruptedException 异常的方法，如wait、sleep、join等，都是在方法内部不断地检查中断状 态的值。</p>
<ul>
<li><strong>interrupt方法</strong><br>Thread实例方法：必须由其它线程获取被调用线程的实例后，进行调用。实际上，只是改变了被调用线 程的内部中断状态；</li>
<li><strong>Thread.interrupted方法</strong><br>Thread类方法：必须在当前执行线程内调用，该方法返回当前线程的内部中断状态，然后清除中断状态 （置为false） ；</li>
<li><strong>isInterrupted方法</strong><br>Thread实例方法：用来检查指定线程的中断状态。当线程为中断状态时，会返回true；否则返回 false。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopThread thread = <span class="keyword">new</span> StopThread();        </span><br><span class="line">        thread.start();        </span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);        </span><br><span class="line">        thread.interrupt();        </span><br><span class="line">        <span class="keyword">while</span> (thread.isAlive()) &#123; &#125;        </span><br><span class="line">        thread.print();    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;                </span><br><span class="line">                ++x;                </span><br><span class="line">                <span class="keyword">try</span> &#123;                    </span><br><span class="line">                    Thread.sleep(<span class="number">3000L</span>);                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();                </span><br><span class="line">                &#125;                </span><br><span class="line">                ++y;           </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"x="</span> + x + <span class="string">" y="</span> + y);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x=<span class="number">1</span> y=<span class="number">1</span> </span><br><span class="line">    java.lang.InterruptedException: sleep interrupted    </span><br><span class="line">        at java.lang.Thread.sleep(Native Method)    </span><br><span class="line">        at ThreadTest$StopThread.run(ThreadTest.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure>

<p>x=1,y=1 这个结果是符合我们的预期，同时还抛出了个异常。</p>
<p>底层源码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 核心 interrupt 方法   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) <span class="comment">// 非本线程，需要检查权限</span></span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;            </span><br><span class="line">            Interruptible b = blocker;            </span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;                </span><br><span class="line">                interrupt0();           <span class="comment">// 仅仅设置interrupt标志位</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);    <span class="comment">// 调用如 I/O 操作定义的中断方法</span></span><br><span class="line">                <span class="keyword">return</span>;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">    interrupt0();    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 静态方法，这个方法有点坑，调用该方法调用后会清除中断状态。    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 这个方法不会清除中断状态    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);    </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 上面两个方法会调用这个本地方法，参数代表是否清除中断状态   </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>interrupt() ：</strong></p>
<ul>
<li><p>interrupt 中断操作时，非自身打断需要先检测是否有中断权限，这由jvm的安全机制配置； </p>
</li>
<li><p>如果线程处于sleep, wait, join 等状态，那么线程将立即退出被阻塞状态，并抛出一个 InterruptedException异常； </p>
</li>
<li><p>如果线程处于I/O阻塞状态，将会抛出ClosedByInterruptException（IOException的子类）异常； </p>
</li>
<li><p>如果线程在Selector上被阻塞，select方法将立即返回；</p>
</li>
<li><p>如果非以上情况，将直接标记 interrupt 状态；</p>
</li>
</ul>
<p>  注意：interrupt 操作不会打断所有阻塞，只有上述阻塞情况才在jvm的打断范围内，如处于锁阻塞的 线程，不会受 interrupt 中断；<br>  阻塞情况下中断，抛出异常后线程恢复非中断状态，即 interrupted = false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        </span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"mytask"</span>));        </span><br><span class="line">        t.start();        </span><br><span class="line">        t.interrupt();    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;        </span><br><span class="line">        String name;                </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;            </span><br><span class="line">            <span class="keyword">this</span>.name = name;        </span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread has been interrupt!"</span>);</span><br><span class="line">            &#125;            </span><br><span class="line">            System.out.println(<span class="string">"isInterrupted: "</span> + </span><br><span class="line">                               Thread.currentThread().isInterrupted());            </span><br><span class="line">            System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread has been interrupt! </span><br><span class="line">isInterrupted: <span class="keyword">false</span> </span><br><span class="line">task <span class="number">1</span> is over</span><br></pre></td></tr></table></figure>

<p>调用Thread.interrupted() 方法后线程恢复非中断状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        </span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">"mytask"</span>));        </span><br><span class="line">        t.start();        </span><br><span class="line">        t.interrupt();    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;        </span><br><span class="line">        String name;                </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;            </span><br><span class="line">            <span class="keyword">this</span>.name = name;        </span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            System.out.println(<span class="string">"first :"</span> + Thread.interrupted());</span><br><span class="line">            System.out.println(<span class="string">"second:"</span> + Thread.interrupted());</span><br><span class="line">			System.out.println(<span class="string">"task "</span> + name + <span class="string">" is over"</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first :<span class="keyword">true</span> </span><br><span class="line">second:<span class="keyword">false</span> </span><br><span class="line">task <span class="number">1</span> is o</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-4-线程的状态"><a href="#1-1-2-4-线程的状态" class="headerlink" title="1.1.2.4 线程的状态"></a>1.1.2.4 线程的状态</h5><p>Java线程可能的状态：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/img1.jpg"  alt></p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2021/01/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/img2.jpg"  alt></p>
<h3 id="1-2-多线程"><a href="#1-2-多线程" class="headerlink" title="1.2 多线程"></a>1.2 多线程</h3><p>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>
<h4 id="1-2-1-并发和并行"><a href="#1-2-1-并发和并行" class="headerlink" title="1.2.1 并发和并行"></a>1.2.1 并发和并行</h4><ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 </li>
<li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</li>
</ul>
<h4 id="1-2-2-多线程好处"><a href="#1-2-2-多线程好处" class="headerlink" title="1.2.2 多线程好处"></a>1.2.2 多线程好处</h4><p>提高cpu的利用率</p>
<p><strong>单线程：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 seconds reading file A  </span><br><span class="line">2 seconds processing file A  </span><br><span class="line">5 seconds reading file B  </span><br><span class="line">2 seconds processing file B </span><br><span class="line">---------------------- </span><br><span class="line">14 seconds total</span><br></pre></td></tr></table></figure>

<p><strong>多线程：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 seconds reading file A  </span><br><span class="line">5 seconds reading file B + </span><br><span class="line">2 seconds processing file A  </span><br><span class="line">2 seconds processing file B </span><br><span class="line">---------------------- </span><br><span class="line">12 seconds total</span><br></pre></td></tr></table></figure>

<p>一般来说，在等待磁盘IO，网络IO或者等待用户输入时，CPU可以同时去处理其他任务。</p>
<p><strong>更高效的响应</strong></p>
<p>多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态，不会 造成无法响应的现象。</p>
<p><strong>公平使用CPU资源</strong></p>
<p>当前没有进行处理的任务，可以将处理器时间让给其它任务;占用大量处理时间的任务，也可以定期将 处理器时间让给其它任务;通过对CPU时间的划分，使得CPU时间片可以在多个线程之间切换，避免需要 长时间处理的线程独占CPU，导致其它线程长时间等待。</p>
<h5 id="1-2-3-多线程的代价"><a href="#1-2-3-多线程的代价" class="headerlink" title="1.2.3 多线程的代价"></a>1.2.3 多线程的代价</h5><p>*<em>更复杂的设计 *</em></p>
<p>共享数据的读取，数据的安全性，线程之间的交互，线程的同步等；</p>
<p><strong>上下文环境切换</strong></p>
<p>线程切换，cpu需要保存本地数据、程序指针等内容；</p>
<p><strong>更多的资源消耗</strong></p>
<p>每个线程都需要内存维护自己的本地栈信息，操作系统也需要资源对线程进行管理维护；</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 相关知识及使用(一)</title>
    <url>/2020/12/27/Dubbo%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%80/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dubbo官网地址：http:&#x2F;&#x2F;dubbo.apache.org</span><br><span class="line">官网有详细的文档可供学习，并且有中文的。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td align="center">Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td align="center">Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td align="center">Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td align="center">Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<p>简单的描述一下调用关系：</p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。 </li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。 </li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。 </li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数 据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用 失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<hr>
<h3 id="Dubbo快速开发"><a href="#Dubbo快速开发" class="headerlink" title="Dubbo快速开发"></a>Dubbo快速开发</h3><h5 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备:"></a>环境准备:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database dubbo;</span><br><span class="line">CREATE TABLE &#96;t_user&#96; (  </span><br><span class="line">    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;name&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">    &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<h5 id="创建父工程："><a href="#创建父工程：" class="headerlink" title="创建父工程："></a>创建父工程：</h5><p>​    父工程，不实现任何代码，主要是添加工程需要的库的依赖管理（DependencyManagement）， 依赖管理就是解决项目中多个模块间公共依赖的版本号、scope的控制范围。本项目需要使用spring-webmvc，使用dubbo（务必2.6.2以上版本）、zookeeper及其客户端（curator-framework）依赖库。</p>
<p>​    修改pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.frosro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo_common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo_interface<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo_provider<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo_consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql-connector-java.version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">mysql-connector-java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.20<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis-spring.version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">mybatis-spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zookeeper.version</span>&gt;</span>3.4.7<span class="tag">&lt;/<span class="name">zookeeper.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">curator.version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">curator.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo.version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">dubbo.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jackson.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">jackson.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--管理jar包, 在当前工程中不进行jar包加载, 只是管理版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--与数据库相关的jar--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--与Mybatis相关的--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--Spring相关的jar--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--dubbo,ZooKeeper相关的jar--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zookeeper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--servlet相关的jar--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--解析json相关的jar--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="创建公共子模块："><a href="#创建公共子模块：" class="headerlink" title="创建公共子模块："></a>创建公共子模块：</h5><p>​        不选择工程模板，在父工程内部创建子模块，命名为 dubbo_common 。主要放公共类的定义，它是接口子模块的依赖模块。</p>
<h6 id="pom-xml内容："><a href="#pom-xml内容：" class="headerlink" title="pom.xml内容："></a>pom.xml内容：</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.frosro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="在java文件夹下创建包：com-frosro-pojo，并添加User类："><a href="#在java文件夹下创建包：com-frosro-pojo，并添加User类：" class="headerlink" title="在java文件夹下创建包：com.frosro.pojo，并添加User类："></a>在java文件夹下创建包：com.frosro.pojo，并添加User类：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frosro.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 15:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;<span class="comment">//必须实现Serializable接口，序列化。为了网络传输。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建接口子模块："><a href="#创建接口子模块：" class="headerlink" title="创建接口子模块："></a>创建接口子模块：</h5><pre><code>此模块，主要是放业务接口的定义，它是服务消费者模块和服务提供者模块的公共依赖模块。命名为:dubbo_interface，同样也是在父工程内部创建。 </code></pre><h6 id="pom-xml文件："><a href="#pom-xml文件：" class="headerlink" title="pom.xml文件："></a>pom.xml文件：</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.frosro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.frosro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在java文件夹下创建com.frosro.service包，并创建接口类：UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frosro.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.frosro.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 16:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务提供者模块："><a href="#服务提供者模块：" class="headerlink" title="服务提供者模块："></a>服务提供者模块：</h5><p>此模块是服务提供者模块，需要在容器启动时，把服务注册到zookeeper,故需要引入springwebmvc,zookeeper及客户端依赖。 </p>
<p>使用webapp模板工程创建子模块<strong>dubbo_provider</strong></p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2020/12/27/Dubbo%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%80/1609161306(1).png"  alt="1"></p>
<h6 id="在pom-xml中添加必要依赖："><a href="#在pom-xml中添加必要依赖：" class="headerlink" title="在pom.xml中添加必要依赖："></a>在pom.xml中添加必要依赖：</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.frosro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.frosro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            这里导入的dubbo_interface中包含了dubbo_common所以不再导入--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>dubbo_provider<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h6 id="初始化java资源目录"><a href="#初始化java资源目录" class="headerlink" title="初始化java资源目录"></a>初始化java资源目录</h6><h6 id="在java文件夹下创建com-frosro-dao包并创建接口类UserDao："><a href="#在java文件夹下创建com-frosro-dao包并创建接口类UserDao：" class="headerlink" title="在java文件夹下创建com.frosro.dao包并创建接口类UserDao："></a>在java文件夹下创建com.frosro.dao包并创建接口类UserDao：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frosro.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.frosro.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 16:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="然后在resources资源目录下同样创建com-frosro-dao包并增加UserDao-xml文件"><a href="#然后在resources资源目录下同样创建com-frosro-dao包并增加UserDao-xml文件" class="headerlink" title="然后在resources资源目录下同样创建com.frosro.dao包并增加UserDao.xml文件"></a>然后在resources资源目录下同样创建com.frosro.dao包并增加UserDao.xml文件</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.frosro.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">resultType</span>=<span class="string">"com.frosro.pojo.User"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select * from t_user where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="这里要添加UserService的具体实现，在com-frosro-service下添加UserServiceImpl实现类："><a href="#这里要添加UserService的具体实现，在com-frosro-service下添加UserServiceImpl实现类：" class="headerlink" title="这里要添加UserService的具体实现，在com.frosro.service下添加UserServiceImpl实现类："></a>这里要添加UserService的具体实现，在com.frosro.service下添加UserServiceImpl实现类：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frosro.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.frosro.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.frosro.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 16:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@Service 这是springmvc的注解</span></span><br><span class="line">    <span class="meta">@Service</span><span class="comment">// 换成dubbo的service注解，相应xml配置中换成包扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在resources目录下创建其他的一些配置文件："><a href="#在resources目录下创建其他的一些配置文件：" class="headerlink" title="在resources目录下创建其他的一些配置文件："></a>在resources目录下创建其他的一些配置文件：</h6><p>dubbo的配置文件：spring-dubbo.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    给提供者起个名字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo_provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--     &lt;dubbo:registry address="zookeeper://39.106.92.113:2181"/&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    zk的地址，这里表示的是一个zk集群，如果是单机话，可以写成上面那样--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"192.168.234.130:2181,192.168.234.131:2181,192.168.234.132:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    暴露服务的地址    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;dubbo:service interface="com.frosro.service.UserService" ref="userServiceImpl"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    dubbo的service注解的包扫描，与上面作用一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.frosro.service"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h6 id="spring的配置文件spring-xml"><a href="#spring的配置文件spring-xml" class="headerlink" title="spring的配置文件spring.xml"></a>spring的配置文件spring.xml</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载属性文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"druidDataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置SQLSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"druidDataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Mapper文件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"scannerConfigurer"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.frosro.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"druidDataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--事务注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自动扫包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.frosro.service"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>log4j的配置文件 log4j.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### direct log messages to stdout ###</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Target</span>=<span class="string">System.err</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug, stdout</span></span><br></pre></td></tr></table></figure>



<p>数据库连接的 jdbc.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/dubbo</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>



<p>在webapp/WEB-INF下的web.xml内:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="提供者的整体文件结构如下："><a href="#提供者的整体文件结构如下：" class="headerlink" title="提供者的整体文件结构如下："></a>提供者的整体文件结构如下：</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2020/12/27/Dubbo%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%80/1609163369(1).png"  alt="2"></p>
<h5 id="下面创建消费者模块dubbo-consumer："><a href="#下面创建消费者模块dubbo-consumer：" class="headerlink" title="下面创建消费者模块dubbo-consumer："></a>下面创建消费者模块dubbo-consumer：</h5><p>同样使用webapp的工程模板进行创建</p>
<h6 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.frosro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.frosro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo_interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>dubbo_consumer<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9999<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在java目录下创建com.frosro.controller包，并且创建UserController类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frosro.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.frosro.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.frosro.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 16:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line">    <span class="meta">@Reference</span> <span class="comment">//这是dubbo的@Reference标签,代替@Autowired 并且 去掉了xml 中的 dubbo:reference 配置</span></span><br><span class="line">   <span class="keyword">public</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findById"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在resources文件夹下创建："><a href="#在resources文件夹下创建：" class="headerlink" title="在resources文件夹下创建："></a>在resources文件夹下创建：</h6><p>spring-dubbo.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo_consumer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"192.168.234.130:2181,192.168.234.131:2181,192.168.234.132:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;dubbo:reference interface="com.frosro.service.UserService" id="userService"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    开启controller包内的注解扫描,将上面 dubbo:reference 改为注解形式  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.frosro.controller"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自动扫包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.frosro.controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="webapp下的web-xml文件："><a href="#webapp下的web-xml文件：" class="headerlink" title="webapp下的web.xml文件："></a>webapp下的web.xml文件：</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h5 id="下面启动虚拟机"><a href="#下面启动虚拟机" class="headerlink" title="下面启动虚拟机"></a>下面启动虚拟机</h5><h6 id="我通过MobaXterm进行连接，开启内部安装的zk集群。"><a href="#我通过MobaXterm进行连接，开启内部安装的zk集群。" class="headerlink" title="我通过MobaXterm进行连接，开启内部安装的zk集群。"></a>我通过MobaXterm进行连接，开启内部安装的zk集群。</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2020/12/27/Dubbo%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%80/1609164240(1).png"  alt="3"></p>
<h6 id="开启后进去zk的客户端"><a href="#开启后进去zk的客户端" class="headerlink" title="开启后进去zk的客户端"></a>开启后进去zk的客户端</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2020/12/27/Dubbo%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%80/1609164557(1).png"  alt="4"></p>
<h6 id="这个时候消费者和提供者内部都是空的，分别启动提供者和消费者的tomcat插件；"><a href="#这个时候消费者和提供者内部都是空的，分别启动提供者和消费者的tomcat插件；" class="headerlink" title="这个时候消费者和提供者内部都是空的，分别启动提供者和消费者的tomcat插件；"></a>这个时候消费者和提供者内部都是空的，分别启动提供者和消费者的tomcat插件；</h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2020/12/27/Dubbo%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%80/1609164667(1).png"  alt="5"></p>
<p>现在可以看到zk上dubbo里有值了</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2020/12/27/Dubbo%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%80/1609164804(1).png"  alt="6"></p>
<h6 id="此时我们可以用http-localhost-9999-user-findById-do-id-1访问消费者，可以获取数据库内的值"><a href="#此时我们可以用http-localhost-9999-user-findById-do-id-1访问消费者，可以获取数据库内的值" class="headerlink" title="此时我们可以用http://localhost:9999/user/findById.do?id=1访问消费者，可以获取数据库内的值"></a>此时我们可以用<a href="http://localhost:9999/user/findById.do?id=1访问消费者，可以获取数据库内的值" target="_blank" rel="noopener">http://localhost:9999/user/findById.do?id=1访问消费者，可以获取数据库内的值</a></h6><p><img src="/img/loading.gif" class="lazyload" data-src="/2020/12/27/Dubbo%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%80/1609164929(1).png"  alt="7"></p>
]]></content>
      <categories>
        <category>🐂框架</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>RPC</tag>
        <tag>框架</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>重启</title>
    <url>/2020/12/23/%E9%87%8D%E5%90%AF/</url>
    <content><![CDATA[<hr>
<p>​        快到2021年了，从九月份开始到现在，大概四个月的时间了，我逐渐适应了新的环境和工作，虽然还有很多欠缺，不管是在业务上还是技术上。但这是一个不错的开始。</p>
<p>​        接下来，我会将空闲的时间全部投入到学习中，争取来年能有更大的进步。并且会逐步恢复学习笔记的记录，记录下那些工作或者学习上的难点。</p>
<p>​        <del>~</del>！go    </p>
]]></content>
      <categories>
        <category>🐟台小记</category>
      </categories>
      <tags>
        <tag>历程</tag>
      </tags>
  </entry>
  <entry>
    <title>转战成都</title>
    <url>/2020/08/26/%E8%BD%AC%E6%88%98%E6%88%90%E9%83%BD/</url>
    <content><![CDATA[<p>2020年8月24日   星期一   晴</p>
<p>我进入了新的工作环境，是中软的外包平安线，不可否认，这可能不是一份好工作，但工资我还是觉得较为可观，每天也不需要加班，一切都是为了生活。</p>
<p>项目用的是我不熟悉的技术，</p>
<p>数据库是Orcal，我觉得我可以好好学一下，毕竟这是世界上顶级的数据库。</p>
<p>服务器不再是Tomcat，而是WebLogic，也有必要好好了解一下看。</p>
<p>还有一些其他的东西；</p>
<p>这个人事管理系统目前分为老版本和新版本，还有一个移动端。</p>
<p>目前我只看到了老版本的代码，希望可以从中学到不少有用的知识。</p>
]]></content>
      <categories>
        <category>🐟台小记</category>
      </categories>
      <tags>
        <tag>历程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java synchronized原理总结</title>
    <url>/2020/07/26/Java-synchronized%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>我觉得并不会比他写得好：</p>
<p><a href="https://zhuanlan.zhihu.com/p/29866981" target="_blank" rel="noopener">点击此处</a></p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>synchronized</tag>
        <tag>锁</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>java JVM 知识检验</title>
    <url>/2020/07/19/java-JVM-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-说一下-JVM-的主要组成部分？及其作用？"><a href="#1-说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="1. 说一下 JVM 的主要组成部分？及其作用？"></a><strong>1.</strong> <strong>说一下</strong> <strong>JVM</strong> <strong>的主要组成部分？及其作用？</strong></h4><p>·    类加载器（ClassLoader）</p>
<p>·    运行时数据区（Runtime Data Area）</p>
<p>·    执行引擎（Execution Engine）</p>
<p>·    本地库接口（Native Interface）</p>
<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h4 id="2-说一下-JVM-运行时数据区？"><a href="#2-说一下-JVM-运行时数据区？" class="headerlink" title="2. 说一下 JVM 运行时数据区？"></a><strong>2.</strong> <strong>说一下</strong> <strong>JVM</strong> <strong>运行时数据区？</strong></h4><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<p>·   程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p>
<p>·   Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p>
<p>·   本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p>
<p>·   Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</p>
<p>·   方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>
<h4 id="3-说一下堆栈的区别？"><a href="#3-说一下堆栈的区别？" class="headerlink" title="3. 说一下堆栈的区别？"></a><strong>3.</strong> <strong>说一下堆栈的区别？</strong></h4><p>·    功能方面：堆是用来存放对象的，栈是用来执行程序的。</p>
<p>·    共享性：堆是线程共享的，栈是线程私有的。</p>
<p>·    空间大小：堆大小远远大于栈。</p>
<h4 id="4-队列和栈是什么？有什么区别？"><a href="#4-队列和栈是什么？有什么区别？" class="headerlink" title="4. 队列和栈是什么？有什么区别？"></a><strong>4.</strong> <strong>队列和栈是什么？有什么区别？</strong></h4><p>队列和栈都是被用来预存储数据的。</p>
<p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p>
<p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
<h4 id="5-什么是双亲委派模型？"><a href="#5-什么是双亲委派模型？" class="headerlink" title="5. 什么是双亲委派模型？"></a><strong>5.</strong> <strong>什么是双亲委派模型？</strong></h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<p>·    启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</p>
<p>·    其他类加载器：</p>
<p>·    扩展类加载器（Extension ClassLoader）：负责加载<java_home>\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home></p>
<p>·    应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h4 id="6-说一下类装载的执行过程？"><a href="#6-说一下类装载的执行过程？" class="headerlink" title="6. 说一下类装载的执行过程？"></a><strong>6.</strong> <strong>说一下类装载的执行过程？</strong></h4><p>类装载分为以下 5 个步骤：</p>
<p>·    加载：根据查找路径找到相应的 class 文件然后导入；</p>
<p>·    检查：检查加载的 class 文件的正确性；</p>
<p>·    准备：给类中的静态变量分配内存空间；</p>
<p>·    解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</p>
<p>·    初始化：对静态变量和静态代码块执行初始化工作。</p>
<h4 id="7-怎么判断对象是否可以被回收？"><a href="#7-怎么判断对象是否可以被回收？" class="headerlink" title="7. 怎么判断对象是否可以被回收？"></a><strong>7.</strong> <strong>怎么判断对象是否可以被回收？</strong></h4><p>一般有两种方法来判断：</p>
<p>·    引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</p>
<p>·    可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>
<h4 id="8-Java-中都有哪些引用类型？"><a href="#8-Java-中都有哪些引用类型？" class="headerlink" title="8. Java 中都有哪些引用类型？"></a><strong>8. Java</strong> <strong>中都有哪些引用类型？</strong></h4><p>·    强引用：发生 gc 的时候不会被回收。</p>
<p>·    软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</p>
<p>·    弱引用：有用但不是必须的对象，在下一次GC时会被回收。</p>
<p>·    虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p>
<h4 id="9-说一下-JVM-有哪些垃圾回收算法？"><a href="#9-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="9. 说一下 JVM 有哪些垃圾回收算法？"></a><strong>9.</strong> <strong>说一下</strong> <strong>JVM</strong> <strong>有哪些垃圾回收算法？</strong></h4><p>·    标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p>
<p>·    标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p>
<p>·    复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p>
<p>·    分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p>
<h4 id="10-说一下-JVM-有哪些垃圾回收器？"><a href="#10-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="10. 说一下 JVM 有哪些垃圾回收器？"></a><strong>10.</strong> <strong>说一下</strong> <strong>JVM</strong> <strong>有哪些垃圾回收器？</strong></h4><p>·    Serial：最早的单线程串行垃圾回收器。</p>
<p>·    Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</p>
<p>·    ParNew：是 Serial 的多线程版本。</p>
<p>·    Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</p>
<p>·    Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</p>
<p>·    CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</p>
<p>·    G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p>
<h4 id="11-详细介绍一下-CMS-垃圾回收器？"><a href="#11-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="11. 详细介绍一下 CMS 垃圾回收器？"></a><strong>11.</strong> <strong>详细介绍一下</strong> <strong>CMS</strong> <strong>垃圾回收器？</strong></h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h4 id="12-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#12-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a><strong>12.</strong> <strong>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</strong></h4><p>·    新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>·    老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>·    整堆回收器：G1</p>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h4 id="13-简述分代垃圾回收器是怎么工作的？"><a href="#13-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="13. 简述分代垃圾回收器是怎么工作的？"></a><strong>13.</strong> <strong>简述分代垃圾回收器是怎么工作的？</strong></h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<p>·    把 Eden + From Survivor 存活的对象放入 To Survivor 区；</p>
<p>·    清空 Eden 和 From Survivor 分区；</p>
<p>·    From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</p>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h4 id="14-说一下-JVM-调优的工具？"><a href="#14-说一下-JVM-调优的工具？" class="headerlink" title="14. 说一下 JVM 调优的工具？"></a><strong>14.</strong> <strong>说一下</strong> <strong>JVM</strong> <strong>调优的工具？</strong></h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>·    jconsole：用于对 JVM 中的内存、线程和类等进行监控；</p>
<p>·    jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h4 id="15-常用的-JVM-调优的参数都有哪些？"><a href="#15-常用的-JVM-调优的参数都有哪些？" class="headerlink" title="15. 常用的 JVM 调优的参数都有哪些？"></a><strong>15.</strong> <strong>常用的</strong> <strong>JVM</strong> <strong>调优的参数都有哪些？</strong></h4><p>·    -Xms2g：初始化推大小为 2g；</p>
<p>·    -Xmx2g：堆最大内存为 2g；</p>
<p>·    -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</p>
<p>·    -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</p>
<p>·    –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</p>
<p>·    -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</p>
<p>·    -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</p>
<p>·    -XX:+PrintGC：开启打印 gc 信息；</p>
<p>·    -XX:+PrintGCDetails：打印 gc 详细信息。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>java Redis 知识检验</title>
    <url>/2020/07/19/java-Redis-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-Redis-是什么？都有哪些使用场景？"><a href="#1-Redis-是什么？都有哪些使用场景？" class="headerlink" title="1. Redis 是什么？都有哪些使用场景？"></a><strong>1. Redis</strong> <strong>是什么？都有哪些使用场景？</strong></h4><p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p>
<p>Redis 使用场景：</p>
<p>·    记录帖子点赞数、点击数、评论数；</p>
<p>·    缓存近期热帖；</p>
<p>·    缓存文章详情信息；</p>
<p>·    记录用户会话信息。</p>
<h4 id="2-Redis-有哪些功能？"><a href="#2-Redis-有哪些功能？" class="headerlink" title="2. Redis 有哪些功能？"></a><strong>2. Redis</strong> <strong>有哪些功能？</strong></h4><p>·    数据缓存功能</p>
<p>·    分布式锁的功能</p>
<p>·    支持数据持久化</p>
<p>·    支持事务</p>
<p>·    支持消息队列</p>
<h4 id="3-Redis-和-memcache-有什么区别？"><a href="#3-Redis-和-memcache-有什么区别？" class="headerlink" title="3. Redis 和 memcache 有什么区别？"></a><strong>3. Redis</strong> <strong>和</strong> <strong>memcache</strong> <strong>有什么区别？</strong></h4><p>·    存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</p>
<p>·    数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</p>
<p>·    使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
<p>·    value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。</p>
<h4 id="4-Redis-为什么是单线程的？"><a href="#4-Redis-为什么是单线程的？" class="headerlink" title="4. Redis 为什么是单线程的？"></a><strong>4. Redis</strong> <strong>为什么是单线程的？</strong></h4><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>
<h4 id="5-什么是缓存穿透？怎么解决？"><a href="#5-什么是缓存穿透？怎么解决？" class="headerlink" title="5. 什么是缓存穿透？怎么解决？"></a><strong>5.</strong> <strong>什么是缓存穿透？怎么解决？</strong></h4><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h4 id="6-Redis-支持的数据类型有哪些？"><a href="#6-Redis-支持的数据类型有哪些？" class="headerlink" title="6. Redis 支持的数据类型有哪些？"></a><strong>6. Redis</strong> <strong>支持的数据类型有哪些？</strong></h4><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p>
<h4 id="7-Redis-支持的-Java-客户端都有哪些？"><a href="#7-Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="7. Redis 支持的 Java 客户端都有哪些？"></a><strong>7. Redis</strong> <strong>支持的</strong> <strong>Java</strong> <strong>客户端都有哪些？</strong></h4><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p>
<h4 id="8-jedis-和-Redisson-有哪些区别？"><a href="#8-jedis-和-Redisson-有哪些区别？" class="headerlink" title="8. jedis 和 Redisson 有哪些区别？"></a><strong>8. jedis</strong> <strong>和</strong> <strong>Redisson</strong> <strong>有哪些区别？</strong></h4><p>·    jedis：提供了比较全面的 Redis 命令的支持。</p>
<p>·    Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p>
<h4 id="9-怎么保证缓存和数据库数据的一致性？"><a href="#9-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="9. 怎么保证缓存和数据库数据的一致性？"></a><strong>9.</strong> <strong>怎么保证缓存和数据库数据的一致性？</strong></h4><p>·    合理设置缓存的过期时间。</p>
<p>·    新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p>
<h4 id="10-Redis-持久化有几种方式？"><a href="#10-Redis-持久化有几种方式？" class="headerlink" title="10. Redis 持久化有几种方式？"></a><strong>10. Redis</strong> <strong>持久化有几种方式？</strong></h4><p>Redis 的持久化有两种方式，或者说有两种策略：</p>
<p>·    RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</p>
<p>·    AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p>
<h4 id="11-Redis-怎么实现分布式锁？"><a href="#11-Redis-怎么实现分布式锁？" class="headerlink" title="11. Redis 怎么实现分布式锁？"></a><strong>11. Redis</strong> <strong>怎么实现分布式锁？</strong></h4><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>
<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>
<h4 id="12-Redis-分布式锁有什么缺陷？"><a href="#12-Redis-分布式锁有什么缺陷？" class="headerlink" title="12. Redis 分布式锁有什么缺陷？"></a><strong>12. Redis</strong> <strong>分布式锁有什么缺陷？</strong></h4><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<h4 id="13-Redis-如何做内存优化？"><a href="#13-Redis-如何做内存优化？" class="headerlink" title="13. Redis 如何做内存优化？"></a><strong>13. Redis</strong> <strong>如何做内存优化？</strong></h4><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p>
<h4 id="14-Redis-淘汰策略有哪些？"><a href="#14-Redis-淘汰策略有哪些？" class="headerlink" title="14. Redis 淘汰策略有哪些？"></a><strong>14. Redis</strong> <strong>淘汰策略有哪些？</strong></h4><p>·   volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p>
<p>·   volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p>
<p>·   volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p>
<p>·   allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p>
<p>·   allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</p>
<p>·   no-enviction（驱逐）：禁止驱逐数据。</p>
<p><strong>15. Redis</strong> <strong>常见的性能问题有哪些？该如何解决？</strong></p>
<p>·    主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</p>
<p>·    Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>java Mysql 知识检验</title>
    <url>/2020/07/19/java-Mysql-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-数据库的三范式是什么？"><a href="#1-数据库的三范式是什么？" class="headerlink" title="1. 数据库的三范式是什么？"></a><strong>1.</strong> <strong>数据库的三范式是什么？</strong></h4><p>·    第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>·    第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>
<p>·    第三范式：任何非主属性不依赖于其它非主属性。</p>
<h4 id="2-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？"><a href="#2-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a><strong>2.</strong> <strong>一张自增表里面总共有</strong> <strong>7</strong> <strong>条数据，删除了最后</strong> <strong>2</strong> <strong>条数据，重启</strong> <strong>MySQL</strong> <strong>数据库，又插入了一条数据，此时</strong> <strong>id</strong> <strong>是几？</strong></h4><p>·    表类型如果是 MyISAM ，那 id 就是 8。</p>
<p>·    表类型如果是 InnoDB，那 id 就是 6。</p>
<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h4 id="3-如何获取当前数据库版本？"><a href="#3-如何获取当前数据库版本？" class="headerlink" title="3. 如何获取当前数据库版本？"></a><strong>3.</strong> <strong>如何获取当前数据库版本？</strong></h4><p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h4 id="4-说一下-ACID-是什么？"><a href="#4-说一下-ACID-是什么？" class="headerlink" title="4. 说一下 ACID 是什么？"></a><strong>4.</strong> <strong>说一下</strong> <strong>ACID</strong> <strong>是什么？</strong></h4><p>·    Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</p>
<p>·    Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p>
<p>·    Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p>·    Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h4 id="5-char-和-varchar-的区别是什么？"><a href="#5-char-和-varchar-的区别是什么？" class="headerlink" title="5. char 和 varchar 的区别是什么？"></a><strong>5. char</strong> <strong>和</strong> <strong>varchar</strong> <strong>的区别是什么？</strong></h4><p>·    char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>·    varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h4 id="6-float-和-double-的区别是什么？"><a href="#6-float-和-double-的区别是什么？" class="headerlink" title="6. float 和 double 的区别是什么？"></a><strong>6. float</strong> <strong>和</strong> <strong>double</strong> <strong>的区别是什么？</strong></h4><p>·    float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</p>
<p>·    double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p>
<h4 id="7-MySQL-的内连接、左连接、右连接有什么区别？"><a href="#7-MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="7. MySQL 的内连接、左连接、右连接有什么区别？"></a><strong>7. MySQL</strong> <strong>的内连接、左连接、右连接有什么区别？</strong></h4><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h4 id="8-MySQL-索引是怎么实现的？"><a href="#8-MySQL-索引是怎么实现的？" class="headerlink" title="8. MySQL 索引是怎么实现的？"></a><strong>8. MySQL</strong> <strong>索引是怎么实现的？</strong></h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h4 id="9-怎么验证-MySQL-的索引是否满足需求？"><a href="#9-怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="9. 怎么验证 MySQL 的索引是否满足需求？"></a><strong>9.</strong> <strong>怎么验证</strong> <strong>MySQL</strong> <strong>的索引是否满足需求？</strong></h4><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from table where type=1。</p>
<h4 id="10-说一下数据库的事务隔离？"><a href="#10-说一下数据库的事务隔离？" class="headerlink" title="10. 说一下数据库的事务隔离？"></a><strong>10.</strong> <strong>说一下数据库的事务隔离？</strong></h4><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p>
<p>transaction-isolation = REPEATABLE-READ</p>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<p>·    READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p>
<p>·    READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p>
<p>·    REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</p>
<p>·    SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4 id="11-说一下-MySQL-常用的引擎？"><a href="#11-说一下-MySQL-常用的引擎？" class="headerlink" title="11. 说一下 MySQL 常用的引擎？"></a><strong>11.</strong> <strong>说一下</strong> <strong>MySQL</strong> <strong>常用的引擎？</strong></h4><p>·   InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>
<p>·   MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
<h4 id="12-说一下-MySQL-的行锁和表锁？"><a href="#12-说一下-MySQL-的行锁和表锁？" class="headerlink" title="12. 说一下 MySQL 的行锁和表锁？"></a><strong>12.</strong> <strong>说一下</strong> <strong>MySQL</strong> <strong>的行锁和表锁？</strong></h4><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<p>·    表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</p>
<p>·    行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>
<h4 id="13-说一下乐观锁和悲观锁？"><a href="#13-说一下乐观锁和悲观锁？" class="headerlink" title="13. 说一下乐观锁和悲观锁？"></a><strong>13.</strong> <strong>说一下乐观锁和悲观锁？</strong></h4><p>·    乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
<p>·    悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<h4 id="14-MySQL-问题排查都有哪些手段？"><a href="#14-MySQL-问题排查都有哪些手段？" class="headerlink" title="14. MySQL 问题排查都有哪些手段？"></a><strong>14. MySQL</strong> <strong>问题排查都有哪些手段？</strong></h4><p>·    使用 show processlist 命令查看当前所有连接信息。</p>
<p>·    使用 explain 命令查询 SQL 语句执行计划。</p>
<p>·    开启慢查询日志，查看慢查询的 SQL。</p>
<h4 id="15-如何做-MySQL-的性能优化？"><a href="#15-如何做-MySQL-的性能优化？" class="headerlink" title="15. 如何做 MySQL 的性能优化？"></a><strong>15.</strong> <strong>如何做</strong> <strong>MySQL</strong> <strong>的性能优化？</strong></h4><p>·    为搜索字段创建索引。</p>
<p>·    避免使用 select *，列出需要查询的字段。</p>
<p>·    垂直分割分表。</p>
<p>·    选择正确的存储引擎。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>java Zookeeper 知识检验</title>
    <url>/2020/07/19/java-Zookeeper-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-zookeeper-是什么？"><a href="#1-zookeeper-是什么？" class="headerlink" title="1. zookeeper 是什么？"></a><strong>1. zookeeper</strong> <strong>是什么？</strong></h4><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h4 id="2-zookeeper-都有哪些功能？"><a href="#2-zookeeper-都有哪些功能？" class="headerlink" title="2. zookeeper 都有哪些功能？"></a><strong>2. zookeeper</strong> <strong>都有哪些功能？</strong></h4><p>·    集群管理：监控节点存活状态、运行请求等。</p>
<p>·    主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</p>
<p>·    分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</p>
<p>·    命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p>
<h4 id="3-zookeeper-有几种部署模式？"><a href="#3-zookeeper-有几种部署模式？" class="headerlink" title="3. zookeeper 有几种部署模式？"></a><strong>3. zookeeper</strong> <strong>有几种部署模式？</strong></h4><p>zookeeper 有三种部署模式：</p>
<p>·    单机部署：一台集群上运行；</p>
<p>·    集群部署：多台集群运行；</p>
<p>·    伪集群部署：一台集群启动多个 zookeeper 实例运行。</p>
<h4 id="4-zookeeper-怎么保证主从节点的状态同步？"><a href="#4-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="4. zookeeper 怎么保证主从节点的状态同步？"></a><strong>4. zookeeper</strong> <strong>怎么保证主从节点的状态同步？</strong></h4><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<h4 id="5-集群中为什么要有主节点？"><a href="#5-集群中为什么要有主节点？" class="headerlink" title="5. 集群中为什么要有主节点？"></a><strong>5.</strong> <strong>集群中为什么要有主节点？</strong></h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>
<h4 id="6-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#6-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="6. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a><strong>6.</strong> <strong>集群中有</strong> <strong>3</strong> <strong>台服务器，其中一个节点宕机，这个时候</strong> <strong>zookeeper</strong> <strong>还可以使用吗？</strong></h4><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>
<h4 id="7-说一下-zookeeper-的通知机制？"><a href="#7-说一下-zookeeper-的通知机制？" class="headerlink" title="7. 说一下 zookeeper 的通知机制？"></a><strong>7.</strong> <strong>说一下</strong> <strong>zookeeper</strong> <strong>的通知机制？</strong></h4><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>java Kafka 知识检验</title>
    <url>/2020/07/19/java-Kafka-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#1-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="1. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a><strong>1. kafka</strong> <strong>可以脱离</strong> <strong>zookeeper</strong> <strong>单独使用吗？为什么？</strong></h4><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>
<h4 id="2-kafka-有几种数据保留的策略？"><a href="#2-kafka-有几种数据保留的策略？" class="headerlink" title="2. kafka 有几种数据保留的策略？"></a><strong>2. kafka</strong> <strong>有几种数据保留的策略？</strong></h4><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>
<h4 id="3-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G-，这个时候-kafka-将如何处理？"><a href="#3-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G-，这个时候-kafka-将如何处理？" class="headerlink" title="3. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G**，这个时候** kafka 将如何处理？"></a><strong>3. kafka</strong> <strong>同时设置了</strong> <strong>7</strong> <strong>天和</strong> <strong>10G</strong> <strong>清除数据，到第五天的时候消息达到了</strong> <strong>10G**</strong>，这个时候** <strong>kafka</strong> <strong>将如何处理？</strong></h4><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>
<h4 id="4-什么情况会导致-kafka-运行变慢？"><a href="#4-什么情况会导致-kafka-运行变慢？" class="headerlink" title="4. 什么情况会导致 kafka 运行变慢？"></a><strong>4.</strong> <strong>什么情况会导致</strong> <strong>kafka</strong> <strong>运行变慢？</strong></h4><p>·    cpu 性能瓶颈</p>
<p>·    磁盘读写瓶颈</p>
<p>·    网络瓶颈</p>
<h4 id="5-使用-kafka-集群需要注意什么？"><a href="#5-使用-kafka-集群需要注意什么？" class="headerlink" title="5. 使用 kafka 集群需要注意什么？"></a><strong>5.</strong> <strong>使用</strong> <strong>kafka</strong> <strong>集群需要注意什么？</strong></h4><p>·    集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</p>
<p>·    集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>消息队列</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>java RabbitMQ 知识检验</title>
    <url>/2020/07/19/java-RabbitMQ-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-RabbitMQ-的使用场景有哪些？"><a href="#1-RabbitMQ-的使用场景有哪些？" class="headerlink" title="1. RabbitMQ 的使用场景有哪些？"></a><strong>1. RabbitMQ</strong> <strong>的使用场景有哪些？</strong></h4><p>·    抢购活动，削峰填谷，防止系统崩塌。</p>
<p>·    延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</p>
<p>·    解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p>
<h4 id="2-RabbitMQ-有哪些重要的角色？"><a href="#2-RabbitMQ-有哪些重要的角色？" class="headerlink" title="2. RabbitMQ 有哪些重要的角色？"></a><strong>2. RabbitMQ</strong> <strong>有哪些重要的角色？</strong></h4><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p>
<p>·    生产者：消息的创建者，负责创建和推送数据到消息服务器；</p>
<p>·    消费者：消息的接收方，用于处理数据和确认消息；</p>
<p>·    代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</p>
<h4 id="3-RabbitMQ-有哪些重要的组件？"><a href="#3-RabbitMQ-有哪些重要的组件？" class="headerlink" title="3. RabbitMQ 有哪些重要的组件？"></a><strong>3. RabbitMQ</strong> <strong>有哪些重要的组件？</strong></h4><p>·    ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</p>
<p>·    Channel（信道）：消息推送使用的通道。</p>
<p>·    Exchange（交换器）：用于接受、分配消息。</p>
<p>·    Queue（队列）：用于存储生产者的消息。</p>
<p>·    RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</p>
<p>·    BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</p>
<h4 id="4-RabbitMQ-中-vhost-的作用是什么？"><a href="#4-RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="4. RabbitMQ 中 vhost 的作用是什么？"></a><strong>4. RabbitMQ</strong> <strong>中</strong> <strong>vhost</strong> <strong>的作用是什么？</strong></h4><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p>
<h4 id="5-RabbitMQ-的消息是怎么发送的？"><a href="#5-RabbitMQ-的消息是怎么发送的？" class="headerlink" title="5. RabbitMQ 的消息是怎么发送的？"></a><strong>5. RabbitMQ</strong> <strong>的消息是怎么发送的？</strong></h4><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
<h4 id="6-RabbitMQ-怎么保证消息的稳定性？"><a href="#6-RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="6. RabbitMQ 怎么保证消息的稳定性？"></a><strong>6. RabbitMQ</strong> <strong>怎么保证消息的稳定性？</strong></h4><p>·    提供了事务的功能。</p>
<p>·    通过将 channel 设置为 confirm（确认）模式。</p>
<h4 id="7-RabbitMQ-怎么避免消息丢失？"><a href="#7-RabbitMQ-怎么避免消息丢失？" class="headerlink" title="7. RabbitMQ 怎么避免消息丢失？"></a><strong>7. RabbitMQ</strong> <strong>怎么避免消息丢失？</strong></h4><p>·    把消息持久化磁盘，保证服务器重启消息不丢失。</p>
<p>·    每个集群中至少有一个物理磁盘，保证消息落入磁盘。</p>
<h4 id="8-要保证消息持久化成功的条件有哪些？"><a href="#8-要保证消息持久化成功的条件有哪些？" class="headerlink" title="8. 要保证消息持久化成功的条件有哪些？"></a><strong>8.</strong> <strong>要保证消息持久化成功的条件有哪些？</strong></h4><p>·    声明队列必须设置持久化 durable 设置为 true.</p>
<p>·    消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</p>
<p>·    消息已经到达持久化交换器。</p>
<p>·    消息已经到达持久化队列。</p>
<p>以上四个条件都满足才能保证消息持久化成功。</p>
<h4 id="9-RabbitMQ-持久化有什么缺点？"><a href="#9-RabbitMQ-持久化有什么缺点？" class="headerlink" title="9. RabbitMQ 持久化有什么缺点？"></a><strong>9. RabbitMQ</strong> <strong>持久化有什么缺点？</strong></h4><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>
<h4 id="10-RabbitMQ-有几种广播类型？"><a href="#10-RabbitMQ-有几种广播类型？" class="headerlink" title="10. RabbitMQ 有几种广播类型？"></a><strong>10. RabbitMQ</strong> <strong>有几种广播类型？</strong></h4><p>·    direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</p>
<p>·    headers：与 direct 类似，只是性能很差，此类型几乎用不到。</p>
<p>·    fanout：分发模式，把消费分发给所有订阅者。</p>
<p>·    topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</p>
<h4 id="11-RabbitMQ-怎么实现延迟消息队列？"><a href="#11-RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="11. RabbitMQ 怎么实现延迟消息队列？"></a><strong>11. RabbitMQ</strong> <strong>怎么实现延迟消息队列？</strong></h4><p>延迟队列的实现有两种方式：</p>
<p>·    通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</p>
<p>·    使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</p>
<h4 id="12-RabbitMQ-集群有什么用？"><a href="#12-RabbitMQ-集群有什么用？" class="headerlink" title="12. RabbitMQ 集群有什么用？"></a><strong>12. RabbitMQ</strong> <strong>集群有什么用？</strong></h4><p>集群主要有以下两个用途：</p>
<p>·    高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</p>
<p>·    高容量：集群可以承载更多的消息量。</p>
<h4 id="13-RabbitMQ-节点的类型有哪些？"><a href="#13-RabbitMQ-节点的类型有哪些？" class="headerlink" title="13. RabbitMQ 节点的类型有哪些？"></a><strong>13. RabbitMQ</strong> <strong>节点的类型有哪些？</strong></h4><p>·    磁盘节点：消息会存储到磁盘。</p>
<p>·    内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</p>
<h4 id="14-RabbitMQ-集群搭建需要注意哪些问题？"><a href="#14-RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="14. RabbitMQ 集群搭建需要注意哪些问题？"></a><strong>14. RabbitMQ</strong> <strong>集群搭建需要注意哪些问题？</strong></h4><p>·    各节点之间使用“–link”连接，此属性不能忽略。</p>
<p>·    各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</p>
<p>·    整个集群中必须包含一个磁盘节点。</p>
<h4 id="15-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#15-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="15. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a><strong>15. RabbitMQ</strong> <strong>每个节点是其他节点的完整拷贝吗？为什么？</strong></h4><p>不是，原因有以下两个：</p>
<p>·    存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</p>
<p>·    性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</p>
<h4 id="16-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#16-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="16. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a><strong>16. RabbitMQ</strong> <strong>集群中唯一一个磁盘节点崩溃了会发生什么情况？</strong></h4><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<p>·    不能创建队列</p>
<p>·    不能创建交换器</p>
<p>·    不能创建绑定</p>
<p>·    不能添加用户</p>
<p>·    不能更改权限</p>
<p>·    不能添加和删除集群节点</p>
<p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>
<h4 id="17-RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#17-RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="17. RabbitMQ 对集群节点停止顺序有要求吗？"></a><strong>17. RabbitMQ</strong> <strong>对集群节点停止顺序有要求吗？</strong></h4><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>java Mybatis 知识检验</title>
    <url>/2020/07/19/java-Mybatis-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-MyBatis-中-和-的区别是什么？"><a href="#1-MyBatis-中-和-的区别是什么？" class="headerlink" title="1. MyBatis 中 #{}和** ${}**的区别是什么？"></a><strong>1. MyBatis</strong> <strong>中</strong> <strong>#{}</strong>和** ${}**的区别是什么？</h4><p>#{}是预编译处理，${}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p>
<h4 id="2-MyBatis-有几种分页方式？"><a href="#2-MyBatis-有几种分页方式？" class="headerlink" title="2. MyBatis 有几种分页方式？"></a><strong>2. MyBatis</strong> <strong>有几种分页方式？</strong></h4><p>分页方式：逻辑分页和物理分页。</p>
<p>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p>
<p>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>
<h4 id="3-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#3-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="3. RowBounds 是一次性查询全部结果吗？为什么？"></a><strong>3. RowBounds</strong> <strong>是一次性查询全部结果吗？为什么？</strong></h4><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>
<p>Fetch Size 官方相关文档：<a href="http://t" target="_blank" rel="noopener">http://t</a>. cn/EfSE2g3</p>
<h4 id="4-MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#4-MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="4. MyBatis 逻辑分页和物理分页的区别是什么？"></a><strong>4. MyBatis</strong> <strong>逻辑分页和物理分页的区别是什么？</strong></h4><p>·    逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</p>
<p>·    物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p>
<h4 id="5-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#5-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="5. MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a><strong>5. MyBatis</strong> <strong>是否支持延迟加载？延迟加载的原理是什么？</strong></h4><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p>
<p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>
<h4 id="6-说一下-MyBatis-的一级缓存和二级缓存？"><a href="#6-说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="6. 说一下 MyBatis 的一级缓存和二级缓存？"></a><strong>6.</strong> <strong>说一下</strong> <strong>MyBatis</strong> <strong>的一级缓存和二级缓存？</strong></h4><p>·    一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</p>
<p>·    二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</p>
<p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h4 id="7-MyBatis-和-hibernate-的区别有哪些？"><a href="#7-MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="7. MyBatis 和 hibernate 的区别有哪些？"></a><strong>7. MyBatis</strong> <strong>和</strong> <strong>hibernate</strong> <strong>的区别有哪些？</strong></h4><p>·    灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</p>
<p>·    可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</p>
<p>·    学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</p>
<p>·    二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p>
<h4 id="8-MyBatis-有哪些执行器（-Executor-）？"><a href="#8-MyBatis-有哪些执行器（-Executor-）？" class="headerlink" title="8. MyBatis 有哪些执行器（**Executor**）？"></a><strong>8. MyBatis</strong> <strong>有哪些执行器（**</strong>Executor<strong>**）？</strong></h4><p>MyBatis 有三种基本的Executor执行器：</p>
<p>·    SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</p>
<p>·    ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</p>
<p>·    BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p>
<h4 id="9-MyBatis-分页插件的实现原理是什么？"><a href="#9-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="9. MyBatis 分页插件的实现原理是什么？"></a><strong>9. MyBatis</strong> <strong>分页插件的实现原理是什么？</strong></h4><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h4 id="10-MyBatis-如何编写一个自定义插件？"><a href="#10-MyBatis-如何编写一个自定义插件？" class="headerlink" title="10. MyBatis 如何编写一个自定义插件？"></a><strong>10. MyBatis</strong> <strong>如何编写一个自定义插件？</strong></h4><p>自定义插件实现原理</p>
<p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p>
<p>·    Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</p>
<p>·    StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</p>
<p>·    ParameterHandler：拦截参数的处理；</p>
<p>·    ResultSetHandler：拦截结果集的处理。</p>
<p>自定义插件实现关键</p>
<p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;    </span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·    setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</p>
<p>·    plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；</p>
<p>·    intercept 方法就是要进行拦截的时候要执行的方法。</p>
<p>自定义插件实现示例</p>
<p>官方插件实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor. <span class="class"><span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>,</span><br><span class="line"></span><br><span class="line">​    args = &#123;MappedStatement. <span class="class"><span class="keyword">class</span>, <span class="title">Object</span>. <span class="title">class</span>, <span class="title">RowBounds</span>. <span class="title">class</span>, <span class="title">ResultHandler</span>. <span class="title">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">   Object target = invocation. getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line"></span><br><span class="line">   Method method = invocation. getMethod(); <span class="comment">//代理方法</span></span><br><span class="line"></span><br><span class="line">   Object[] args = invocation. getArgs(); <span class="comment">//方法参数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// do something . . . . . . 方法拦截前执行代码块</span></span><br><span class="line"></span><br><span class="line">   Object result = invocation. proceed();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// do something . . . . . . . 方法拦截后执行代码块</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Plugin. wrap(target, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>java Hibernate 知识检验</title>
    <url>/2020/07/19/java-Hibernate-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-为什么要使用-hibernate？"><a href="#1-为什么要使用-hibernate？" class="headerlink" title="1. 为什么要使用 hibernate？"></a><strong>1.</strong> <strong>为什么要使用</strong> <strong>hibernate</strong>？</h4><p>·    hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</p>
<p>·    hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</p>
<p>·    可以很方便的进行数据库的移植工作。</p>
<p>·    提供了缓存机制，是程序执行更改的高效。</p>
<h4 id="2-什么是-ORM-框架？"><a href="#2-什么是-ORM-框架？" class="headerlink" title="2. 什么是 ORM 框架？"></a><strong>2.</strong> <strong>什么是</strong> <strong>ORM</strong> <strong>框架？</strong></h4><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p>
<p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p>
<h4 id="3-hibernate-中如何在控制台查看打印的-SQL-语句？"><a href="#3-hibernate-中如何在控制台查看打印的-SQL-语句？" class="headerlink" title="3. hibernate 中如何在控制台查看打印的 SQL 语句？"></a><strong>3. hibernate</strong> <strong>中如何在控制台查看打印的</strong> <strong>SQL</strong> <strong>语句？</strong></h4><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p>
<h4 id="4-hibernate-有几种查询方式？"><a href="#4-hibernate-有几种查询方式？" class="headerlink" title="4. hibernate 有几种查询方式？"></a><strong>4. hibernate</strong> <strong>有几种查询方式？</strong></h4><p>三种：hql、原生 SQL、条件查询 Criteria。</p>
<h4 id="5-hibernate-实体类可以被定义为-final-吗？"><a href="#5-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="5. hibernate 实体类可以被定义为 final 吗？"></a><strong>5. hibernate</strong> <strong>实体类可以被定义为</strong> <strong>final</strong> <strong>吗？</strong></h4><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p>
<h4 id="6-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#6-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a><strong>6.</strong> <strong>在</strong> <strong>hibernate</strong> <strong>中使用</strong> <strong>Integer</strong> <strong>和</strong> <strong>int</strong> <strong>做映射有什么区别？</strong></h4><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p>
<h4 id="7-hibernate-是如何工作的？"><a href="#7-hibernate-是如何工作的？" class="headerlink" title="7. hibernate 是如何工作的？"></a><strong>7. hibernate</strong> <strong>是如何工作的？</strong></h4><p>·    读取并解析配置文件。</p>
<p>·    读取并解析映射文件，创建 SessionFactory。</p>
<p>·    打开 Session。</p>
<p>·    创建事务。</p>
<p>·    进行持久化操作。</p>
<p>·    提交事务。</p>
<p>·    关闭 Session。</p>
<p>·    关闭 SessionFactory。</p>
<h4 id="8-get-和-load-的区别？"><a href="#8-get-和-load-的区别？" class="headerlink" title="8. get()**和** load()**的区别？"></a><strong>8. get()**</strong>和** <strong>load()**</strong>的区别？</h4><p>·    数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。</p>
<p>·    load()支持延迟加载；get() 不支持延迟加载。</p>
<h4 id="9-说一下-hibernate-的缓存机制？"><a href="#9-说一下-hibernate-的缓存机制？" class="headerlink" title="9. 说一下 hibernate 的缓存机制？"></a><strong>9.</strong> <strong>说一下</strong> <strong>hibernate</strong> <strong>的缓存机制？</strong></h4><p>hibernate 常用的缓存有一级缓存和二级缓存：</p>
<p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</p>
<p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p>
<h4 id="10-hibernate-对象有哪些状态？"><a href="#10-hibernate-对象有哪些状态？" class="headerlink" title="10. hibernate 对象有哪些状态？"></a><strong>10. hibernate</strong> <strong>对象有哪些状态？</strong></h4><p>·    临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</p>
<p>·    持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。</p>
<p>·    游离状态：Session 关闭之后对象就是游离状态。</p>
<h4 id="11-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#11-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="11. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a><strong>11.</strong> <strong>在</strong> <strong>hibernate</strong> <strong>中</strong> <strong>getCurrentSession</strong> <strong>和</strong> <strong>openSession</strong> <strong>的区别是什么？</strong></h4><p>·    getCurrentSession 会绑定当前线程，而 openSession 则不会。</p>
<p>·    getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</p>
<h4 id="12-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#12-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="12. hibernate 实体类必须要有无参构造函数吗？为什么？"></a><strong>12. hibernate</strong> <strong>实体类必须要有无参构造函数吗？为什么？</strong></h4><p>hibernate 中每个实体类必须提供一个无参构造函数，因为框架要使用，通过调用来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Hibernate</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>java[springBoot/springCloud]知识检验</title>
    <url>/2020/07/19/java-springBoot-springCloud-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-什么是-spring-boot？"><a href="#1-什么是-spring-boot？" class="headerlink" title="1. 什么是 spring boot？"></a>1. 什么是 spring boot？</h4><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p>
<h4 id="2-为什么要用-spring-boot？"><a href="#2-为什么要用-spring-boot？" class="headerlink" title="2. 为什么要用 spring boot？"></a>2. 为什么要用 spring boot？</h4><p>•    配置简单<br>•    独立运行<br>•    自动装配<br>•    无代码生成和 xml 配置<br>•    提供应用监控<br>•    易上手<br>•    提升开发效率</p>
<h4 id="3-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#3-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="3. spring boot 配置文件有哪几种类型？它们有什么区别？"></a>3. spring boot 配置文件有哪几种类型？它们有什么区别？</h4><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。<br>. properties 配置如下：<br>spring. RabbitMQ. port=5672<br>. yml 配置如下：<br>spring:</p>
<pre><code>RabbitMQ:
    port: 5672</code></pre><p>​    . yml 格式不支持 @PropertySource 注解导入。</p>
<h4 id="4-spring-boot-有哪些方式可以实现热部署？"><a href="#4-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="4. spring boot 有哪些方式可以实现热部署？"></a>4. spring boot 有哪些方式可以实现热部署？</h4><p>•    使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；</p>
<p>•    导入springloaded依赖</p>
<p>•    使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</p>
<h4 id="5-jpa-和-hibernate-有什么区别？"><a href="#5-jpa-和-hibernate-有什么区别？" class="headerlink" title="5. jpa 和 hibernate 有什么区别？"></a>5. jpa 和 hibernate 有什么区别？</h4><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p>
<h4 id="6-什么是-spring-cloud？"><a href="#6-什么是-spring-cloud？" class="headerlink" title="6. 什么是 spring cloud？"></a>6. 什么是 spring cloud？</h4><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>
<h4 id="7-spring-cloud-断路器的作用是什么？"><a href="#7-spring-cloud-断路器的作用是什么？" class="headerlink" title="7. spring cloud 断路器的作用是什么？"></a>7. spring cloud 断路器的作用是什么？</h4><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h4 id="8-spring-cloud-的核心组件有哪些？"><a href="#8-spring-cloud-的核心组件有哪些？" class="headerlink" title="8. spring cloud 的核心组件有哪些？"></a>8. spring cloud 的核心组件有哪些？</h4><p>•    Eureka：服务注册于发现。<br>•    Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。<br>•    Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。<br>•    Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。<br>•    Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>springBoot</tag>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>java[spring/springMVC]知识检验</title>
    <url>/2020/07/19/java-spring-springMVC-%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-为什么要使用-spring？"><a href="#1-为什么要使用-spring？" class="headerlink" title="1. 为什么要使用 spring？"></a><strong>1.</strong> <strong>为什么要使用</strong> <strong>spring</strong>？</h4><p>·    spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</p>
<p>·    spring 提供了事务支持，使得事务操作变的更加方便。</p>
<p>·    spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</p>
<p>·    更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</p>
<h4 id="2-解释一下什么是-aop？"><a href="#2-解释一下什么是-aop？" class="headerlink" title="2. 解释一下什么是 aop？"></a><strong>2.</strong> <strong>解释一下什么是</strong> <em>aop</em>？</h4><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p>
<h4 id="3-解释一下什么是-ioc？"><a href="#3-解释一下什么是-ioc？" class="headerlink" title="3. 解释一下什么是 ioc？"></a><strong>3.</strong> <strong>解释一下什么是</strong> <strong>ioc</strong>？</h4><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</p>
<p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p>
<h4 id="4-spring-有哪些主要模块？"><a href="#4-spring-有哪些主要模块？" class="headerlink" title="4. spring 有哪些主要模块？"></a><strong>4. spring</strong> <strong>有哪些主要模块？</strong></h4><p>·    spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</p>
<p>·    spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</p>
<p>·    spring dao：Data Access Object 提供了JDBC的抽象层。</p>
<p>·    spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</p>
<p>·    spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</p>
<p>·    spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</p>
<h4 id="5-spring-常用的注入方式有哪些？"><a href="#5-spring-常用的注入方式有哪些？" class="headerlink" title="5. spring 常用的注入方式有哪些？"></a><strong>5. spring</strong> <strong>常用的注入方式有哪些？</strong></h4><p>·    setter 属性注入</p>
<p>·    构造方法注入</p>
<p>·    注解方式注入</p>
<h4 id="6-spring-中的-bean-是线程安全的吗？"><a href="#6-spring-中的-bean-是线程安全的吗？" class="headerlink" title="6. spring 中的 bean 是线程安全的吗？"></a><strong>6. spring</strong> <strong>中的</strong> <strong>bean</strong> <strong>是线程安全的吗？</strong></h4><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<p>·    有状态就是有数据存储功能。</p>
<p>·    无状态就是不会保存数据。</p>
<h4 id="7-spring-支持几种-bean-的作用域？"><a href="#7-spring-支持几种-bean-的作用域？" class="headerlink" title="7. spring 支持几种 bean 的作用域？"></a><strong>7. spring</strong> <strong>支持几种</strong> <strong>bean</strong> <strong>的作用域？</strong></h4><p>spring 支持 5 种作用域，如下：</p>
<p>·    singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</p>
<p>·    prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</p>
<p>·    Web 环境下的作用域：</p>
<p>·    request：每次 http 请求都会创建一个 bean；</p>
<p>·    session：同一个 http session 共享一个 bean 实例；</p>
<p>·    global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</p>
<p>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h4 id="8-spring-自动装配-bean-有哪些方式？"><a href="#8-spring-自动装配-bean-有哪些方式？" class="headerlink" title="8. spring 自动装配 bean 有哪些方式？"></a><strong>8. spring</strong> <strong>自动装配</strong> <strong>bean</strong> <strong>有哪些方式？</strong></h4><p>·    no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</p>
<p>·    byName：它根据 bean 的名称注入对象依赖项。</p>
<p>·    byType：它根据类型注入对象依赖项。</p>
<p>·    构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</p>
<p>·    autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</p>
<h4 id="9-spring-事务实现方式有哪些？"><a href="#9-spring-事务实现方式有哪些？" class="headerlink" title="9. spring 事务实现方式有哪些？"></a><strong>9. spring</strong> <strong>事务实现方式有哪些？</strong></h4><p>·    声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</p>
<p>·    编码方式：提供编码的形式管理和维护事务。</p>
<h4 id="10-说一下-spring-的事务隔离？"><a href="#10-说一下-spring-的事务隔离？" class="headerlink" title="10.说一下 spring 的事务隔离？"></a>10.<strong>说一下</strong> <strong>spring</strong> <strong>的事务隔离？</strong></h4><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
<p>ISOLATION<em>READ</em>UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
<p>ISOLATION<em>READ</em>COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
<p>ISOLATION<em>REPEATABLE</em>READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
<p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4 id="11-说一下-spring-mvc-运行流程？"><a href="#11-说一下-spring-mvc-运行流程？" class="headerlink" title="11. 说一下 spring mvc 运行流程？"></a><strong>11.</strong> <strong>说一下</strong> <strong>spring mvc</strong> <strong>运行流程？</strong></h4><p>·    spring mvc 先将请求发送给 DispatcherServlet。</p>
<p>·    DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</p>
<p>·    DispatcherServlet 再把请求提交到对应的 Controller。</p>
<p>·    Controller 进行业务逻辑处理后，会返回一个ModelAndView。</p>
<p>·    Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</p>
<p>·    视图对象负责渲染返回给客户端。</p>
<h4 id="12-spring-mvc-有哪些组件？"><a href="#12-spring-mvc-有哪些组件？" class="headerlink" title="12. spring mvc 有哪些组件？"></a><strong>12. spring mvc</strong> <strong>有哪些组件？</strong></h4><p>·    前置控制器 DispatcherServlet。</p>
<p>·    映射控制器 HandlerMapping。</p>
<p>·    处理器 Controller。</p>
<p>·    模型和视图 ModelAndView。</p>
<p>·    视图解析器 ViewResolver。</p>
<h4 id="13-RequestMapping-的作用是什么？"><a href="#13-RequestMapping-的作用是什么？" class="headerlink" title="13. @RequestMapping 的作用是什么？"></a><strong>13. @RequestMapping</strong> <strong>的作用是什么？</strong></h4><p>将 http 请求映射到相应的类/方法上。</p>
<h5 id="14-Autowired-的作用是什么？"><a href="#14-Autowired-的作用是什么？" class="headerlink" title="14. @Autowired 的作用是什么？"></a><strong>14. @Autowired</strong> <strong>的作用是什么？</strong></h5><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>spring</tag>
        <tag>springmMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>java网络知识检验</title>
    <url>/2020/07/19/java%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#1-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="1. http 响应码 301 和 302 代表的是什么？有什么区别？"></a><strong>1. http</strong> <strong>响应码</strong> <strong>301</strong> <strong>和</strong> <strong>302</strong> <strong>代表的是什么？有什么区别？</strong></h4><p>301：永久重定向。</p>
<p>302：暂时重定向。</p>
<p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
<h4 id="2-forward-和-redirect-的区别？"><a href="#2-forward-和-redirect-的区别？" class="headerlink" title="2. forward 和 redirect 的区别？"></a><strong>2. forward</strong> <strong>和</strong> <strong>redirect</strong> <strong>的区别？</strong></h4><p>forward 是转发 和 redirect 是重定向：</p>
<p>·    地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</p>
<p>·    数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</p>
<p>·    效率：forward 比 redirect 效率高。</p>
<h4 id="3-简述-tcp-和-udp的区别？"><a href="#3-简述-tcp-和-udp的区别？" class="headerlink" title="3. 简述 tcp 和 udp的区别？"></a><strong>3.</strong> <strong>简述</strong> <strong>tcp</strong> <strong>和</strong> <strong>udp</strong>的区别？</h4><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<p>·    tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</p>
<p>·    tcp 提供可靠的服务（数据传输），udp 无法保证；</p>
<p>·    tcp 面向字节流，udp 面向报文；</p>
<p>·    tcp 数据传输慢，udp 数据传输快；</p>
<h4 id="4-tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#4-tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="4. tcp 为什么要三次握手，两次不行吗？为什么？"></a><strong>4. tcp</strong> <strong>为什么要三次握手，两次不行吗？为什么？</strong></h4><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>
<h4 id="5-说一下-tcp-粘包是怎么产生的？"><a href="#5-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="5. 说一下 tcp 粘包是怎么产生的？"></a><strong>5.</strong> <strong>说一下</strong> <strong>tcp</strong> <strong>粘包是怎么产生的？</strong></h4><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>
<p>·    发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</p>
<p>·    接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</p>
<h4 id="6-OSI-的七层模型都有哪些？"><a href="#6-OSI-的七层模型都有哪些？" class="headerlink" title="6. OSI 的七层模型都有哪些？"></a><strong>6. OSI</strong> <strong>的七层模型都有哪些？</strong></h4><p>·    物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</p>
<p>·    数据链路层：负责建立和管理节点间的链路。</p>
<p>·    网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</p>
<p>·    传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</p>
<p>·    会话层：向两个实体的表示层提供建立和使用连接的方法。</p>
<p>·    表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</p>
<p>·    应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p>
<h4 id="7-get-和-post-请求有哪些区别？"><a href="#7-get-和-post-请求有哪些区别？" class="headerlink" title="7. get 和 post 请求有哪些区别？"></a><strong>7. get</strong> <strong>和</strong> <strong>post</strong> <strong>请求有哪些区别？</strong></h4><p>·    get 请求会被浏览器主动缓存，而 post 不会。</p>
<p>·    get 传递参数有大小限制，而 post 没有。</p>
<p>·    post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</p>
<h4 id="8-如何实现跨域？"><a href="#8-如何实现跨域？" class="headerlink" title="8. 如何实现跨域？"></a><strong>8.</strong> <strong>如何实现跨域？</strong></h4><p>实现跨域有以下几种方案：</p>
<p>·    服务器端运行跨域 设置 CORS 等于 *；</p>
<p>·    在单个接口使用注解 @CrossOrigin 运行跨域；</p>
<p>·    使用 jsonp 跨域；</p>
<h4 id="9-说一下-JSONP-实现原理？"><a href="#9-说一下-JSONP-实现原理？" class="headerlink" title="9. 说一下 JSONP 实现原理？"></a><strong>9.</strong> <strong>说一下</strong> <strong>JSONP</strong> <strong>实现原理？</strong></h4><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程知识检验</title>
    <url>/2020/07/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1. 并行和并发有什么区别？"></a>1. <strong>并行和并发有什么区别？</strong></h4><p>·    并行：多个处理器或多核处理器同时处理多个任务。</p>
<p>·    并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p>
<p>如下图：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2020/07/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/clip_image001.png"  alt="并发和并行"></p>
<p>并发 = 两个队列和一台咖啡机。</p>
<p>并行 = 两个队列和两台咖啡机。</p>
<h4 id="2-线程和进程的区别？"><a href="#2-线程和进程的区别？" class="headerlink" title="2. 线程和进程的区别？"></a><strong>2.</strong> <strong>线程和进程的区别？</strong></h4><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<h4 id="3-守护线程是什么？"><a href="#3-守护线程是什么？" class="headerlink" title="3. 守护线程是什么？"></a><strong>3.</strong> <strong>守护线程是什么？</strong></h4><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h4 id="4-创建线程有哪几种方式？"><a href="#4-创建线程有哪几种方式？" class="headerlink" title="4. 创建线程有哪几种方式？"></a><strong>4.</strong> <strong>创建线程有哪几种方式？</strong></h4><p>创建线程有三种方式：</p>
<p>·    继承 Thread 重写 run 方法；</p>
<p>·    实现 Runnable 接口；</p>
<p>·    实现 Callable 接口。</p>
<h4 id="5-说一下-runnable-和-callable-有什么区别？"><a href="#5-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="5. 说一下 runnable 和 callable 有什么区别？"></a><strong>5.</strong> <strong>说一下</strong> <strong>runnable</strong> <strong>和</strong> <strong>callable</strong> <strong>有什么区别？</strong></h4><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>
<h4 id="6-线程有哪些状态？"><a href="#6-线程有哪些状态？" class="headerlink" title="6. 线程有哪些状态？"></a><strong>6.</strong> <strong>线程有哪些状态？</strong></h4><p>线程的状态：</p>
<p>·    NEW 尚未启动</p>
<p>·    RUNNABLE 正在执行中</p>
<p>·    BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</p>
<p>·    WAITING 永久等待状态</p>
<p>·    TIMED_WAITING 等待指定的时间重新被唤醒的状态</p>
<p>·    TERMINATED 执行完成</p>
<h4 id="7-sleep-和-wait-有什么区别？"><a href="#7-sleep-和-wait-有什么区别？" class="headerlink" title="7. sleep() 和 wait() 有什么区别？"></a><strong>7. sleep()</strong> <strong>和</strong> <strong>wait()</strong> <strong>有什么区别？</strong></h4><p>·    类的不同：sleep() 来自 Thread，wait() 来自 Object。</p>
<p>·    释放锁：sleep() 不释放锁；wait() 释放锁。</p>
<p>·    用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</p>
<h4 id="8-notify-和-notifyAll-有什么区别？"><a href="#8-notify-和-notifyAll-有什么区别？" class="headerlink" title="8. notify()**和** notifyAll()**有什么区别？**"></a><strong>8. notify()**</strong>和** <strong>notifyAll()**</strong>有什么区别？**</h4><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>
<h4 id="9-线程的-run-和-start-有什么区别？"><a href="#9-线程的-run-和-start-有什么区别？" class="headerlink" title="9. 线程的 run() 和 start() 有什么区别？"></a><strong>9.</strong> <strong>线程的</strong> <strong>run()</strong> <strong>和</strong> <strong>start()</strong> <strong>有什么区别？</strong></h4><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<h4 id="10-创建线程池有哪几种方式？"><a href="#10-创建线程池有哪几种方式？" class="headerlink" title="10. 创建线程池有哪几种方式？"></a><strong>10.</strong> <strong>创建线程池有哪几种方式？</strong></h4><p>线程池创建有七种方式，最核心的是最后一种：</p>
<p>·   newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</p>
<p>·   newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</p>
<p>·   newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</p>
<p>·   newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</p>
<p>·   newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</p>
<p>·   newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</p>
<p>·   ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</p>
<h4 id="11-线程池都有哪些状态？"><a href="#11-线程池都有哪些状态？" class="headerlink" title="11. 线程池都有哪些状态？"></a><strong>11.</strong> <strong>线程池都有哪些状态？</strong></h4><p>·    RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p>
<p>·    SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p>
<p>·    STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p>
<p>·    TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</p>
<p>·    TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p>
<h4 id="12-线程池中-submit-和-execute-方法有什么区别？"><a href="#12-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="12. 线程池中 submit() 和 execute() 方法有什么区别？"></a><strong>12.</strong> <strong>线程池中</strong> <strong>submit()</strong> <strong>和</strong> <strong>execute()</strong> <strong>方法有什么区别？</strong></h4><p>·    execute()：只能执行 Runnable 类型的任务。</p>
<p>·    submit()：可以执行 Runnable 和 Callable 类型的任务。</p>
<p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>
<h4 id="13-在-Java-程序中怎么保证多线程的运行安全？"><a href="#13-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="13. 在 Java 程序中怎么保证多线程的运行安全？"></a><strong>13.</strong> <strong>在</strong> <strong>Java</strong> <strong>程序中怎么保证多线程的运行安全？</strong></h4><p>·    方法一：使用安全类，比如 Java. util. concurrent 下的类。</p>
<p>·    方法二：使用自动锁 synchronized。</p>
<p>·    方法三：使用手动锁 Lock。</p>
<p>手动锁 Java 示例代码如下：</p>
<p>Lock lock = new ReentrantLock();</p>
<p>lock. lock();</p>
<p>try {</p>
<p>  System. out. println(“获得锁”);</p>
<p>} catch (Exception e) {</p>
<p>  // TODO: handle exception</p>
<p>} finally {</p>
<p>  System. out. println(“释放锁”);</p>
<p>  lock. unlock();</p>
<p>}</p>
<h4 id="14-多线程中-synchronized-锁升级的原理是什么？"><a href="#14-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="14. 多线程中 synchronized 锁升级的原理是什么？"></a><strong>14.</strong> <strong>多线程中</strong> <strong>synchronized</strong> <strong>锁升级的原理是什么？</strong></h4><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h4 id="15-什么是死锁？"><a href="#15-什么是死锁？" class="headerlink" title="15. 什么是死锁？"></a><strong>15.</strong> <strong>什么是死锁？</strong></h4><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h4 id="16-怎么防止死锁？"><a href="#16-怎么防止死锁？" class="headerlink" title="16. 怎么防止死锁？"></a><strong>16.</strong> <strong>怎么防止死锁？</strong></h4><p>·    尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</p>
<p>·    尽量使用 Java. util. concurrent 并发类代替自己手写锁。</p>
<p>·    尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</p>
<p>·    尽量减少同步的代码块。</p>
<h4 id="17-ThreadLocal-是什么？有哪些使用场景？"><a href="#17-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="17. ThreadLocal 是什么？有哪些使用场景？"></a><strong>17. ThreadLocal</strong> <strong>是什么？有哪些使用场景？</strong></h4><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<h4 id="18-说一下-synchronized-底层实现原理？"><a href="#18-说一下-synchronized-底层实现原理？" class="headerlink" title="18. 说一下 synchronized 底层实现原理？"></a><strong>18.</strong> <strong>说一下</strong> <strong>synchronized</strong> <strong>底层实现原理？</strong></h4><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<h4 id="19-synchronized-和-volatile-的区别是什么？"><a href="#19-synchronized-和-volatile-的区别是什么？" class="headerlink" title="19. synchronized 和 volatile 的区别是什么？"></a><strong>19. synchronized</strong> <strong>和</strong> <strong>volatile</strong> <strong>的区别是什么？</strong></h4><p>·    volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</p>
<p>·    volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</p>
<p>·    volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p>
<h4 id="20-synchronized-和-Lock-有什么区别？"><a href="#20-synchronized-和-Lock-有什么区别？" class="headerlink" title="20. synchronized 和 Lock 有什么区别？"></a><strong>20. synchronized</strong> <strong>和</strong> <strong>Lock</strong> <strong>有什么区别？</strong></h4><p>·    synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</p>
<p>·    synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p>
<p>·    通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>
<h4 id="21-synchronized-和-ReentrantLock-区别是什么？"><a href="#21-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="21. synchronized 和 ReentrantLock 区别是什么？"></a><strong>21. synchronized</strong> <strong>和</strong> <strong>ReentrantLock</strong> <strong>区别是什么？</strong></h4><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>主要区别如下：</p>
<p>·    ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</p>
<p>·    ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</p>
<p>·    ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</p>
<p>·    volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</p>
<h4 id="22-说一下-atomic-的原理？"><a href="#22-说一下-atomic-的原理？" class="headerlink" title="22. 说一下 atomic 的原理？"></a><strong>22.</strong> <strong>说一下</strong> <strong>atomic</strong> <strong>的原理？</strong></h4><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>锁</tag>
        <tag>面试</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java容器知识检验</title>
    <url>/2020/07/16/java%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18. Java 容器都有哪些？"></a><strong>18. Java</strong> <strong>容器都有哪些？</strong></h4><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>·    Collection</p>
<p>·    List</p>
<p>o  ArrayList</p>
<p>o  LinkedList</p>
<p>o  Vector</p>
<p>o  Stack</p>
<p>·    Set</p>
<p>o  HashSet</p>
<p>o  LinkedHashSet</p>
<p>o  TreeSet</p>
<p>·    Map</p>
<p>·    HashMap</p>
<p>o  LinkedHashMap</p>
<p>·    TreeMap</p>
<p>·    ConcurrentHashMap</p>
<p>·    Hashtable</p>
<h4 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a><strong>19. Collection</strong> <strong>和</strong> <strong>Collections</strong> <strong>有什么区别？</strong></h4><p>·    Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</p>
<p>·    Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p>
<h4 id="20-List、Set、-Map-之间的区别是什么？"><a href="#20-List、Set、-Map-之间的区别是什么？" class="headerlink" title="20. List、Set、*Map *之间的区别是什么？"></a><strong>20. List</strong>、<strong><strong>Set</strong></strong>、<strong>*<em>Map *</em>之间的区别是什么？</strong></h4><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p>三者之间的区别，如下表：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2020/07/16/java%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/%E5%9B%BE1.png"  alt="区别图"></p>
<h4 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a><strong>21. HashMap</strong> <strong>和</strong> <strong>Hashtable</strong> <strong>有什么区别？</strong></h4><p>·    存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</p>
<p>·    线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</p>
<p>·    推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>
<h4 id="22-如何决定使用-HashMap-还是-TreeMap-？"><a href="#22-如何决定使用-HashMap-还是-TreeMap-？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap**？**"></a><strong>22.</strong> <strong>如何决定使用</strong> <strong>HashMap</strong> <strong>还是</strong> <strong>TreeMap**</strong>？**</h4><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h4 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a><strong>23.</strong> <strong>说一下</strong> <strong>HashMap</strong> <strong>的实现原理？</strong></h4><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h4 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a><strong>24.</strong> <strong>说一下</strong> <strong>HashSet</strong> <strong>的实现原理？</strong></h4><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h4 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a><strong>25. ArrayList</strong> <strong>和</strong> <strong>LinkedList</strong> <strong>的区别是什么？</strong></h4><p>·    数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p>
<p>·    随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p>·    增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<h4 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a><strong>26.</strong> <strong>如何实现数组和</strong> <strong>List</strong> <strong>之间的转换？</strong></h4><p>·    数组转 List：使用 Arrays. asList(array) 进行转换。</p>
<p>·    List 转数组：使用 List 自带的 toArray() 方法。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">list. add(<span class="string">"王磊"</span>);</span><br><span class="line"></span><br><span class="line">list. add(<span class="string">"的博客"</span>);</span><br><span class="line"></span><br><span class="line">list. toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line"></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"王磊"</span>,<span class="string">"的博客"</span>&#125;;</span><br><span class="line"></span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>

<h4 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27. ArrayList 和 Vector 的区别是什么？"></a><strong>27. ArrayList</strong> <strong>和</strong> <strong>Vector</strong> <strong>的区别是什么？</strong></h4><p>·    线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</p>
<p>·    性能：ArrayList 在性能方面要优于 Vector。</p>
<p>·    扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p>
<h4 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28. Array 和 ArrayList 有何区别？"></a><strong>28. Array</strong> <strong>和</strong> <strong>ArrayList</strong> <strong>有何区别？</strong></h4><p>·    Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p>
<p>·    Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p>
<p>·    Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p>
<h4 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll()和 remove()有什么区别？"></a><strong>29.</strong> <strong>在</strong> <strong>Queue</strong> <strong>中</strong> <strong>poll()</strong>和 <strong>remove()有什么区别？</strong></h4><p>·    相同点：都是返回第一个元素，并在队列中删除返回的对象。</p>
<p>·    不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">queue. offer(<span class="string">"string"</span>); <span class="comment">// add</span></span><br><span class="line"></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line"></span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line"></span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure>



<h4 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a><strong>30.</strong> <strong>哪些集合类是线程安全的？</strong></h4><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h4 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a><strong>31.</strong> <strong>迭代器</strong> <strong>Iterator</strong> <strong>是什么？</strong></h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h4 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a><strong>32. Iterator</strong> <strong>怎么使用？有什么特点？</strong></h4><p>Iterator 使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line"></span><br><span class="line"> String obj = it. next();</span><br><span class="line"></span><br><span class="line"> System. out. println(obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h4 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a><strong>33. Iterator</strong> <strong>和</strong> <strong>ListIterator</strong> <strong>有什么区别？</strong></h4><p>·    Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</p>
<p>·    Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</p>
<p>·    ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
<h4 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34. 怎么确保一个集合不能被修改？"></a><strong>34.</strong> <strong>怎么确保一个集合不能被修改？</strong></h4><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list. add(<span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line"></span><br><span class="line">clist. add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line"></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础知识检验</title>
    <url>/2020/07/16/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a><strong>1. JDK</strong> <strong>和</strong> <strong>JRE</strong> <strong>有什么区别？</strong></h4><p>·    JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</p>
<p>·    JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</p>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>
<h4 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a><strong>2. ==</strong> <strong>和</strong> <strong>equals</strong> <strong>的区别是什么？</strong></h4><p>== 解读</p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<p>·    基本类型：比较的是值是否相同；</p>
<p>·    引用类型：比较的是引用是否相同；</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line"></span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line"></span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p>equals 解读</p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line"></span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"></span><br><span class="line">​    String anotherString = (String)anObject;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> n = value.length;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">char</span> v1[] = value;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"></span><br><span class="line">​          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">​        i++;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h4 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a><strong>3.</strong> <strong>两个对象的</strong> <strong>hashCode()</strong> <strong>相同，则</strong> <strong>equals()</strong> <strong>也一定为</strong> <strong>true</strong>，对吗？</h4><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"通话"</span>;</span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">"重地"</span>;</span><br><span class="line"></span><br><span class="line">System. out. println(String. format(<span class="string">"str1：%d | str2：%d"</span>, str1. hashCode(),str2. hashCode()));</span><br><span class="line"></span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure>

<p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p> false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h4 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4. final 在 Java 中有什么作用？"></a><strong>4. final</strong> <strong>在</strong> <strong>Java</strong> <strong>中有什么作用？</strong></h4><p>·    final 修饰的类叫最终类，该类不能被继承。</p>
<p>·    final 修饰的方法不能被重写。</p>
<p>·    final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h4 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. Java 中的 Math. round(-1. 5) 等于多少？"></a><strong>5. Java</strong> <strong>中的</strong> <strong>Math. round(-1. 5)</strong> <strong>等于多少？</strong></h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h4 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a><strong>6. String</strong> <strong>属于基础的数据类型吗？</strong></h4><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h4 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a><strong>7. Java</strong> <strong>中操作字符串都有哪些类？它们之间有什么区别？</strong></h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h4 id="8-String-str-”i”-与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=”i”**与** String str=new String(“i”)**一样吗？**"></a><strong>8. String str=”i”**</strong>与** <strong>String str=new String(“i”)**</strong>一样吗？**</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h4 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a><strong>9.</strong> <strong>如何将字符串反转？</strong></h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line"></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">stringBuffer. append(<span class="string">"abcdefg"</span>);</span><br><span class="line"></span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">stringBuilder. append(<span class="string">"abcdefg"</span>);</span><br><span class="line"></span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>

<h4 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a><strong>10. String</strong> <strong>类的常用方法都有那些？</strong></h4><p>·    indexOf()：返回指定字符的索引。</p>
<p>·    charAt()：返回指定索引处的字符。</p>
<p>·    replace()：字符串替换。</p>
<p>·    trim()：去除字符串两端空白。</p>
<p>·    split()：分割字符串，返回一个分割后的字符串数组。</p>
<p>·    getBytes()：返回字符串的 byte 类型数组。</p>
<p>·    length()：返回字符串长度。</p>
<p>·    toLowerCase()：将字符串转成小写字母。</p>
<p>·    toUpperCase()：将字符串转成大写字符。</p>
<p>·    substring()：截取字符串。</p>
<p>·    equals()：字符串比较。</p>
<h4 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a><strong>11.</strong> <strong>抽象类必须要有抽象方法吗？</strong></h4><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<p>abstract class Cat {</p>
<p>  public static void sayHi() {</p>
<p>​    System. out. println(“hi~”);</p>
<p>  }</p>
<p>}</p>
<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h4 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a><strong>12.</strong> <strong>普通类和抽象类有哪些区别？</strong></h4><p>·    普通类不能包含抽象方法，抽象类可以包含抽象方法。</p>
<p>·    抽象类不能直接实例化，普通类可以直接实例化。</p>
<h4 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a><strong>13.</strong> <strong>抽象类能使用</strong> <strong>final</strong> <strong>修饰吗？</strong></h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2020/07/16/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/img.png"  alt="图1"></p>
<h4 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a><strong>14.</strong> <strong>接口和抽象类有什么区别？</strong></h4><p>·    实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</p>
<p>·    构造函数：抽象类可以有构造函数；接口不能有。</p>
<p>·    实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</p>
<p>·    访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p>
<h4 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15. Java 中 IO 流分为几种？"></a><strong>15. Java</strong> <strong>中</strong> <strong>IO</strong> <strong>流分为几种？</strong></h4><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h4 id="16-BIO、NIO、AIO有什么区别？"><a href="#16-BIO、NIO、AIO有什么区别？" class="headerlink" title="16. BIO、NIO、AIO有什么区别？"></a><strong>16. BIO、NIO、AIO有什么区别？</strong></h4><p>·    BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p>
<p>·    NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p>
<p>·    AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h4 id="17-Files-的常用方法都有哪些？"><a href="#17-Files-的常用方法都有哪些？" class="headerlink" title="17. Files**的常用方法都有哪些？**"></a><strong>17. Files**</strong>的常用方法都有哪些？**</h4><p>·    Files. exists()：检测文件路径是否存在。</p>
<p>·    Files. createFile()：创建文件。</p>
<p>·    Files. createDirectory()：创建文件夹。</p>
<p>·    Files. delete()：删除一个文件或目录。</p>
<p>·    Files. copy()：复制文件。</p>
<p>·    Files. move()：移动文件。</p>
<p>·    Files. size()：查看文件个数。</p>
<p>·    Files. read()：读取文件。</p>
<p>·    Files. write()：写入文件。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试题</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机</title>
    <url>/2020/07/06/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E4%B8%80%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F" target="_blank" rel="noopener">参考连接</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/29881777" target="_blank" rel="noopener">JVM总结</a></p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS和Synchronized的区别</title>
    <url>/2020/07/05/CAS%E5%92%8CSynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md" target="_blank" rel="noopener">更多资源</a>：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md</a></p>
<h2 id="一、CAS"><a href="#一、CAS" class="headerlink" title="一、CAS"></a>一、CAS</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p> CAS（Compare And Swap ) 或（ Compare-and-Set ）是乐观锁的一种实现方式，是一种轻量级锁。JAVA1.5开始引入了CAS，JUC下很多工具类都是基于CAS。 </p>
<h3 id="CAS的实现方式"><a href="#CAS的实现方式" class="headerlink" title="CAS的实现方式:"></a><strong>CAS的实现方式:</strong></h3><p> CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。当多个线程同时尝试使用CAS更新一个变量时，任何时候只有一个线程可以更新成功，若更新失败，线程会重新进入循环再次进行尝试。 </p>
<h3 id="CAS带来的问题"><a href="#CAS带来的问题" class="headerlink" title="CAS带来的问题"></a>CAS带来的问题</h3><h4 id="ABA问题-："><a href="#ABA问题-：" class="headerlink" title="ABA问题 ："></a><strong>ABA问题</strong> ：</h4><p>ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。ABA问题的解决思路是，每次变量更新的时候把变量的版本号加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题。在JDK的java.util.concurrent.atomic包中提供了AtomicStampedReference来解决ABA问题，该类的compareAndSet是该类的核心方法，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                            V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">   Pair&lt;V&gt; current = pair;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">       expectedReference == current.reference &amp;&amp;</span><br><span class="line">       expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">       ((newReference == current.reference &amp;&amp;</span><br><span class="line">         newStamp == current.stamp) ||</span><br><span class="line">        casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，该类检查了当前引用与当前标志是否与预期相同，如果全部相等，才会以原子方式将该引用和该标志的值设为新的更新值，这样CAS操作中的比较就不依赖于变量的值了。</p>
<h2 id="二、synchronized"><a href="#二、synchronized" class="headerlink" title="二、synchronized"></a>二、synchronized</h2><p>相比于CAS基于乐观锁实现，synchronized是基于悲观锁的，当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p>
<ul>
<li>对于普通同步方法加锁时，锁是当前实例对象</li>
<li>对于静态同步方法加锁时，锁是当前类的Class对象</li>
<li>对于同步方法块加锁时，锁是Synchonized括号里配置的对象</li>
</ul>
<h3 id="Synchronized的实现方式："><a href="#Synchronized的实现方式：" class="headerlink" title="Synchronized的实现方式："></a><strong>Synchronized的实现方式：</strong></h3><p>Synchonized是基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。Synchronized 用在方法上时，在字节码中是通过方法的 ACC_SYNCHRONIZED 标志来实现的。而代码块同步则是使用monitorenter和monitorexit指令实现的。</p>
<p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁，当获得对象的monitor以后，monitor内部的计数器就会自增（初始为0），当同一个线程再次获得monitor的时候，计数器会再次自增。当同一个线程执行monitorexit指令的时候，计数器会进行自减，当计数器为0的时候，monitor就会被释放，其他线程便可以获得monitor。</p>
<h3 id="Synchronized的优化："><a href="#Synchronized的优化：" class="headerlink" title="Synchronized的优化："></a><strong>Synchronized的优化：</strong></h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h4><p>HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁是为了在只有一个线程执行同步块时提高性能。</p>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。</p>
<p><strong>偏向锁获取过程：</strong></p>
<ul>
<li>（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</li>
<li>（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</li>
<li>（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。</li>
<li>（4）如果CAS获取偏向锁失败，则表示有竞争（CAS获取偏向锁失败说明至少有过其他线程曾经获得过偏向锁，因为线程不会主动去释放偏向锁）。当到达全局安全点（safepoint）时，会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着（因为可能持有偏向锁的线程已经执行完毕，但是该线程并不会主动去释放偏向锁），如果线程不处于活动状态，则将对象头设置成无锁状态（标志位为“01”），然后重新偏向新的线程；如果线程仍然活着，撤销偏向锁后升级到轻量级锁状态（标志位为“00”），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。</li>
<li>（5）执行同步代码。</li>
</ul>
<p><strong>偏向锁的释放过程：</strong></p>
<p>如上步骤（4）。偏向锁使用了一种等到竞争出现才释放偏向锁的机制：偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p><strong>关闭偏向锁：</strong></p>
<p>偏向锁在Java 6和Java 7里是默认启用的。由于偏向锁是为了在只有一个线程执行同步块时提高性能，如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a><strong>轻量级锁：</strong></h4><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h4 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a><strong>重量级锁：</strong></h4><p>重量级锁是依赖对象内部的monitor锁来实现。当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，需要从用户态转换到内核态，而转换状态是需要消耗很多时间。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>容器小记</title>
    <url>/2020/07/04/%E5%AE%B9%E5%99%A8%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="容器中的设计模式："><a href="#容器中的设计模式：" class="headerlink" title="容器中的设计模式："></a>容器中的设计模式：</h5><ol>
<li>迭代器模式；[例子：容器循环所使用的 Iterator 迭代器]</li>
<li>设配器模式：简单的说就是将原本两个不相干的类联系起来（类似于充电器，连接插座和用电器，将电压变成电器匹配的量级）；[例子：Arrays.asList() 将数组转换成List]</li>
</ol>
<h5 id="默认长度-amp-扩容大小："><a href="#默认长度-amp-扩容大小：" class="headerlink" title="默认长度 &amp; 扩容大小："></a>默认长度 &amp; 扩容大小：</h5><ol>
<li>List</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">默认大小</th>
<th>默认扩容</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayList</td>
<td align="center">10</td>
<td>原来的1.5倍</td>
<td align="center">由数组实现，因此支持快速随机访问；扩容操作需要将原数组整个复制到新数组中，代价很高；删除元素是将删除index后的元素复制到index的位置，代价很高；</td>
</tr>
<tr>
<td align="center">Vector</td>
<td align="center"></td>
<td>原来的2倍</td>
<td align="center">与ArrayList相似，但是使用了synchronized进行同步，是线程安全的</td>
</tr>
</tbody></table>
<h5 id="得到一个线程-安全的ArrayList替代方案："><a href="#得到一个线程-安全的ArrayList替代方案：" class="headerlink" title="得到一个线程 安全的ArrayList替代方案："></a>得到一个线程 安全的ArrayList替代方案：</h5><p>  ①   Collections.synchronizedList() </p>
<p>  ②   concurrent 并发包下的 CopyOnWriteArrayList 类</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList :"></a>CopyOnWriteArrayList :</h4><ol>
<li><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。  写操作需要加锁，防止并发写入时导致写入数据丢失。  写操作结束之后需要把原始数组指向新的复制数组。 </p>
</li>
<li><p>适用场景：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
</li>
</ol>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h4><p> 基于双向链表实现，使用 Node 存储链表节点信息。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表不支持随机访问，但插入删除只需要改变指针。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h4><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td>size</td>
<td>键值对数量。</td>
</tr>
<tr>
<td>threshold</td>
<td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td>loadFactor</td>
<td>装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md</a> (源码分析：1.7为主)</p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md</a> （详细讲解）</p>
<p> 从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。 </p>
<p><strong>这里需要注意：1.7  put方法在链表中采用头插法，即当数组位置相同，而key不同，就在这个链表的头部插入该元素；1.8中则是在链表尾部插入</strong></p>
<blockquote>
<p> 为什么要从头插法改成尾插法？ </p>
<p>A.因为头插法会造成死链，参考链接<a href="https://blog.csdn.net/chenyiminnanjing/article/details/82706942" target="_blank" rel="noopener">https://blog.csdn.net/chenyiminnanjing/article/details/82706942</a><br>B.JDK7用头插是考虑到了一个所谓的热点数据的点(新插入的数据可能会更早用到)，但这其实是个伪命题,因为JDK7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置(就是因为头插) 所以最后的结果 还是打乱了插入的顺序 所以总的来看支撑JDK7使用头插的这点原因也不足以支撑下去了 所以就干脆换成尾插 一举多得</p>
</blockquote>
<h6 id="与-Hashtable-的比较"><a href="#与-Hashtable-的比较" class="headerlink" title="与 Hashtable 的比较"></a>与 Hashtable 的比较</h6><ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h4 id="ConcurrentHashMap："><a href="#ConcurrentHashMap：" class="headerlink" title="ConcurrentHashMap："></a>ConcurrentHashMap：</h4><h6 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h6><p><a href="https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw</a> （详细讲解）</p>
<p>Java7 中 ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>
<p> Segment 继承自 ReentrantLock。 </p>
<p>Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
<p>JDK8之后，ConcurrentHashMap舍弃了ReentrantLock，而重新使用了synchronized。其原因大致有一下几点：</p>
<ol>
<li>加入多个分段锁浪费内存空间。</li>
<li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li>
<li>为了提高 GC 的效率</li>
</ol>
<p>新的ConcurrentHashMap中使用synchronized关键字+CAS操作保证了线程安全；详细信息 <a href="https://my.oschina.net/pingpangkuangmo/blog/817973#h2_12" target="_blank" rel="noopener">https://my.oschina.net/pingpangkuangmo/blog/817973#h2_12</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 默认的并发级别为 16，也就是说默认创建 16 个 Segment。 </p>
<h6 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h6><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="JDK-1-8-的改动"><a href="#JDK-1-8-的改动" class="headerlink" title="JDK 1.8 的改动"></a>JDK 1.8 的改动</h6><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h4 id="LinkedHashMap："><a href="#LinkedHashMap：" class="headerlink" title="LinkedHashMap："></a>LinkedHashMap：</h4><p> 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 </p>
<p> 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The head (eldest) of the doubly linked list.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The tail (youngest) of the doubly linked list.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h6 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h6><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h6><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h4><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>事务传播行为与事务隔离级别</title>
    <url>/2020/06/04/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h4 id="事务读传播行为"><a href="#事务读传播行为" class="headerlink" title="事务读传播行为"></a>事务读传播行为</h4><h6 id="·-保证同一个事务中"><a href="#·-保证同一个事务中" class="headerlink" title="· 保证同一个事务中"></a>· 保证同一个事务中</h6><p>PROPAGATION_REQUIRED支持当前事务，如果不存在，就新建一个（默认）<br>PROPAGATION_SUPPORTS支持当前事务，如果不存在，就不适用事务<br>PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常</p>
<h6 id="·-保证没有在同一个事务中"><a href="#·-保证没有在同一个事务中" class="headerlink" title="· 保证没有在同一个事务中"></a>· 保证没有在同一个事务中</h6><p>PROPAGATION_REQUIRES_NEW如果有事务存在，挂起当前事务，创建一个新的事务<br>PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务<br>PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常<br>PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>DEFAULT这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别；</p>
<h6 id="未提交读（read-uncommitted）："><a href="#未提交读（read-uncommitted）：" class="headerlink" title="未提交读（read uncommitted）："></a>未提交读（read uncommitted）：</h6><p>​    事务的修改，即使当前事务没有被提交，对其他事务而言也是可见的。事务可以读取未提交的数据，也称为脏读。这个级别会导致很多问题，性能上也不比其他级别好多少，一般不会使用；</p>
<h6 id="已提交读（read-committed）："><a href="#已提交读（read-committed）：" class="headerlink" title="已提交读（read committed）："></a>已提交读（read committed）：</h6><p>​    大部分数据库系统的默认隔离级别都是read committed（Mysql 不是），它表示一个事务只能看到已经提交的事务所做的修改。换个角度来讲，就是一个事务从开始到提交之前，所做的操作对别的操作都是不可见的。此隔离级别也被称为（<strong>不可重复读</strong>），因为多次执行同样的查询语句，可能会得出不一样的结果，因为可能有别的事务提交了。</p>
<h6 id="可重复读（repeatable-read）："><a href="#可重复读（repeatable-read）：" class="headerlink" title="可重复读（repeatable read）："></a>可重复读（repeatable read）：</h6><p>​    repeatable read解决了脏读的问题，该隔离级别保证了在同一个事务中每次读取都是同样的结果，但是还是无法解决幻读的问题。（<strong>幻读：</strong>指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再读取该范围内的记录时，会产生幻行；）【这是高性能Mysql中的解释，我的个人理解为：先读取的事务读不到后来新添加的记录，导致读取不准确】。但InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题，后面我会详细写到。</p>
<h6 id="可串行化的（serializable）："><a href="#可串行化的（serializable）：" class="headerlink" title="可串行化的（serializable）："></a>可串行化的（serializable）：</h6><p>强制事务串行执行，由于可能会导致大量的超时和锁争用，通常不考虑。<br>MySQL默认：可重复读<br>Oracle默认：已提交读</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet学习笔记</title>
    <url>/2020/05/04/servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="1-Tomcat主要在程序中做了些什么？"><a href="#1-Tomcat主要在程序中做了些什么？" class="headerlink" title="1.Tomcat主要在程序中做了些什么？"></a>1.Tomcat主要在程序中做了些什么？</h3><p>1.1  创建socket监听在对应的端口</p>
<p>1.2  维护一个线程池</p>
<p>1.3  当有TCP连接时分配一个线程来处理</p>
<p>1.4  从TCP连接中读取数据</p>
<p>1.5  按照HTTP协议解析数据</p>
<p>1.6  将解析后的数据包封装到request对象中</p>
<p>1.7  按照web.xml的映射关系找到对应的Servlet类</p>
<p>1.8  将最后的执行结果response组装成HTTP协议格式的数据包</p>
<p>1.9  重新通过TCP返回给客户端</p>
<h3 id="2-访问servlet-的过程"><a href="#2-访问servlet-的过程" class="headerlink" title="2.访问servlet 的过程"></a>2.访问servlet 的过程</h3><p>2.1  connector 负责监听端⼝,当有链接进来时分配线程并实例化HttpllProcessor对数据进⾏ HTTP协议解析,然后将请求交给其所在的engine即Catalina来处理,处理的是域名对应的ip和 端⼝8080 ,注意localhost任然没被使⽤ </p>
<p>2.2  engine将从HTTP请求头中获取host参数⽤于选择⼀个匹配的Host   处理的是主机名 localhost(Host可以配置多个,即你可以在⼀台电脑上部署两个完全不相关的web项⽬例如jd 和百度),此时处理的是域名即localhost</p>
<p>2.3  Host将在Context中查找匹配第⼀级路径的Context(web项⽬)   处理的是第⼀级路径(ServletLesson)</p>
<p>2.4  读取ServletLesson项⽬的web.xml配置,查找匹配TestServlet的Servlet</p>
<p>2.5  实例化Servlet,调⽤Service根据请求类型执⾏对应的Get或Post ,处理的真正的客户端请求</p>
<p>2.6  Servlet响应⽅法执⾏完毕后,响应数据依次返回-&gt;Context-&gt;Host-&gt;engine-&gt;connector</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Servlet</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>部署web到Tomcat的三种方式</title>
    <url>/2020/05/04/%E9%83%A8%E7%BD%B2web%E5%88%B0Tomcat%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>这里简单的记录tomcat的部署方式：</p>
<p>一、 直接将 web 项目文件（一般是复制生成的war包）复制到tomcat的webapps目录中 ；</p>
<p>二、在tomcat中的conf目录下的server.xml文件中，在<Host>节点中添加一个context，具体为：</Host></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">Path</span>=<span class="string">""</span> <span class="attr">Docbase</span>=<span class="string">"目标目录位置"</span> <span class="attr">Debug</span>=<span class="string">"0"</span> <span class="attr">Privileged</span>=<span class="string">"True"</span> <span class="attr">Reloadable</span>=<span class="string">"True"</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 Reloadable= “true” 这个属性是指tomcat在运行状态下会自动检测应用程序的WEB-INF/classes和WEB-INF/lib目录下的class文件，如果监测到有class文件有改动，服务器自动加载新的web应用程序，可以在不重起tomcat的情况下改变应用程序，也就是热部署；</p>
<p>一般我们会在开发阶段将Reloadable属性设为true，有助于调试servlet和其它的class文件，但是由于这样会增加服务器的运行负荷，损耗系统性能，在项目运行阶段建议将它设为false。</p>
<p>三、直接将编译后的项目复制到webapps中，直接访问</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式常见应用场景</title>
    <url>/2020/04/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="一、集合中的使用"><a href="#一、集合中的使用" class="headerlink" title="一、集合中的使用"></a>一、集合中的使用</h3><ul>
<li><h5 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化集合</span></span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"詹姆士"</span>,<span class="number">22</span>,<span class="string">"男"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"露西"</span>,<span class="number">21</span>,<span class="string">"女"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"弗兰克"</span>,<span class="number">25</span>,<span class="string">"男"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"爱丽丝"</span>,<span class="number">27</span>,<span class="string">"女"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"路易斯"</span>,<span class="number">22</span>,<span class="string">"男"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合 Lambda</span></span><br><span class="line">users.stream().forEach(user -&gt; System.out.println(user));</span><br><span class="line"><span class="comment">// 遍历集合 方法引用</span></span><br><span class="line">users.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>方法引用（::双冒号操作符）</strong></p>
<ol>
<li><p>其实就是一种Lambda表达式的简写方式，它提供了一种引用而不执行方法的方式，运行时，方法引用会创建一个函数式接口的实例。</p>
</li>
<li><p>方法引用的五种方式：</p>
<table>
<thead>
<tr>
<th align="center">—-</th>
<th align="center">—-</th>
</tr>
</thead>
<tbody><tr>
<td align="center">引用对象的实例方法</td>
<td align="center">对象::实例方法名</td>
</tr>
<tr>
<td align="center">引用类的静态方法</td>
<td align="center">类::静态方法名</td>
</tr>
<tr>
<td align="center">引用类的实例方法</td>
<td align="center">类::实例方法名</td>
</tr>
<tr>
<td align="center">引用构造方法</td>
<td align="center">类::new</td>
</tr>
<tr>
<td align="center">数组引用</td>
<td align="center">类型::new</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h5 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的toMap有三个参数，第一个取的名称为 key,第二个参数 表示整个user对象为一个 value,最后一个参数可以不加，它的作用是如果 key 值有重复的，如何处理</span></span><br><span class="line">Map&lt;String, User&gt; userMap = users.stream().collect(Collectors.toMap(User::getName, a -&gt; a, (k1, k2) -&gt; k1));</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="将List分组"><a href="#将List分组" class="headerlink" title="将List分组"></a>将List分组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据性别进行分类</span></span><br><span class="line">Map&lt;String, List&lt;User&gt;&gt; groupBy = users.stream().collect(Collectors.groupingBy(User::getSex));</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="集合过滤"><a href="#集合过滤" class="headerlink" title="集合过滤"></a>集合过滤</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤出男性</span></span><br><span class="line">List&lt;User&gt; filterList = users.stream().filter(user -&gt; user.getSex().equals(<span class="string">"男"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="集合求和"><a href="#集合求和" class="headerlink" title="集合求和"></a>集合求和</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 年龄和</span></span><br><span class="line"><span class="keyword">int</span> sum = users.stream().mapToInt(User::getAge).sum();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、代替Runnable"><a href="#二、代替Runnable" class="headerlink" title="二、代替Runnable"></a>二、代替Runnable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用Lambda实现Runnable里的run方法</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">   System.out.println(Thread.currentThread().getName());</span><br><span class="line"> &#125;  ;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="三、Predicate条件过滤"><a href="#三、Predicate条件过滤" class="headerlink" title="三、Predicate条件过滤"></a>三、Predicate条件过滤</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">       filter(numbers,number -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> (<span class="keyword">int</span>)number &gt; <span class="number">2</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 过滤方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List list, Predicate condition)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       list.forEach(number -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (condition.test(number))&#123;</span><br><span class="line">               System.out.println(number);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、Map映射"><a href="#四、Map映射" class="headerlink" title="四、Map映射"></a>四、Map映射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将返回一个将每个数字都×2的新List</span></span><br><span class="line">List&lt;Integer&gt; mapList = numbers.stream().map(number -&gt; number * <span class="number">2</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="五、Reduce聚合"><a href="#五、Reduce聚合" class="headerlink" title="五、Reduce聚合"></a>五、Reduce聚合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回所有成员的和</span></span><br><span class="line">Integer sum = numbers.stream().reduce((x, y) -&gt; x + y).get();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反射机制</title>
    <url>/2020/04/13/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JAVA反射机制"><a href="#JAVA反射机制" class="headerlink" title="JAVA反射机制"></a>JAVA反射机制</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>java反射机制是在运行状态中，对于任意一个类，都能够得到这个类的所有属性和方法；对于任意一个对象，都能调用它的任意方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为<strong>反射机制</strong></p>
<h3 id="获取Class对象的两种方式"><a href="#获取Class对象的两种方式" class="headerlink" title="获取Class对象的两种方式"></a>获取Class对象的两种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.如果我们知道具体的类,可以使用下面的代码，[类名.class];但是通常情况下我们是不知道具体的类的，并且还需要导入类的包，依赖太强。</span></span><br><span class="line">Class targetClass = TargetObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过[Class.forName()]小括号中传入类的字符串路径获取，字符串可以写在配置文件中。</span></span><br><span class="line">Class targetClass = Class.forName(<span class="string">"frosro.test.TargetObject"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.其实还有一种方法，继承自Object类的getClass方法，如下，但这样对象都已经存在了，我们再用反射就多此一举了。</span></span><br><span class="line">TargetObject targetObject = <span class="keyword">new</span> TargetObject();</span><br><span class="line">Class targetClass = targetObject.getClass();</span><br></pre></td></tr></table></figure>

<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>首先创建一个我们将要操作的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 21:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = <span class="string">"initVal"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I love "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用反射来操作这个类的方法和参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package fanshe;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author sy</span><br><span class="line"> * @data \ 21:36</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取TargetObject类的Class对象</span><br><span class="line">        Class&lt;?&gt; tagetClass  &#x3D; Class.forName(&quot;fanshe.TargetObject&quot;);</span><br><span class="line">        &#x2F;&#x2F; 创建一个TargetObject类的实例</span><br><span class="line">        TargetObject targetObject &#x3D; (TargetObject)tagetClass .newInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取类中所有定义的方法</span><br><span class="line">        Method[] methods &#x3D; tagetClass.getDeclaredMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环输出方法名称</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取指定方法并调用</span><br><span class="line">        Method publicMethod &#x3D; tagetClass.getDeclaredMethod(&quot;publicMethod&quot;, String.class);</span><br><span class="line">        publicMethod.invoke(targetObject,&quot;frosro&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取指定参数</span><br><span class="line">        Field field &#x3D; tagetClass.getDeclaredField(&quot;value&quot;);</span><br><span class="line">        &#x2F;&#x2F; 取消安全检查，这样我们就可以访问到私有的属性和方法</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        &#x2F;&#x2F; 对参数进行修改</span><br><span class="line">        field.set(targetObject,&quot;frosro&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 调用私有的方法</span><br><span class="line">        Method privateMethod &#x3D; tagetClass.getDeclaredMethod(&quot;privateMethod&quot;);</span><br><span class="line">        privateMethod.setAccessible(true);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有其他很多方法，可以翻看文档查找；</p>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li><p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。 </p>
</li>
<li><p>缺点：  </p>
<p>1.性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。</p>
<p>2.安全问题：让我们可以动态操作改变类的属性同时也增加了类的安全隐患。 </p>
</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
</ol>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA集合的多种遍历方式总结</title>
    <url>/2020/03/29/JAVA%E9%9B%86%E5%90%88%E7%9A%84%E5%A4%9A%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Collection 集合 :  总的来说分为以下这三类，这里更多的子类我便不在阐述了。</li>
</ol>
<ul>
<li>Set ： 无序集合，元素不可重复；</li>
<li>Queue  ： 队列；</li>
<li>List ： 有序集合，元素可以重复；</li>
</ul>
<ol start="2">
<li>Map集合 ：一般用于保存拥有映射关系的数据，也就是 key-value 键值对，它也有很多子类，这里不细说；</li>
</ol>
<hr>
<p>本文以HashSet 为例，总结遍历方式。当然像List这种有序集合还可以通过for循环的方式遍历。</p>
<p><strong>下面是主要内容：</strong></p>
<h3 id="一、使用-Lambda-表达式遍历集合"><a href="#一、使用-Lambda-表达式遍历集合" class="headerlink" title="一、使用 Lambda 表达式遍历集合"></a>一、使用 Lambda 表达式遍历集合</h3><p>从 JDK8 开始，Iterable 接口新增了 forEach(Consumer action)方法，主要 是使用 Lambda 表达式更加简洁的操作。Consumer 其实是一个函数式接 口，只要是函数式接口，都能够使用 Lambda 表示来进行替代。在调用这 个方法的时候，其实会依次将集合的元素传递给 Consumer 中的 accept(T t) 方法去处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 21:34</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CollectionEach &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line">        books.forEach(str -&gt; System.out.println(&quot;书名：&quot;  + str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、-使用-Iterator-遍历集合元素"><a href="#二、-使用-Iterator-遍历集合元素" class="headerlink" title="二、 使用 Iterator 遍历集合元素"></a>二、 使用 Iterator 遍历集合元素</h3><p>Iterator 主要用来遍历 Conllection 集合中的元素，也叫迭代器。它只能用于遍历集合。</p>
<p>常用方法如下：</p>
<ul>
<li>hasNext()：判断集合中还有没有元素，如果有则返回 true。 </li>
<li>next()：取出集合中的下一个元素。 </li>
<li>remove()：移除上面 next() 方法中读取的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 21:48</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IteratorTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过 iterator() 方法，获取 books 集合对应的迭 代器</span><br><span class="line">        Iterator&lt;String&gt; iterator &#x3D; books.iterator();</span><br><span class="line"></span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String next &#x3D; iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 对 next 变量赋值，不会改变集合元素本身</span><br><span class="line">            &#x2F;&#x2F; Iterator 并不会把集合元素本身交给迭代变 量，</span><br><span class="line">            &#x2F;&#x2F; 而是把集合元素的值交给了迭代变量</span><br><span class="line">            &#x2F;&#x2F; 所以在修改迭代变量的值之后对集合远古三本身并 没有任何覆盖。</span><br><span class="line">            next &#x3D; &quot;设计模式&quot;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果我们在使用迭代器的过程中改变了集合元素的值，也就是books,比如</span><br><span class="line">            &#x2F;&#x2F; books.remove(next);</span><br><span class="line">            &#x2F;&#x2F; 上面这行代码运行会报 ConcurrentModificationException 异常</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上，是因为 Iterator 迭代器使用了 fail-fast 机制（快速失败机制）， 在迭代过程中一旦发现有其他线程来修改该集合，则马上报 ConcurrentModicationException 异常，这样做可以避免共享资源而埋下其他隐患问题。</p>
<h3 id="三、-使用-Lambda-表达式遍历-Iterator"><a href="#三、-使用-Lambda-表达式遍历-Iterator" class="headerlink" title="三、 使用 Lambda 表达式遍历 Iterator"></a>三、 使用 Lambda 表达式遍历 Iterator</h3><p>核心方法：</p>
<ul>
<li>forEachRemaining()：JDK8 新增方法，使用 Lambda 表达式来遍历集合元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:06</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IteratorEach &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator &#x3D; books.iterator();</span><br><span class="line"></span><br><span class="line">        iterator.forEachRemaining(str -&gt; System.out.println(&quot;迭代集合元素：&quot; + str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、-使用-foreach-循环遍历集合元素"><a href="#四、-使用-foreach-循环遍历集合元素" class="headerlink" title="四、  使用 foreach 循环遍历集合元素"></a>四、  使用 foreach 循环遍历集合元素</h3><p>foreach 循环，是我们常用的一种遍历方式。另外，foreach 循环中迭代变量也不是集合元素本身，其实也是把每个集合元素的值赋给了迭代变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:13</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ForeachTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        for (String book : books) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 改变book的值，并不会改变books集合的数据</span><br><span class="line">            &#x2F;&#x2F; 因为book只是保存着books其中的一个值</span><br><span class="line">            book &#x3D; &quot;设计模式&quot;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 同样的，我们也不能在遍历时改变原有的集合books</span><br><span class="line">            &#x2F;&#x2F; 如果像下面这种方式，会报 ConcurrentModificationException</span><br><span class="line">            &#x2F;&#x2F; books.remove(book);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、-使用-Stream遍历集合"><a href="#五、-使用-Stream遍历集合" class="headerlink" title="五、  使用 Stream遍历集合"></a>五、  使用 Stream遍历集合</h3><p>JDK8 新增了 Stream、IntStream、LongStream、DoubleStream 等强悍的 流式 API，代表多个支持串行 &amp; 并行聚集操作的元素。还可以通过特别提 供的 Builder 来创建对应的流。</p>
<p>使用步骤：</p>
<p> 1）使用 Stream 或 XxxStream 的 builder() 方法初始化对应 的 Builder。<br>2）多次调用 Builder 的 add() 方法，添加元素<br>3）调用 Builder 的 build() 方法获取对应的 Stream。<br>4）调用 Stream 的聚集方法。（具体参考 API 文档）</p>
<p>Stream 提供了很多方法，可以归类为两种：</p>
<ul>
<li>Intermediate（中间方法）<br>中间方法，指的是中间操作允许流保持打开状态，并允许直接调用后续方 法，中间方法的返回值是另外一个流。</li>
<li>Terminal（末端方法）<br>末端方法，指的是对流的终操作，执行过后，该流就会被“消耗”且不再可用。因为我们在操作的时候，是在内存中的缓存中，如果操作完毕，它将会从缓冲中刷新flush() 出来，就不能再改了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:29</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IntStreamTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       Stream stream &#x3D; Stream.builder()</span><br><span class="line">               .add(&quot;编程思想&quot;)</span><br><span class="line">                .add(&quot;核心技术&quot;)</span><br><span class="line">                .add(&quot;从入门到放弃&quot;).build();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 当然，这里不可避免的用到了forEach</span><br><span class="line">       stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者是这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:29</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IntStreamTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        books.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能你会觉得这和第一种方式很像，我测试了一下，这两者效率也相差无几。<br>但是stream流却是目前必须掌握的方式。因为它的一些其他用法都颇为重要。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>循环</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博文</title>
    <url>/2020/03/28/myfirstPage/</url>
    <content><![CDATA[<p>我的个人博客算是建立了，中间遇到比较坑的就是，我想要使用java做分类，但总是报404，但是JAVA却可以，没找到原因；还有就是阿里云的域名真的是坑，提交了十几个实名认证还是没通过，太考验耐心了。markdown还不太会用，渐渐熟练吧，之后我会把遇到的好的经验分享到这个博客，其他教程什么的网上太多了，我就不在这上面添加了，我只写我认为有价值的博文，如果哪位同学有问题或者想要和我在技术上交流，可以联系我，我会非常乐意分享我所知道的信息。大家一起学习，共同进步为社会主义做贡献！</p>
]]></content>
      <categories>
        <category>🐟台小记</category>
      </categories>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
</search>
