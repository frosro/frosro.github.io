<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java容器</title>
    <url>/2020/07/16/java%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18. Java 容器都有哪些？"></a><strong>18. Java</strong> <strong>容器都有哪些？</strong></h4><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>·    Collection</p>
<p>·    List</p>
<p>o  ArrayList</p>
<p>o  LinkedList</p>
<p>o  Vector</p>
<p>o  Stack</p>
<p>·    Set</p>
<p>o  HashSet</p>
<p>o  LinkedHashSet</p>
<p>o  TreeSet</p>
<p>·    Map</p>
<p>·    HashMap</p>
<p>o  LinkedHashMap</p>
<p>·    TreeMap</p>
<p>·    ConcurrentHashMap</p>
<p>·    Hashtable</p>
<h4 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a><strong>19. Collection</strong> <strong>和</strong> <strong>Collections</strong> <strong>有什么区别？</strong></h4><p>·    Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</p>
<p>·    Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p>
<h4 id="20-List、Set、-Map-之间的区别是什么？"><a href="#20-List、Set、-Map-之间的区别是什么？" class="headerlink" title="20. List、Set、*Map *之间的区别是什么？"></a><strong>20. List</strong>、<strong><strong>Set</strong></strong>、<strong>*<em>Map *</em>之间的区别是什么？</strong></h4><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p>三者之间的区别，如下表：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2020/07/16/java%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/%E5%9B%BE1.png"  alt="区别图"></p>
<h4 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a><strong>21. HashMap</strong> <strong>和</strong> <strong>Hashtable</strong> <strong>有什么区别？</strong></h4><p>·    存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</p>
<p>·    线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</p>
<p>·    推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>
<h4 id="22-如何决定使用-HashMap-还是-TreeMap-？"><a href="#22-如何决定使用-HashMap-还是-TreeMap-？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap**？**"></a><strong>22.</strong> <strong>如何决定使用</strong> <strong>HashMap</strong> <strong>还是</strong> <strong>TreeMap**</strong>？**</h4><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h4 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a><strong>23.</strong> <strong>说一下</strong> <strong>HashMap</strong> <strong>的实现原理？</strong></h4><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h4 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a><strong>24.</strong> <strong>说一下</strong> <strong>HashSet</strong> <strong>的实现原理？</strong></h4><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h4 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a><strong>25. ArrayList</strong> <strong>和</strong> <strong>LinkedList</strong> <strong>的区别是什么？</strong></h4><p>·    数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p>
<p>·    随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p>·    增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<h4 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a><strong>26.</strong> <strong>如何实现数组和</strong> <strong>List</strong> <strong>之间的转换？</strong></h4><p>·    数组转 List：使用 Arrays. asList(array) 进行转换。</p>
<p>·    List 转数组：使用 List 自带的 toArray() 方法。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">list. add(<span class="string">"王磊"</span>);</span><br><span class="line"></span><br><span class="line">list. add(<span class="string">"的博客"</span>);</span><br><span class="line"></span><br><span class="line">list. toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line"></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"王磊"</span>,<span class="string">"的博客"</span>&#125;;</span><br><span class="line"></span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>

<h4 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27. ArrayList 和 Vector 的区别是什么？"></a><strong>27. ArrayList</strong> <strong>和</strong> <strong>Vector</strong> <strong>的区别是什么？</strong></h4><p>·    线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</p>
<p>·    性能：ArrayList 在性能方面要优于 Vector。</p>
<p>·    扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p>
<h4 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28. Array 和 ArrayList 有何区别？"></a><strong>28. Array</strong> <strong>和</strong> <strong>ArrayList</strong> <strong>有何区别？</strong></h4><p>·    Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p>
<p>·    Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p>
<p>·    Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p>
<h4 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll()和 remove()有什么区别？"></a><strong>29.</strong> <strong>在</strong> <strong>Queue</strong> <strong>中</strong> <strong>poll()</strong>和 <strong>remove()有什么区别？</strong></h4><p>·    相同点：都是返回第一个元素，并在队列中删除返回的对象。</p>
<p>·    不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">queue. offer(<span class="string">"string"</span>); <span class="comment">// add</span></span><br><span class="line"></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line"></span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line"></span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure>



<h4 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a><strong>30.</strong> <strong>哪些集合类是线程安全的？</strong></h4><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h4 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a><strong>31.</strong> <strong>迭代器</strong> <strong>Iterator</strong> <strong>是什么？</strong></h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h4 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a><strong>32. Iterator</strong> <strong>怎么使用？有什么特点？</strong></h4><p>Iterator 使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line"></span><br><span class="line"> String obj = it. next();</span><br><span class="line"></span><br><span class="line"> System. out. println(obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h4 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a><strong>33. Iterator</strong> <strong>和</strong> <strong>ListIterator</strong> <strong>有什么区别？</strong></h4><p>·    Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</p>
<p>·    Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</p>
<p>·    ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
<h4 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34. 怎么确保一个集合不能被修改？"></a><strong>34.</strong> <strong>怎么确保一个集合不能被修改？</strong></h4><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list. add(<span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line"></span><br><span class="line">clist. add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line"></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>容器</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础知识总结</title>
    <url>/2020/07/16/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<h4 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a><strong>1. JDK</strong> <strong>和</strong> <strong>JRE</strong> <strong>有什么区别？</strong></h4><p>·    JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</p>
<p>·    JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</p>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>
<h4 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a><strong>2. ==</strong> <strong>和</strong> <strong>equals</strong> <strong>的区别是什么？</strong></h4><p>== 解读</p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<p>·    基本类型：比较的是值是否相同；</p>
<p>·    引用类型：比较的是引用是否相同；</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line"></span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line"></span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p>equals 解读</p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line"></span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"></span><br><span class="line">​    String anotherString = (String)anObject;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> n = value.length;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">char</span> v1[] = value;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"></span><br><span class="line">​          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">​        i++;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h4 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a><strong>3.</strong> <strong>两个对象的</strong> <strong>hashCode()</strong> <strong>相同，则</strong> <strong>equals()</strong> <strong>也一定为</strong> <strong>true</strong>，对吗？</h4><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"通话"</span>;</span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">"重地"</span>;</span><br><span class="line"></span><br><span class="line">System. out. println(String. format(<span class="string">"str1：%d | str2：%d"</span>, str1. hashCode(),str2. hashCode()));</span><br><span class="line"></span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure>

<p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p> false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h4 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4. final 在 Java 中有什么作用？"></a><strong>4. final</strong> <strong>在</strong> <strong>Java</strong> <strong>中有什么作用？</strong></h4><p>·    final 修饰的类叫最终类，该类不能被继承。</p>
<p>·    final 修饰的方法不能被重写。</p>
<p>·    final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h4 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. Java 中的 Math. round(-1. 5) 等于多少？"></a><strong>5. Java</strong> <strong>中的</strong> <strong>Math. round(-1. 5)</strong> <strong>等于多少？</strong></h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h4 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a><strong>6. String</strong> <strong>属于基础的数据类型吗？</strong></h4><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h4 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a><strong>7. Java</strong> <strong>中操作字符串都有哪些类？它们之间有什么区别？</strong></h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h4 id="8-String-str-”i”-与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=”i”**与** String str=new String(“i”)**一样吗？**"></a><strong>8. String str=”i”**</strong>与** <strong>String str=new String(“i”)**</strong>一样吗？**</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h4 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a><strong>9.</strong> <strong>如何将字符串反转？</strong></h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line"></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">stringBuffer. append(<span class="string">"abcdefg"</span>);</span><br><span class="line"></span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">stringBuilder. append(<span class="string">"abcdefg"</span>);</span><br><span class="line"></span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>

<h4 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a><strong>10. String</strong> <strong>类的常用方法都有那些？</strong></h4><p>·    indexOf()：返回指定字符的索引。</p>
<p>·    charAt()：返回指定索引处的字符。</p>
<p>·    replace()：字符串替换。</p>
<p>·    trim()：去除字符串两端空白。</p>
<p>·    split()：分割字符串，返回一个分割后的字符串数组。</p>
<p>·    getBytes()：返回字符串的 byte 类型数组。</p>
<p>·    length()：返回字符串长度。</p>
<p>·    toLowerCase()：将字符串转成小写字母。</p>
<p>·    toUpperCase()：将字符串转成大写字符。</p>
<p>·    substring()：截取字符串。</p>
<p>·    equals()：字符串比较。</p>
<h4 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a><strong>11.</strong> <strong>抽象类必须要有抽象方法吗？</strong></h4><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<p>abstract class Cat {</p>
<p>  public static void sayHi() {</p>
<p>​    System. out. println(“hi~”);</p>
<p>  }</p>
<p>}</p>
<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h4 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a><strong>12.</strong> <strong>普通类和抽象类有哪些区别？</strong></h4><p>·    普通类不能包含抽象方法，抽象类可以包含抽象方法。</p>
<p>·    抽象类不能直接实例化，普通类可以直接实例化。</p>
<h4 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a><strong>13.</strong> <strong>抽象类能使用</strong> <strong>final</strong> <strong>修饰吗？</strong></h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="/2020/07/16/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C/img.png"  alt="图1"></p>
<h4 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a><strong>14.</strong> <strong>接口和抽象类有什么区别？</strong></h4><p>·    实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</p>
<p>·    构造函数：抽象类可以有构造函数；接口不能有。</p>
<p>·    实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</p>
<p>·    访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p>
<h4 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15. Java 中 IO 流分为几种？"></a><strong>15. Java</strong> <strong>中</strong> <strong>IO</strong> <strong>流分为几种？</strong></h4><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h4 id="16-BIO、NIO、AIO有什么区别？"><a href="#16-BIO、NIO、AIO有什么区别？" class="headerlink" title="16. BIO、NIO、AIO有什么区别？"></a><strong>16. BIO、NIO、AIO有什么区别？</strong></h4><p>·    BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p>
<p>·    NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p>
<p>·    AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h4 id="17-Files-的常用方法都有哪些？"><a href="#17-Files-的常用方法都有哪些？" class="headerlink" title="17. Files**的常用方法都有哪些？**"></a><strong>17. Files**</strong>的常用方法都有哪些？**</h4><p>·    Files. exists()：检测文件路径是否存在。</p>
<p>·    Files. createFile()：创建文件。</p>
<p>·    Files. createDirectory()：创建文件夹。</p>
<p>·    Files. delete()：删除一个文件或目录。</p>
<p>·    Files. copy()：复制文件。</p>
<p>·    Files. move()：移动文件。</p>
<p>·    Files. size()：查看文件个数。</p>
<p>·    Files. read()：读取文件。</p>
<p>·    Files. write()：写入文件。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试题</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机</title>
    <url>/2020/07/06/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E4%B8%80%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F" target="_blank" rel="noopener">参考连接</a></p>
<p>问题一、为什么在执行本地方法时程序计数器为空。</p>
<p>问题二、 </p>
<p>（待续）</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS和Synchronized的区别</title>
    <url>/2020/07/05/CAS%E5%92%8CSynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md" target="_blank" rel="noopener">更多资源</a>：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md</a></p>
<h3 id="一、CAS"><a href="#一、CAS" class="headerlink" title="一、CAS"></a>一、CAS</h3><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p> CAS（Compare And Swap ) 或（ Compare-and-Set ）是乐观锁的一种实现方式，是一种轻量级锁。JAVA1.5开始引入了CAS，JUC下很多工具类都是基于CAS。 </p>
<h5 id="CAS的实现方式"><a href="#CAS的实现方式" class="headerlink" title="CAS的实现方式:"></a><strong>CAS的实现方式:</strong></h5><p> CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。当多个线程同时尝试使用CAS更新一个变量时，任何时候只有一个线程可以更新成功，若更新失败，线程会重新进入循环再次进行尝试。 </p>
<h5 id="CAS带来的问题"><a href="#CAS带来的问题" class="headerlink" title="CAS带来的问题"></a>CAS带来的问题</h5><h6 id="ABA问题-："><a href="#ABA问题-：" class="headerlink" title="ABA问题 ："></a><strong>ABA问题</strong> ：</h6><p>ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。ABA问题的解决思路是，每次变量更新的时候把变量的版本号加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题。在JDK的java.util.concurrent.atomic包中提供了AtomicStampedReference来解决ABA问题，该类的compareAndSet是该类的核心方法，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                            V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">   Pair&lt;V&gt; current = pair;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">       expectedReference == current.reference &amp;&amp;</span><br><span class="line">       expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">       ((newReference == current.reference &amp;&amp;</span><br><span class="line">         newStamp == current.stamp) ||</span><br><span class="line">        casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，该类检查了当前引用与当前标志是否与预期相同，如果全部相等，才会以原子方式将该引用和该标志的值设为新的更新值，这样CAS操作中的比较就不依赖于变量的值了。</p>
<h3 id="二、synchronized"><a href="#二、synchronized" class="headerlink" title="二、synchronized"></a>二、synchronized</h3><p>相比于CAS基于乐观锁实现，synchronized是基于悲观锁的，当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p>
<ul>
<li>对于普通同步方法加锁时，锁是当前实例对象</li>
<li>对于静态同步方法加锁时，锁是当前类的Class对象</li>
<li>对于同步方法块加锁时，锁是Synchonized括号里配置的对象</li>
</ul>
<h5 id="Synchronized的实现方式："><a href="#Synchronized的实现方式：" class="headerlink" title="Synchronized的实现方式："></a><strong>Synchronized的实现方式：</strong></h5><p>Synchonized是基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。Synchronized 用在方法上时，在字节码中是通过方法的 ACC_SYNCHRONIZED 标志来实现的。而代码块同步则是使用monitorenter和monitorexit指令实现的。</p>
<p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁，当获得对象的monitor以后，monitor内部的计数器就会自增（初始为0），当同一个线程再次获得monitor的时候，计数器会再次自增。当同一个线程执行monitorexit指令的时候，计数器会进行自减，当计数器为0的时候，monitor就会被释放，其他线程便可以获得monitor。</p>
<h5 id="Synchronized的优化："><a href="#Synchronized的优化：" class="headerlink" title="Synchronized的优化："></a><strong>Synchronized的优化：</strong></h5><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<h5 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a><strong>偏向锁：</strong></h5><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<h5 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a><strong>轻量级锁：</strong></h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h5 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a><strong>重量级锁：</strong></h5><p>重量级锁是依赖对象内部的monitor锁来实现。当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，需要从用户态转换到内核态，而转换状态是需要消耗很多时间。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>容器小记</title>
    <url>/2020/07/04/%E5%AE%B9%E5%99%A8%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="容器中的设计模式："><a href="#容器中的设计模式：" class="headerlink" title="容器中的设计模式："></a>容器中的设计模式：</h5><ol>
<li>迭代器模式；[例子：容器循环所使用的 Iterator 迭代器]</li>
<li>设配器模式：简单的说就是将原本两个不相干的类联系起来（类似于充电器，连接插座和用电器，将电压变成电器匹配的量级）；[例子：Arrays.asList() 将数组转换成List]</li>
</ol>
<h5 id="默认长度-amp-扩容大小："><a href="#默认长度-amp-扩容大小：" class="headerlink" title="默认长度 &amp; 扩容大小："></a>默认长度 &amp; 扩容大小：</h5><ol>
<li>List</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">默认大小</th>
<th>默认扩容</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayList</td>
<td align="center">10</td>
<td>原来的1.5倍</td>
<td align="center">由数组实现，因此支持快速随机访问；扩容操作需要将原数组整个复制到新数组中，代价很高；删除元素是将删除index后的元素复制到index的位置，代价很高；</td>
</tr>
<tr>
<td align="center">Vector</td>
<td align="center"></td>
<td>原来的2倍</td>
<td align="center">与ArrayList相似，但是使用了synchronized进行同步，是线程安全的</td>
</tr>
</tbody></table>
<h5 id="得到一个线程-安全的ArrayList替代方案："><a href="#得到一个线程-安全的ArrayList替代方案：" class="headerlink" title="得到一个线程 安全的ArrayList替代方案："></a>得到一个线程 安全的ArrayList替代方案：</h5><p>  ①   Collections.synchronizedList() </p>
<p>  ②   concurrent 并发包下的 CopyOnWriteArrayList 类</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList :"></a>CopyOnWriteArrayList :</h4><ol>
<li><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。  写操作需要加锁，防止并发写入时导致写入数据丢失。  写操作结束之后需要把原始数组指向新的复制数组。 </p>
</li>
<li><p>适用场景：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
</li>
</ol>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h4><p> 基于双向链表实现，使用 Node 存储链表节点信息。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表不支持随机访问，但插入删除只需要改变指针。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h4><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td>size</td>
<td>键值对数量。</td>
</tr>
<tr>
<td>threshold</td>
<td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td>loadFactor</td>
<td>装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md</a> (源码分析：1.7为主)</p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md</a> （详细讲解）</p>
<p> 从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。 </p>
<p><strong>这里需要注意：1.7  put方法在链表中采用头插法，即当数组位置相同，而key不同，就在这个链表的头部插入该元素；1.8中则是在链表尾部插入</strong></p>
<blockquote>
<p> 为什么要从头插法改成尾插法？ </p>
<p>A.因为头插法会造成死链，参考链接<a href="https://blog.csdn.net/chenyiminnanjing/article/details/82706942" target="_blank" rel="noopener">https://blog.csdn.net/chenyiminnanjing/article/details/82706942</a><br>B.JDK7用头插是考虑到了一个所谓的热点数据的点(新插入的数据可能会更早用到)，但这其实是个伪命题,因为JDK7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置(就是因为头插) 所以最后的结果 还是打乱了插入的顺序 所以总的来看支撑JDK7使用头插的这点原因也不足以支撑下去了 所以就干脆换成尾插 一举多得</p>
</blockquote>
<h6 id="与-Hashtable-的比较"><a href="#与-Hashtable-的比较" class="headerlink" title="与 Hashtable 的比较"></a>与 Hashtable 的比较</h6><ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h4 id="ConcurrentHashMap："><a href="#ConcurrentHashMap：" class="headerlink" title="ConcurrentHashMap："></a>ConcurrentHashMap：</h4><h6 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h6><p><a href="https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw</a> （详细讲解）</p>
<p>Java7 中 ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>
<p> Segment 继承自 ReentrantLock。 </p>
<p>Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
<p>JDK8之后，ConcurrentHashMap舍弃了ReentrantLock，而重新使用了synchronized。其原因大致有一下几点：</p>
<ol>
<li>加入多个分段锁浪费内存空间。</li>
<li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li>
<li>为了提高 GC 的效率</li>
</ol>
<p>新的ConcurrentHashMap中使用synchronized关键字+CAS操作保证了线程安全；详细信息 <a href="https://my.oschina.net/pingpangkuangmo/blog/817973#h2_12" target="_blank" rel="noopener">https://my.oschina.net/pingpangkuangmo/blog/817973#h2_12</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 默认的并发级别为 16，也就是说默认创建 16 个 Segment。 </p>
<h6 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h6><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="JDK-1-8-的改动"><a href="#JDK-1-8-的改动" class="headerlink" title="JDK 1.8 的改动"></a>JDK 1.8 的改动</h6><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h4 id="LinkedHashMap："><a href="#LinkedHashMap：" class="headerlink" title="LinkedHashMap："></a>LinkedHashMap：</h4><p> 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 </p>
<p> 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The head (eldest) of the doubly linked list.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The tail (youngest) of the doubly linked list.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h6 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h6><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h6><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h4><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>事务传播行为与事务隔离级别</title>
    <url>/2020/06/04/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h4 id="事务读传播行为"><a href="#事务读传播行为" class="headerlink" title="事务读传播行为"></a>事务读传播行为</h4><h6 id="·-保证同一个事务中"><a href="#·-保证同一个事务中" class="headerlink" title="· 保证同一个事务中"></a>· 保证同一个事务中</h6><p>PROPAGATION_REQUIRED支持当前事务，如果不存在，就新建一个（默认）<br>PROPAGATION_SUPPORTS支持当前事务，如果不存在，就不适用事务<br>PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常</p>
<h6 id="·-保证没有在同一个事务中"><a href="#·-保证没有在同一个事务中" class="headerlink" title="· 保证没有在同一个事务中"></a>· 保证没有在同一个事务中</h6><p>PROPAGATION_REQUIRES_NEW如果有事务存在，挂起当前事务，创建一个新的事务<br>PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务<br>PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常<br>PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>DEFAULT这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别；</p>
<h6 id="未提交读（read-uncommitted）："><a href="#未提交读（read-uncommitted）：" class="headerlink" title="未提交读（read uncommitted）："></a>未提交读（read uncommitted）：</h6><p>​    事务的修改，即使当前事务没有被提交，对其他事务而言也是可见的。事务可以读取未提交的数据，也称为脏读。这个级别会导致很多问题，性能上也不比其他级别好多少，一般不会使用；</p>
<h6 id="已提交读（read-committed）："><a href="#已提交读（read-committed）：" class="headerlink" title="已提交读（read committed）："></a>已提交读（read committed）：</h6><p>​    大部分数据库系统的默认隔离级别都是read committed（Mysql 不是），它表示一个事务只能看到已经提交的事务所做的修改。换个角度来讲，就是一个事务从开始到提交之前，所做的操作对别的操作都是不可见的。此隔离级别也被称为（<strong>不可重复读</strong>），因为多次执行同样的查询语句，可能会得出不一样的结果，因为可能有别的事务提交了。</p>
<h6 id="可重复读（repeatable-read）："><a href="#可重复读（repeatable-read）：" class="headerlink" title="可重复读（repeatable read）："></a>可重复读（repeatable read）：</h6><p>​    repeatable read解决了脏读的问题，该隔离级别保证了在同一个事务中每次读取都是同样的结果，但是还是无法解决幻读的问题。（<strong>幻读：</strong>指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再读取该范围内的记录时，会产生幻行；）【这是高性能Mysql中的解释，我的个人理解为：先读取的事务读不到后来新添加的记录，导致读取不准确】。但InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题，后面我会详细写到。</p>
<h6 id="可串行化的（serializable）："><a href="#可串行化的（serializable）：" class="headerlink" title="可串行化的（serializable）："></a>可串行化的（serializable）：</h6><p>强制事务串行执行，由于可能会导致大量的超时和锁争用，通常不考虑。<br>MySQL默认：可重复读<br>Oracle默认：已提交读</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet学习笔记</title>
    <url>/2020/05/04/servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="1-Tomcat主要在程序中做了些什么？"><a href="#1-Tomcat主要在程序中做了些什么？" class="headerlink" title="1.Tomcat主要在程序中做了些什么？"></a>1.Tomcat主要在程序中做了些什么？</h3><p>1.1  创建socket监听在对应的端口</p>
<p>1.2  维护一个线程池</p>
<p>1.3  当有TCP连接时分配一个线程来处理</p>
<p>1.4  从TCP连接中读取数据</p>
<p>1.5  按照HTTP协议解析数据</p>
<p>1.6  将解析后的数据包封装到request对象中</p>
<p>1.7  按照web.xml的映射关系找到对应的Servlet类</p>
<p>1.8  将最后的执行结果response组装成HTTP协议格式的数据包</p>
<p>1.9  重新通过TCP返回给客户端</p>
<h3 id="2-访问servlet-的过程"><a href="#2-访问servlet-的过程" class="headerlink" title="2.访问servlet 的过程"></a>2.访问servlet 的过程</h3><p>2.1  connector 负责监听端⼝,当有链接进来时分配线程并实例化HttpllProcessor对数据进⾏ HTTP协议解析,然后将请求交给其所在的engine即Catalina来处理,处理的是域名对应的ip和 端⼝8080 ,注意localhost任然没被使⽤ </p>
<p>2.2  engine将从HTTP请求头中获取host参数⽤于选择⼀个匹配的Host   处理的是主机名 localhost(Host可以配置多个,即你可以在⼀台电脑上部署两个完全不相关的web项⽬例如jd 和百度),此时处理的是域名即localhost</p>
<p>2.3  Host将在Context中查找匹配第⼀级路径的Context(web项⽬)   处理的是第⼀级路径(ServletLesson)</p>
<p>2.4  读取ServletLesson项⽬的web.xml配置,查找匹配TestServlet的Servlet</p>
<p>2.5  实例化Servlet,调⽤Service根据请求类型执⾏对应的Get或Post ,处理的真正的客户端请求</p>
<p>2.6  Servlet响应⽅法执⾏完毕后,响应数据依次返回-&gt;Context-&gt;Host-&gt;engine-&gt;connector</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Tomcat</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>部署web到Tomcat的三种方式</title>
    <url>/2020/05/04/%E9%83%A8%E7%BD%B2web%E5%88%B0Tomcat%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>这里简单的记录tomcat的部署方式：</p>
<p>一、 直接将 web 项目文件（一般是复制生成的war包）复制到tomcat的webapps目录中 ；</p>
<p>二、在tomcat中的conf目录下的server.xml文件中，在<Host>节点中添加一个context，具体为：</Host></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">Path</span>=<span class="string">""</span> <span class="attr">Docbase</span>=<span class="string">"目标目录位置"</span> <span class="attr">Debug</span>=<span class="string">"0"</span> <span class="attr">Privileged</span>=<span class="string">"True"</span> <span class="attr">Reloadable</span>=<span class="string">"True"</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 Reloadable= “true” 这个属性是指tomcat在运行状态下会自动检测应用程序的WEB-INF/classes和WEB-INF/lib目录下的class文件，如果监测到有class文件有改动，服务器自动加载新的web应用程序，可以在不重起tomcat的情况下改变应用程序，也就是热部署；</p>
<p>一般我们会在开发阶段将Reloadable属性设为true，有助于调试servlet和其它的class文件，但是由于这样会增加服务器的运行负荷，损耗系统性能，在项目运行阶段建议将它设为false。</p>
<p>三、直接将编译后的项目复制到webapps中，直接访问</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式常见应用场景</title>
    <url>/2020/04/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="一、集合中的使用"><a href="#一、集合中的使用" class="headerlink" title="一、集合中的使用"></a>一、集合中的使用</h3><ul>
<li><h5 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化集合</span></span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"詹姆士"</span>,<span class="number">22</span>,<span class="string">"男"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"露西"</span>,<span class="number">21</span>,<span class="string">"女"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"弗兰克"</span>,<span class="number">25</span>,<span class="string">"男"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"爱丽丝"</span>,<span class="number">27</span>,<span class="string">"女"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"路易斯"</span>,<span class="number">22</span>,<span class="string">"男"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合 Lambda</span></span><br><span class="line">users.stream().forEach(user -&gt; System.out.println(user));</span><br><span class="line"><span class="comment">// 遍历集合 方法引用</span></span><br><span class="line">users.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>方法引用（::双冒号操作符）</strong></p>
<ol>
<li><p>其实就是一种Lambda表达式的简写方式，它提供了一种引用而不执行方法的方式，运行时，方法引用会创建一个函数式接口的实例。</p>
</li>
<li><p>方法引用的五种方式：</p>
<table>
<thead>
<tr>
<th align="center">—-</th>
<th align="center">—-</th>
</tr>
</thead>
<tbody><tr>
<td align="center">引用对象的实例方法</td>
<td align="center">对象::实例方法名</td>
</tr>
<tr>
<td align="center">引用类的静态方法</td>
<td align="center">类::静态方法名</td>
</tr>
<tr>
<td align="center">引用类的实例方法</td>
<td align="center">类::实例方法名</td>
</tr>
<tr>
<td align="center">引用构造方法</td>
<td align="center">类::new</td>
</tr>
<tr>
<td align="center">数组引用</td>
<td align="center">类型::new</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h5 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的toMap有三个参数，第一个取的名称为 key,第二个参数 表示整个user对象为一个 value,最后一个参数可以不加，它的作用是如果 key 值有重复的，如何处理</span></span><br><span class="line">Map&lt;String, User&gt; userMap = users.stream().collect(Collectors.toMap(User::getName, a -&gt; a, (k1, k2) -&gt; k1));</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="将List分组"><a href="#将List分组" class="headerlink" title="将List分组"></a>将List分组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据性别进行分类</span></span><br><span class="line">Map&lt;String, List&lt;User&gt;&gt; groupBy = users.stream().collect(Collectors.groupingBy(User::getSex));</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="集合过滤"><a href="#集合过滤" class="headerlink" title="集合过滤"></a>集合过滤</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤出男性</span></span><br><span class="line">List&lt;User&gt; filterList = users.stream().filter(user -&gt; user.getSex().equals(<span class="string">"男"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="集合求和"><a href="#集合求和" class="headerlink" title="集合求和"></a>集合求和</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 年龄和</span></span><br><span class="line"><span class="keyword">int</span> sum = users.stream().mapToInt(User::getAge).sum();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、代替Runnable"><a href="#二、代替Runnable" class="headerlink" title="二、代替Runnable"></a>二、代替Runnable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用Lambda实现Runnable里的run方法</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">   System.out.println(Thread.currentThread().getName());</span><br><span class="line"> &#125;  ;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="三、Predicate条件过滤"><a href="#三、Predicate条件过滤" class="headerlink" title="三、Predicate条件过滤"></a>三、Predicate条件过滤</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">       filter(numbers,number -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> (<span class="keyword">int</span>)number &gt; <span class="number">2</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 过滤方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List list, Predicate condition)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       list.forEach(number -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (condition.test(number))&#123;</span><br><span class="line">               System.out.println(number);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、Map映射"><a href="#四、Map映射" class="headerlink" title="四、Map映射"></a>四、Map映射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将返回一个将每个数字都×2的新List</span></span><br><span class="line">List&lt;Integer&gt; mapList = numbers.stream().map(number -&gt; number * <span class="number">2</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="五、Reduce聚合"><a href="#五、Reduce聚合" class="headerlink" title="五、Reduce聚合"></a>五、Reduce聚合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回所有成员的和</span></span><br><span class="line">Integer sum = numbers.stream().reduce((x, y) -&gt; x + y).get();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反射机制</title>
    <url>/2020/04/13/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JAVA反射机制"><a href="#JAVA反射机制" class="headerlink" title="JAVA反射机制"></a>JAVA反射机制</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>java反射机制是在运行状态中，对于任意一个类，都能够得到这个类的所有属性和方法；对于任意一个对象，都能调用它的任意方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为<strong>反射机制</strong></p>
<h3 id="获取Class对象的两种方式"><a href="#获取Class对象的两种方式" class="headerlink" title="获取Class对象的两种方式"></a>获取Class对象的两种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.如果我们知道具体的类,可以使用下面的代码，[类名.class];但是通常情况下我们是不知道具体的类的，并且还需要导入类的包，依赖太强。</span></span><br><span class="line">Class targetClass = TargetObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过[Class.forName()]小括号中传入类的字符串路径获取，字符串可以写在配置文件中。</span></span><br><span class="line">Class targetClass = Class.forName(<span class="string">"frosro.test.TargetObject"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.其实还有一种方法，继承自Object类的getClass方法，如下，但这样对象都已经存在了，我们再用反射就多此一举了。</span></span><br><span class="line">TargetObject targetObject = <span class="keyword">new</span> TargetObject();</span><br><span class="line">Class targetClass = targetObject.getClass();</span><br></pre></td></tr></table></figure>

<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>首先创建一个我们将要操作的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 21:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = <span class="string">"initVal"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I love "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用反射来操作这个类的方法和参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package fanshe;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author sy</span><br><span class="line"> * @data \ 21:36</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取TargetObject类的Class对象</span><br><span class="line">        Class&lt;?&gt; tagetClass  &#x3D; Class.forName(&quot;fanshe.TargetObject&quot;);</span><br><span class="line">        &#x2F;&#x2F; 创建一个TargetObject类的实例</span><br><span class="line">        TargetObject targetObject &#x3D; (TargetObject)tagetClass .newInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取类中所有定义的方法</span><br><span class="line">        Method[] methods &#x3D; tagetClass.getDeclaredMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环输出方法名称</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取指定方法并调用</span><br><span class="line">        Method publicMethod &#x3D; tagetClass.getDeclaredMethod(&quot;publicMethod&quot;, String.class);</span><br><span class="line">        publicMethod.invoke(targetObject,&quot;frosro&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取指定参数</span><br><span class="line">        Field field &#x3D; tagetClass.getDeclaredField(&quot;value&quot;);</span><br><span class="line">        &#x2F;&#x2F; 取消安全检查，这样我们就可以访问到私有的属性和方法</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        &#x2F;&#x2F; 对参数进行修改</span><br><span class="line">        field.set(targetObject,&quot;frosro&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 调用私有的方法</span><br><span class="line">        Method privateMethod &#x3D; tagetClass.getDeclaredMethod(&quot;privateMethod&quot;);</span><br><span class="line">        privateMethod.setAccessible(true);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有其他很多方法，可以翻看文档查找；</p>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li><p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。 </p>
</li>
<li><p>缺点：  </p>
<p>1.性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。</p>
<p>2.安全问题：让我们可以动态操作改变类的属性同时也增加了类的安全隐患。 </p>
</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
</ol>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA集合的多种遍历方式总结</title>
    <url>/2020/03/29/JAVA%E9%9B%86%E5%90%88%E7%9A%84%E5%A4%9A%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Collection 集合 :  总的来说分为以下这三类，这里更多的子类我便不在阐述了。</li>
</ol>
<ul>
<li>Set ： 无序集合，元素不可重复；</li>
<li>Queue  ： 队列；</li>
<li>List ： 有序集合，元素可以重复；</li>
</ul>
<ol start="2">
<li>Map集合 ：一般用于保存拥有映射关系的数据，也就是 key-value 键值对，它也有很多子类，这里不细说；</li>
</ol>
<hr>
<p>本文以HashSet 为例，总结遍历方式。当然像List这种有序集合还可以通过for循环的方式遍历。</p>
<p><strong>下面是主要内容：</strong></p>
<h3 id="一、使用-Lambda-表达式遍历集合"><a href="#一、使用-Lambda-表达式遍历集合" class="headerlink" title="一、使用 Lambda 表达式遍历集合"></a>一、使用 Lambda 表达式遍历集合</h3><p>从 JDK8 开始，Iterable 接口新增了 forEach(Consumer action)方法，主要 是使用 Lambda 表达式更加简洁的操作。Consumer 其实是一个函数式接 口，只要是函数式接口，都能够使用 Lambda 表示来进行替代。在调用这 个方法的时候，其实会依次将集合的元素传递给 Consumer 中的 accept(T t) 方法去处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 21:34</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CollectionEach &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line">        books.forEach(str -&gt; System.out.println(&quot;书名：&quot;  + str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、-使用-Iterator-遍历集合元素"><a href="#二、-使用-Iterator-遍历集合元素" class="headerlink" title="二、 使用 Iterator 遍历集合元素"></a>二、 使用 Iterator 遍历集合元素</h3><p>Iterator 主要用来遍历 Conllection 集合中的元素，也叫迭代器。它只能用于遍历集合。</p>
<p>常用方法如下：</p>
<ul>
<li>hasNext()：判断集合中还有没有元素，如果有则返回 true。 </li>
<li>next()：取出集合中的下一个元素。 </li>
<li>remove()：移除上面 next() 方法中读取的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 21:48</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IteratorTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过 iterator() 方法，获取 books 集合对应的迭 代器</span><br><span class="line">        Iterator&lt;String&gt; iterator &#x3D; books.iterator();</span><br><span class="line"></span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String next &#x3D; iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 对 next 变量赋值，不会改变集合元素本身</span><br><span class="line">            &#x2F;&#x2F; Iterator 并不会把集合元素本身交给迭代变 量，</span><br><span class="line">            &#x2F;&#x2F; 而是把集合元素的值交给了迭代变量</span><br><span class="line">            &#x2F;&#x2F; 所以在修改迭代变量的值之后对集合远古三本身并 没有任何覆盖。</span><br><span class="line">            next &#x3D; &quot;设计模式&quot;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果我们在使用迭代器的过程中改变了集合元素的值，也就是books,比如</span><br><span class="line">            &#x2F;&#x2F; books.remove(next);</span><br><span class="line">            &#x2F;&#x2F; 上面这行代码运行会报 ConcurrentModificationException 异常</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上，是因为 Iterator 迭代器使用了 fail-fast 机制（快速失败机制）， 在迭代过程中一旦发现有其他线程来修改该集合，则马上报 ConcurrentModicationException 异常，这样做可以避免共享资源而埋下其他隐患问题。</p>
<h3 id="三、-使用-Lambda-表达式遍历-Iterator"><a href="#三、-使用-Lambda-表达式遍历-Iterator" class="headerlink" title="三、 使用 Lambda 表达式遍历 Iterator"></a>三、 使用 Lambda 表达式遍历 Iterator</h3><p>核心方法：</p>
<ul>
<li>forEachRemaining()：JDK8 新增方法，使用 Lambda 表达式来遍历集合元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:06</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IteratorEach &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator &#x3D; books.iterator();</span><br><span class="line"></span><br><span class="line">        iterator.forEachRemaining(str -&gt; System.out.println(&quot;迭代集合元素：&quot; + str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、-使用-foreach-循环遍历集合元素"><a href="#四、-使用-foreach-循环遍历集合元素" class="headerlink" title="四、  使用 foreach 循环遍历集合元素"></a>四、  使用 foreach 循环遍历集合元素</h3><p>foreach 循环，是我们常用的一种遍历方式。另外，foreach 循环中迭代变量也不是集合元素本身，其实也是把每个集合元素的值赋给了迭代变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:13</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ForeachTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        for (String book : books) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 改变book的值，并不会改变books集合的数据</span><br><span class="line">            &#x2F;&#x2F; 因为book只是保存着books其中的一个值</span><br><span class="line">            book &#x3D; &quot;设计模式&quot;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 同样的，我们也不能在遍历时改变原有的集合books</span><br><span class="line">            &#x2F;&#x2F; 如果像下面这种方式，会报 ConcurrentModificationException</span><br><span class="line">            &#x2F;&#x2F; books.remove(book);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、-使用-Stream遍历集合"><a href="#五、-使用-Stream遍历集合" class="headerlink" title="五、  使用 Stream遍历集合"></a>五、  使用 Stream遍历集合</h3><p>JDK8 新增了 Stream、IntStream、LongStream、DoubleStream 等强悍的 流式 API，代表多个支持串行 &amp; 并行聚集操作的元素。还可以通过特别提 供的 Builder 来创建对应的流。</p>
<p>使用步骤：</p>
<p> 1）使用 Stream 或 XxxStream 的 builder() 方法初始化对应 的 Builder。<br>2）多次调用 Builder 的 add() 方法，添加元素<br>3）调用 Builder 的 build() 方法获取对应的 Stream。<br>4）调用 Stream 的聚集方法。（具体参考 API 文档）</p>
<p>Stream 提供了很多方法，可以归类为两种：</p>
<ul>
<li>Intermediate（中间方法）<br>中间方法，指的是中间操作允许流保持打开状态，并允许直接调用后续方 法，中间方法的返回值是另外一个流。</li>
<li>Terminal（末端方法）<br>末端方法，指的是对流的终操作，执行过后，该流就会被“消耗”且不再可用。因为我们在操作的时候，是在内存中的缓存中，如果操作完毕，它将会从缓冲中刷新flush() 出来，就不能再改了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:29</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IntStreamTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       Stream stream &#x3D; Stream.builder()</span><br><span class="line">               .add(&quot;编程思想&quot;)</span><br><span class="line">                .add(&quot;核心技术&quot;)</span><br><span class="line">                .add(&quot;从入门到放弃&quot;).build();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 当然，这里不可避免的用到了forEach</span><br><span class="line">       stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者是这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:29</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IntStreamTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        books.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能你会觉得这和第一种方式很像，我测试了一下，这两者效率也相差无几。<br>但是stream流却是目前必须掌握的方式。因为它的一些其他用法都颇为重要。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>循环</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博文</title>
    <url>/2020/03/28/myfirstPage/</url>
    <content><![CDATA[<p>我的个人博客算是建立了，中间遇到比较坑的就是，我想要使用java做分类，但总是报404，但是JAVA却可以，没找到原因；还有就是阿里云的域名真的是坑，提交了十几个实名认证还是没通过，太考验耐心了。markdown还不太会用，渐渐熟练吧，之后我会把遇到的好的经验分享到这个博客，其他教程什么的网上太多了，我就不在这上面添加了，我只写我认为有价值的博文，如果哪位同学有问题或者想要和我在技术上交流，可以联系我，我会非常乐意分享我所知道的信息。大家一起学习，共同进步为社会主义做贡献！</p>
]]></content>
      <categories>
        <category>🐟台小记</category>
      </categories>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
</search>
