<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>事务传播行为与事务隔离级别</title>
    <url>/2020/06/04/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h4 id="事务读传播行为"><a href="#事务读传播行为" class="headerlink" title="事务读传播行为"></a>事务读传播行为</h4><h6 id="·-保证同一个事务中"><a href="#·-保证同一个事务中" class="headerlink" title="· 保证同一个事务中"></a>· 保证同一个事务中</h6><p>PROPAGATION_REQUIRED支持当前事务，如果不存在，就新建一个（默认）<br>PROPAGATION_SUPPORTS支持当前事务，如果不存在，就不适用事务<br>PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常</p>
<h6 id="·-保证没有在同一个事务中"><a href="#·-保证没有在同一个事务中" class="headerlink" title="· 保证没有在同一个事务中"></a>· 保证没有在同一个事务中</h6><p>PROPAGATION_REQUIRES_NEW如果有事务存在，挂起当前事务，创建一个新的事务<br>PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务<br>PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常<br>PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>DEFAULT这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别；</p>
<h6 id="未提交读（read-uncommitted）："><a href="#未提交读（read-uncommitted）：" class="headerlink" title="未提交读（read uncommitted）："></a>未提交读（read uncommitted）：</h6><p>​    事务的修改，即使当前事务没有被提交，对其他事务而言也是可见的。事务可以读取未提交的数据，也称为脏读。这个级别会导致很多问题，性能上也不比其他级别好多少，一般不会使用；</p>
<h6 id="已提交读（read-committed）："><a href="#已提交读（read-committed）：" class="headerlink" title="已提交读（read committed）："></a>已提交读（read committed）：</h6><p>​    大部分数据库系统的默认隔离级别都是read committed（Mysql 不是），它表示一个事务只能看到已经提交的事务所做的修改。换个角度来讲，就是一个事务从开始到提交之前，所做的操作对别的操作都是不可见的。此隔离级别也被称为（<strong>不可重复读</strong>），因为多次执行同样的查询语句，可能会得出不一样的结果，因为可能有别的事务提交了。</p>
<h6 id="可重复读（repeatable-read）："><a href="#可重复读（repeatable-read）：" class="headerlink" title="可重复读（repeatable read）："></a>可重复读（repeatable read）：</h6><p>​    repeatable read解决了脏读的问题，该隔离级别保证了在同一个事务中每次读取都是同样的结果，但是还是无法解决幻读的问题。（<strong>幻读：</strong>指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再读取该范围内的记录时，会产生幻行；）【这是高性能Mysql中的解释，我的个人理解为：先读取的事务读不到后来新添加的记录，导致读取不准确】。但InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题，后面我会详细写到。</p>
<h6 id="可串行化的（serializable）："><a href="#可串行化的（serializable）：" class="headerlink" title="可串行化的（serializable）："></a>可串行化的（serializable）：</h6><p>强制事务串行执行，由于可能会导致大量的超时和锁争用，通常不考虑。<br>MySQL默认：可重复读<br>Oracle默认：已提交读</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet学习笔记</title>
    <url>/2020/05/04/servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="1-Tomcat主要在程序中做了些什么？"><a href="#1-Tomcat主要在程序中做了些什么？" class="headerlink" title="1.Tomcat主要在程序中做了些什么？"></a>1.Tomcat主要在程序中做了些什么？</h3><p>1.1  创建socket监听在对应的端口</p>
<p>1.2  维护一个线程池</p>
<p>1.3  当有TCP连接时分配一个线程来处理</p>
<p>1.4  从TCP连接中读取数据</p>
<p>1.5  按照HTTP协议解析数据</p>
<p>1.6  将解析后的数据包封装到request对象中</p>
<p>1.7  按照web.xml的映射关系找到对应的Servlet类</p>
<p>1.8  将最后的执行结果response组装成HTTP协议格式的数据包</p>
<p>1.9  重新通过TCP返回给客户端</p>
<h3 id="2-访问servlet-的过程"><a href="#2-访问servlet-的过程" class="headerlink" title="2.访问servlet 的过程"></a>2.访问servlet 的过程</h3><p>2.1  connector 负责监听端⼝,当有链接进来时分配线程并实例化HttpllProcessor对数据进⾏ HTTP协议解析,然后将请求交给其所在的engine即Catalina来处理,处理的是域名对应的ip和 端⼝8080 ,注意localhost任然没被使⽤ </p>
<p>2.2  engine将从HTTP请求头中获取host参数⽤于选择⼀个匹配的Host   处理的是主机名 localhost(Host可以配置多个,即你可以在⼀台电脑上部署两个完全不相关的web项⽬例如jd 和百度),此时处理的是域名即localhost</p>
<p>2.3  Host将在Context中查找匹配第⼀级路径的Context(web项⽬)   处理的是第⼀级路径(ServletLesson)</p>
<p>2.4  读取ServletLesson项⽬的web.xml配置,查找匹配TestServlet的Servlet</p>
<p>2.5  实例化Servlet,调⽤Service根据请求类型执⾏对应的Get或Post ,处理的真正的客户端请求</p>
<p>2.6  Servlet响应⽅法执⾏完毕后,响应数据依次返回-&gt;Context-&gt;Host-&gt;engine-&gt;connector</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Tomcat</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>部署web到Tomcat的三种方式</title>
    <url>/2020/05/04/%E9%83%A8%E7%BD%B2web%E5%88%B0Tomcat%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>这里简单的记录tomcat的部署方式：</p>
<p>一、 直接将 web 项目文件（一般是复制生成的war包）复制到tomcat的webapps目录中 ；</p>
<p>二、在tomcat中的conf目录下的server.xml文件中，在<Host>节点中添加一个context，具体为：</Host></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">Path</span>=<span class="string">""</span> <span class="attr">Docbase</span>=<span class="string">"目标目录位置"</span> <span class="attr">Debug</span>=<span class="string">"0"</span> <span class="attr">Privileged</span>=<span class="string">"True"</span> <span class="attr">Reloadable</span>=<span class="string">"True"</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 Reloadable= “true” 这个属性是指tomcat在运行状态下会自动检测应用程序的WEB-INF/classes和WEB-INF/lib目录下的class文件，如果监测到有class文件有改动，服务器自动加载新的web应用程序，可以在不重起tomcat的情况下改变应用程序，也就是热部署；</p>
<p>一般我们会在开发阶段将Reloadable属性设为true，有助于调试servlet和其它的class文件，但是由于这样会增加服务器的运行负荷，损耗系统性能，在项目运行阶段建议将它设为false。</p>
<p>三、直接将编译后的项目复制到webapps中，直接访问</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式常见应用场景</title>
    <url>/2020/04/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="一、集合中的使用"><a href="#一、集合中的使用" class="headerlink" title="一、集合中的使用"></a>一、集合中的使用</h3><ul>
<li><h5 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化集合</span></span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"詹姆士"</span>,<span class="number">22</span>,<span class="string">"男"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"露西"</span>,<span class="number">21</span>,<span class="string">"女"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"弗兰克"</span>,<span class="number">25</span>,<span class="string">"男"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"爱丽丝"</span>,<span class="number">27</span>,<span class="string">"女"</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"路易斯"</span>,<span class="number">22</span>,<span class="string">"男"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合 Lambda</span></span><br><span class="line">users.stream().forEach(user -&gt; System.out.println(user));</span><br><span class="line"><span class="comment">// 遍历集合 方法引用</span></span><br><span class="line">users.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>方法引用（::双冒号操作符）</strong></p>
<ol>
<li><p>其实就是一种Lambda表达式的简写方式，它提供了一种引用而不执行方法的方式，运行时，方法引用会创建一个函数式接口的实例。</p>
</li>
<li><p>方法引用的五种方式：</p>
<table>
<thead>
<tr>
<th align="center">—-</th>
<th align="center">—-</th>
</tr>
</thead>
<tbody><tr>
<td align="center">引用对象的实例方法</td>
<td align="center">对象::实例方法名</td>
</tr>
<tr>
<td align="center">引用类的静态方法</td>
<td align="center">类::静态方法名</td>
</tr>
<tr>
<td align="center">引用类的实例方法</td>
<td align="center">类::实例方法名</td>
</tr>
<tr>
<td align="center">引用构造方法</td>
<td align="center">类::new</td>
</tr>
<tr>
<td align="center">数组引用</td>
<td align="center">类型::new</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h5 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的toMap有三个参数，第一个取的名称为 key,第二个参数 表示整个user对象为一个 value,最后一个参数可以不加，它的作用是如果 key 值有重复的，如何处理</span></span><br><span class="line">Map&lt;String, User&gt; userMap = users.stream().collect(Collectors.toMap(User::getName, a -&gt; a, (k1, k2) -&gt; k1));</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="将List分组"><a href="#将List分组" class="headerlink" title="将List分组"></a>将List分组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据性别进行分类</span></span><br><span class="line">Map&lt;String, List&lt;User&gt;&gt; groupBy = users.stream().collect(Collectors.groupingBy(User::getSex));</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="集合过滤"><a href="#集合过滤" class="headerlink" title="集合过滤"></a>集合过滤</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤出男性</span></span><br><span class="line">List&lt;User&gt; filterList = users.stream().filter(user -&gt; user.getSex().equals(<span class="string">"男"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="集合求和"><a href="#集合求和" class="headerlink" title="集合求和"></a>集合求和</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 年龄和</span></span><br><span class="line"><span class="keyword">int</span> sum = users.stream().mapToInt(User::getAge).sum();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二、代替Runnable"><a href="#二、代替Runnable" class="headerlink" title="二、代替Runnable"></a>二、代替Runnable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用Lambda实现Runnable里的run方法</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">   System.out.println(Thread.currentThread().getName());</span><br><span class="line"> &#125;  ;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="三、Predicate条件过滤"><a href="#三、Predicate条件过滤" class="headerlink" title="三、Predicate条件过滤"></a>三、Predicate条件过滤</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">       filter(numbers,number -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> (<span class="keyword">int</span>)number &gt; <span class="number">2</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 过滤方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List list, Predicate condition)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       list.forEach(number -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (condition.test(number))&#123;</span><br><span class="line">               System.out.println(number);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、Map映射"><a href="#四、Map映射" class="headerlink" title="四、Map映射"></a>四、Map映射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将返回一个将每个数字都×2的新List</span></span><br><span class="line">List&lt;Integer&gt; mapList = numbers.stream().map(number -&gt; number * <span class="number">2</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="五、Reduce聚合"><a href="#五、Reduce聚合" class="headerlink" title="五、Reduce聚合"></a>五、Reduce聚合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回所有成员的和</span></span><br><span class="line">Integer sum = numbers.stream().reduce((x, y) -&gt; x + y).get();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反射机制</title>
    <url>/2020/04/13/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JAVA反射机制"><a href="#JAVA反射机制" class="headerlink" title="JAVA反射机制"></a>JAVA反射机制</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>java反射机制是在运行状态中，对于任意一个类，都能够得到这个类的所有属性和方法；对于任意一个对象，都能调用它的任意方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为<strong>反射机制</strong></p>
<h3 id="获取Class对象的两种方式"><a href="#获取Class对象的两种方式" class="headerlink" title="获取Class对象的两种方式"></a>获取Class对象的两种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.如果我们知道具体的类,可以使用下面的代码，[类名.class];但是通常情况下我们是不知道具体的类的，并且还需要导入类的包，依赖太强。</span></span><br><span class="line">Class targetClass = TargetObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过[Class.forName()]小括号中传入类的字符串路径获取，字符串可以写在配置文件中。</span></span><br><span class="line">Class targetClass = Class.forName(<span class="string">"frosro.test.TargetObject"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.其实还有一种方法，继承自Object类的getClass方法，如下，但这样对象都已经存在了，我们再用反射就多此一举了。</span></span><br><span class="line">TargetObject targetObject = <span class="keyword">new</span> TargetObject();</span><br><span class="line">Class targetClass = targetObject.getClass();</span><br></pre></td></tr></table></figure>

<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>首先创建一个我们将要操作的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 21:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = <span class="string">"initVal"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I love "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用反射来操作这个类的方法和参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package fanshe;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author sy</span><br><span class="line"> * @data \ 21:36</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取TargetObject类的Class对象</span><br><span class="line">        Class&lt;?&gt; tagetClass  &#x3D; Class.forName(&quot;fanshe.TargetObject&quot;);</span><br><span class="line">        &#x2F;&#x2F; 创建一个TargetObject类的实例</span><br><span class="line">        TargetObject targetObject &#x3D; (TargetObject)tagetClass .newInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取类中所有定义的方法</span><br><span class="line">        Method[] methods &#x3D; tagetClass.getDeclaredMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环输出方法名称</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取指定方法并调用</span><br><span class="line">        Method publicMethod &#x3D; tagetClass.getDeclaredMethod(&quot;publicMethod&quot;, String.class);</span><br><span class="line">        publicMethod.invoke(targetObject,&quot;frosro&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取指定参数</span><br><span class="line">        Field field &#x3D; tagetClass.getDeclaredField(&quot;value&quot;);</span><br><span class="line">        &#x2F;&#x2F; 取消安全检查，这样我们就可以访问到私有的属性和方法</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        &#x2F;&#x2F; 对参数进行修改</span><br><span class="line">        field.set(targetObject,&quot;frosro&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 调用私有的方法</span><br><span class="line">        Method privateMethod &#x3D; tagetClass.getDeclaredMethod(&quot;privateMethod&quot;);</span><br><span class="line">        privateMethod.setAccessible(true);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有其他很多方法，可以翻看文档查找；</p>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li><p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。 </p>
</li>
<li><p>缺点：  </p>
<p>1.性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。</p>
<p>2.安全问题：让我们可以动态操作改变类的属性同时也增加了类的安全隐患。 </p>
</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
</ol>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA集合的多种遍历方式总结</title>
    <url>/2020/03/29/JAVA%E9%9B%86%E5%90%88%E7%9A%84%E5%A4%9A%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>Collection 集合 :  总的来说分为以下这三类，这里更多的子类我便不在阐述了。</li>
</ol>
<ul>
<li>Set ： 无序集合，元素不可重复；</li>
<li>Queue  ： 队列；</li>
<li>List ： 有序集合，元素可以重复；</li>
</ul>
<ol start="2">
<li>Map集合 ：一般用于保存拥有映射关系的数据，也就是 key-value 键值对，它也有很多子类，这里不细说；</li>
</ol>
<hr>
<p>本文以HashSet 为例，总结遍历方式。当然像List这种有序集合还可以通过for循环的方式遍历。</p>
<p><strong>下面是主要内容：</strong></p>
<h3 id="一、使用-Lambda-表达式遍历集合"><a href="#一、使用-Lambda-表达式遍历集合" class="headerlink" title="一、使用 Lambda 表达式遍历集合"></a>一、使用 Lambda 表达式遍历集合</h3><p>从 JDK8 开始，Iterable 接口新增了 forEach(Consumer action)方法，主要 是使用 Lambda 表达式更加简洁的操作。Consumer 其实是一个函数式接 口，只要是函数式接口，都能够使用 Lambda 表示来进行替代。在调用这 个方法的时候，其实会依次将集合的元素传递给 Consumer 中的 accept(T t) 方法去处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 21:34</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CollectionEach &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line">        books.forEach(str -&gt; System.out.println(&quot;书名：&quot;  + str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、-使用-Iterator-遍历集合元素"><a href="#二、-使用-Iterator-遍历集合元素" class="headerlink" title="二、 使用 Iterator 遍历集合元素"></a>二、 使用 Iterator 遍历集合元素</h3><p>Iterator 主要用来遍历 Conllection 集合中的元素，也叫迭代器。它只能用于遍历集合。</p>
<p>常用方法如下：</p>
<ul>
<li>hasNext()：判断集合中还有没有元素，如果有则返回 true。 </li>
<li>next()：取出集合中的下一个元素。 </li>
<li>remove()：移除上面 next() 方法中读取的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 21:48</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IteratorTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过 iterator() 方法，获取 books 集合对应的迭 代器</span><br><span class="line">        Iterator&lt;String&gt; iterator &#x3D; books.iterator();</span><br><span class="line"></span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String next &#x3D; iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 对 next 变量赋值，不会改变集合元素本身</span><br><span class="line">            &#x2F;&#x2F; Iterator 并不会把集合元素本身交给迭代变 量，</span><br><span class="line">            &#x2F;&#x2F; 而是把集合元素的值交给了迭代变量</span><br><span class="line">            &#x2F;&#x2F; 所以在修改迭代变量的值之后对集合远古三本身并 没有任何覆盖。</span><br><span class="line">            next &#x3D; &quot;设计模式&quot;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果我们在使用迭代器的过程中改变了集合元素的值，也就是books,比如</span><br><span class="line">            &#x2F;&#x2F; books.remove(next);</span><br><span class="line">            &#x2F;&#x2F; 上面这行代码运行会报 ConcurrentModificationException 异常</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上，是因为 Iterator 迭代器使用了 fail-fast 机制（快速失败机制）， 在迭代过程中一旦发现有其他线程来修改该集合，则马上报 ConcurrentModicationException 异常，这样做可以避免共享资源而埋下其他隐患问题。</p>
<h3 id="三、-使用-Lambda-表达式遍历-Iterator"><a href="#三、-使用-Lambda-表达式遍历-Iterator" class="headerlink" title="三、 使用 Lambda 表达式遍历 Iterator"></a>三、 使用 Lambda 表达式遍历 Iterator</h3><p>核心方法：</p>
<ul>
<li>forEachRemaining()：JDK8 新增方法，使用 Lambda 表达式来遍历集合元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:06</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IteratorEach &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator &#x3D; books.iterator();</span><br><span class="line"></span><br><span class="line">        iterator.forEachRemaining(str -&gt; System.out.println(&quot;迭代集合元素：&quot; + str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、-使用-foreach-循环遍历集合元素"><a href="#四、-使用-foreach-循环遍历集合元素" class="headerlink" title="四、  使用 foreach 循环遍历集合元素"></a>四、  使用 foreach 循环遍历集合元素</h3><p>foreach 循环，是我们常用的一种遍历方式。另外，foreach 循环中迭代变量也不是集合元素本身，其实也是把每个集合元素的值赋给了迭代变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:13</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ForeachTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        for (String book : books) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 改变book的值，并不会改变books集合的数据</span><br><span class="line">            &#x2F;&#x2F; 因为book只是保存着books其中的一个值</span><br><span class="line">            book &#x3D; &quot;设计模式&quot;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 同样的，我们也不能在遍历时改变原有的集合books</span><br><span class="line">            &#x2F;&#x2F; 如果像下面这种方式，会报 ConcurrentModificationException</span><br><span class="line">            &#x2F;&#x2F; books.remove(book);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、-使用-Stream遍历集合"><a href="#五、-使用-Stream遍历集合" class="headerlink" title="五、  使用 Stream遍历集合"></a>五、  使用 Stream遍历集合</h3><p>JDK8 新增了 Stream、IntStream、LongStream、DoubleStream 等强悍的 流式 API，代表多个支持串行 &amp; 并行聚集操作的元素。还可以通过特别提 供的 Builder 来创建对应的流。</p>
<p>使用步骤：</p>
<p> 1）使用 Stream 或 XxxStream 的 builder() 方法初始化对应 的 Builder。<br>2）多次调用 Builder 的 add() 方法，添加元素<br>3）调用 Builder 的 build() 方法获取对应的 Stream。<br>4）调用 Stream 的聚集方法。（具体参考 API 文档）</p>
<p>Stream 提供了很多方法，可以归类为两种：</p>
<ul>
<li>Intermediate（中间方法）<br>中间方法，指的是中间操作允许流保持打开状态，并允许直接调用后续方 法，中间方法的返回值是另外一个流。</li>
<li>Terminal（末端方法）<br>末端方法，指的是对流的终操作，执行过后，该流就会被“消耗”且不再可用。因为我们在操作的时候，是在内存中的缓存中，如果操作完毕，它将会从缓冲中刷新flush() 出来，就不能再改了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:29</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IntStreamTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       Stream stream &#x3D; Stream.builder()</span><br><span class="line">               .add(&quot;编程思想&quot;)</span><br><span class="line">                .add(&quot;核心技术&quot;)</span><br><span class="line">                .add(&quot;从入门到放弃&quot;).build();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 当然，这里不可避免的用到了forEach</span><br><span class="line">       stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者是这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author frosro</span><br><span class="line"> * @data 22:29</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IntStreamTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; books &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        books.add(&quot;编程思想&quot;);</span><br><span class="line">        books.add(&quot;核心技术&quot;);</span><br><span class="line">        books.add(&quot;从入门到放弃&quot;);</span><br><span class="line"></span><br><span class="line">        books.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能你会觉得这和第一种方式很像，我测试了一下，这两者效率也相差无几。<br>但是stream流却是目前必须掌握的方式。因为它的一些其他用法都颇为重要。</p>
]]></content>
      <categories>
        <category>🐺JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>循环</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博文</title>
    <url>/2020/03/28/myfirstPage/</url>
    <content><![CDATA[<p>我的个人博客算是建立了，中间遇到比较坑的就是，我想要使用java做分类，但总是报404，但是JAVA却可以，没找到原因；还有就是阿里云的域名真的是坑，提交了十几个实名认证还是没通过，太考验耐心了。markdown还不太会用，渐渐熟练吧，之后我会把遇到的好的经验分享到这个博客，其他教程什么的网上太多了，我就不在这上面添加了，我只写我认为有价值的博文，如果哪位同学有问题或者想要和我在技术上交流，可以联系我，我会非常乐意分享我所知道的信息。大家一起学习，共同进步为社会主义做贡献！</p>
]]></content>
      <categories>
        <category>🐟台小记</category>
      </categories>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
</search>
